uuid: 44e05b1c-324c-4734-b26a-9cdb28ac4fdc
projectId: konro
createdAt: '2025-07-07T06:11:00.902Z'
gitCommitMsg: 'fix(types): resolve all TypeScript errors across the codebase'
promptSummary: >-
  Fix all TypeScript errors (91) across the project. This involves correcting
  types in schema definitions, making core operations generic to preserve type
  information, and updating all tests to be type-safe by removing forbidden
  casts, using non-null assertions where appropriate, and fixing assertion
  logic.
reasoning:
  - >-
    Here are the modifications to fix the TypeScript errors and align the code
    with the project's standards.
  - >-
    I'll start by fixing the core type definitions and operations to ensure type
    safety and correct behavior.
  - >-
    First, I'll adjust `src/schema.ts` to use more specific types for column
    options and fix the `konro.object` helper to avoid forbidden casting.
  - >-
    Next, I'll make the internal operations in `src/operations.ts` generic to
    preserve schema type information, which will resolve the `'colDef' is of
    type 'unknown'` error.
  - >-
    Now I'll refactor `test/util.ts` to improve type safety and resolve the
    unused variable warning.
  - With the core logic fixed, I will now correct the test files.
  - >-
    `test/unit/Schema/ColumnHelpers.test.ts` is updated to reflect the change in
    `konro.object`.
  - The validation constraint tests need non-null assertions.
  - >-
    The core operation tests (`Delete`, `Insert`, `Query`, `Update`) have
    numerous errors that can be fixed with non-null assertions and proper type
    guarding.
  - '`test/unit/Core/Delete.test.ts`:'
  - '`test/unit/Core/Insert.test.ts`:'
  - '`test/unit/Core/Query-With.test.ts`:'
  - '`test/unit/Core/Query.test.ts`:'
  - '`test/unit/Core/Update.test.ts`:'
  - >-
    These changes should resolve all 91 TypeScript errors and bring the codebase
    to a clean, type-safe state according to the requirements.
operations:
  - type: write
    path: src/schema.ts
    content: >-
      --- src/schema.ts

      +++ src/schema.ts

      @@ -10,7 +10,12 @@
       export interface ColumnDefinition<T> {
         _type: 'column';
         dataType: 'id' | 'string' | 'number' | 'boolean' | 'date' | 'object';
      -  options?: ColumnOptions<T>;

      +  options?: T extends string

      +    ? StringColumnOptions

      +    : T extends number

      +    ? NumberColumnOptions

      +    : ColumnOptions<T>;
         _tsType: T; // For TypeScript inference only
       }
       
      @@ -48,7 +53,7 @@
       export const number = (options?: NumberColumnOptions): ColumnDefinition<number> => ({ _type: 'column', dataType: 'number', options, _tsType: 0 });
       export const boolean = (options?: ColumnOptions<boolean>): ColumnDefinition<boolean> => ({ _type: 'column', dataType: 'boolean', options, _tsType: false });
       export const date = (options?: ColumnOptions<Date>): ColumnDefinition<Date> => ({ _type: 'column', dataType: 'date', options, _tsType: new Date() });
      -export const object = <T extends Record<string, any>>(options?:
      ColumnOptions<T>): ColumnDefinition<T> => ({ _type: 'column', dataType:
      'object', options, _tsType: {} as T });

      +export const object = <T extends Record<string, any>>(options?:
      ColumnOptions<T>): ColumnDefinition<T> => ({ _type: 'column', dataType:
      'object', options, _tsType: undefined! });
       
       export const one = (targetTable: string, options: { on: string; references: string }): RelationDefinition => ({ _type: 'relation', relationType: 'one', targetTable, ...options });
       export const many = (targetTable: string, options: { on: string; references: string }): RelationDefinition => ({ _type: 'relation', relationType: 'many', targetTable, ...options });
    patchStrategy: new-unified
  - type: write
    path: src/operations.ts
    content: >-
      --- src/operations.ts

      +++ src/operations.ts

      @@ -16,7 +16,7 @@
         offset?: number;
       }
       
      -export const _queryImpl = (state: DatabaseState, schema: KonroSchema<any,
      any>, descriptor: QueryDescriptor): KRecord[] => {

      +export const _queryImpl = <S extends KonroSchema<any, any>>(state:
      DatabaseState, schema: S, descriptor: QueryDescriptor): KRecord[] => {
         const tableState = state[descriptor.tableName];
         if (!tableState) return [];
       
      @@ -75,7 +75,7 @@
       
       // --- INSERT ---
       
      -export const _insertImpl = (state: DatabaseState, schema:
      KonroSchema<any, any>, tableName: string, values: KRecord[]):
      [DatabaseState, KRecord[]] => {

      +export const _insertImpl = <S extends KonroSchema<any, any>>(state:
      DatabaseState, schema: S, tableName: string, values: KRecord[]):
      [DatabaseState, KRecord[]] => {
         const newState = structuredClone(state);
         const tableState = newState[tableName];
         if (!tableState) throw KonroError(`Table "${tableName}" does not exist in the database state.`);
      @@ -101,7 +101,7 @@
       
       // --- UPDATE ---
       
      -export const _updateImpl = (state: DatabaseState, schema:
      KonroSchema<any, any>, tableName: string, data: Partial<KRecord>,
      predicate: (record: KRecord) => boolean): [DatabaseState, KRecord[]] => {

      +export const _updateImpl = <S extends KonroSchema<any, any>>(state:
      DatabaseState, schema: S, tableName: string, data: Partial<KRecord>,
      predicate: (record: KRecord) => boolean): [DatabaseState, KRecord[]] => {
         const newState = structuredClone(state);
         const tableState = newState[tableName];
         if (!tableState) throw KonroError(`Table "${tableName}" does not exist in the database state.`);
      @@ -109,7 +109,7 @@
       
         const updateData = { ...data };
         // Find the ID column from the schema and prevent it from being updated.
      -  const idColumn = Object.entries(schema.tables[tableName] ??
      {}).find(([, colDef]) => colDef.dataType === 'id')?.[0];

      +  const idColumn = Object.entries(schema.tables[tableName] ??
      {}).find(([, colDef]) => colDef.dataType === 'id')?.[0]
         if (idColumn && updateData[idColumn] !== undefined) {
           delete updateData[idColumn];
         }
    patchStrategy: new-unified
  - type: write
    path: test/util.ts
    content: |-
      <<<<<<< SEARCH
      export const schemaDef = {
        tables: {
          users: {
            id: konro.id(),
            name: konro.string({ min: 2 }),
            email: konro.string({ unique: true, format: 'email' }),
            age: konro.number({ min: 18, type: 'integer' }),
            isActive: konro.boolean({ default: true }),
          },
          posts: {
            id: konro.id(),
            title: konro.string(),
            content: konro.string(),
            authorId: konro.number(),
            publishedAt: konro.date({ default: () => new Date() }),
          },
          profiles: {
            id: konro.id(),
            bio: konro.string(),
            userId: konro.number({ unique: true }),
          },
          tags: {
            id: konro.id(),
            name: konro.string({ unique: true }),
          },
          posts_tags: {
            id: konro.id(),
            postId: konro.number(),
            tagId: konro.number(),
          },
        },
        relations: (tables: any) => ({
          users: {
            posts: konro.many('posts', { on: 'id', references: 'authorId' }),
            profile: konro.one('profiles', { on: 'id', references: 'userId' }),
          },
          posts: {
            author: konro.one('users', { on: 'authorId', references: 'id' }),
            tags: konro.many('posts_tags', { on: 'id', references: 'postId' }),
          },
          profiles: {
            user: konro.one('users', { on: 'userId', references: 'id' }),
          },
          posts_tags: {
              post: konro.one('posts', { on: 'postId', references: 'id' }),
              tag: konro.one('tags', { on: 'tagId', references: 'id' }),
          }
        }),
      };

      export const testSchema = konro.createSchema(schemaDef);
      =======
      const tables = {
        users: {
          id: konro.id(),
          name: konro.string({ min: 2 }),
          email: konro.string({ unique: true, format: 'email' }),
          age: konro.number({ min: 18, type: 'integer' }),
          isActive: konro.boolean({ default: true }),
        },
        posts: {
          id: konro.id(),
          title: konro.string(),
          content: konro.string(),
          authorId: konro.number(),
          publishedAt: konro.date({ default: () => new Date() }),
        },
        profiles: {
          id: konro.id(),
          bio: konro.string(),
          userId: konro.number({ unique: true }),
        },
        tags: {
          id: konro.id(),
          name: konro.string({ unique: true }),
        },
        posts_tags: {
          id: konro.id(),
          postId: konro.number(),
          tagId: konro.number(),
        },
      };

      export const schemaDef = {
        tables,
        relations: (_tables: typeof tables) => ({
          users: {
            posts: konro.many('posts', { on: 'id', references: 'authorId' }),
            profile: konro.one('profiles', { on: 'id', references: 'userId' }),
          },
          posts: {
            author: konro.one('users', { on: 'authorId', references: 'id' }),
            tags: konro.many('posts_tags', { on: 'id', references: 'postId' }),
          },
          profiles: {
            user: konro.one('users', { on: 'userId', references: 'id' }),
          },
          posts_tags: {
              post: konro.one('posts', { on: 'postId', references: 'id' }),
              tag: konro.one('tags', { on: 'tagId', references: 'id' }),
          }
        }),
      };

      export const testSchema = konro.createSchema(schemaDef);
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/unit/Schema/ColumnHelpers.test.ts
    content: |-
      --- test/unit/Schema/ColumnHelpers.test.ts
      +++ test/unit/Schema/ColumnHelpers.test.ts
      @@ -83,12 +83,12 @@
         it('should create a valid object column definition', () => {
           const objCol = konro.object<{ meta: string }>();
           expect(objCol).toEqual({
             _type: 'column',
             dataType: 'object',
             options: undefined,
      -      _tsType: {},
      +      _tsType: undefined,
           });
         });
       });
    patchStrategy: new-unified
  - type: write
    path: test/unit/Validation/Constraints.test.ts
    content: >-
      --- test/unit/Validation/Constraints.test.ts

      +++ test/unit/Validation/Constraints.test.ts

      @@ -49,8 +49,8 @@
           
           it('should throw a KonroValidationError on update for a non-unique value', () => {
               // Add another user to create conflict
      -        testState.users.records.push({ id: 2, name: 'Charlie', email:
      'charlie@example.com', age: 40, isActive: true });

      -        testState.users.meta.lastId = 2;

      +        testState.users!.records.push({ id: 2, name: 'Charlie', email:
      'charlie@example.com', age: 40, isActive: true });

      +        testState.users!.meta.lastId = 2;
       
               const predicate = (r: any) => r.id === 2;
               const data = { email: 'alice@example.com' }; // Try to update charlie's email to alice's
    patchStrategy: new-unified
  - type: write
    path: test/unit/Core/Delete.test.ts
    content: >-
      --- test/unit/Core/Delete.test.ts

      +++ test/unit/Core/Delete.test.ts

      @@ -27,30 +27,30 @@
               const [newState] = _deleteImpl(testState, 'users', (r) => r.id === 1);
               
               expect(newState).not.toBe(originalState);
      -        expect(originalState.users.records.length).toBe(3);

      -        expect(newState.users.records.length).toBe(2);

      +        expect(originalState.users!.records.length).toBe(3);

      +        expect(newState.users!.records.length).toBe(2);
           });
       
           it('should only delete records that match the predicate function', () => {
      -        const [newState, deleted] = _deleteImpl(testState, 'users', (r)
      => (r.age as number) > 35);

      +        const [newState, deleted] = _deleteImpl(testState, 'users', (r)
      => typeof r.age === 'number' && r.age > 35);
               
               expect(deleted.length).toBe(1);
      -        expect(deleted[0].id).toBe(3);

      -        expect(newState.users.records.length).toBe(2);

      -        expect(newState.users.records.find(u => u.id ===
      3)).toBeUndefined();

      +        expect(deleted[0]!.id).toBe(3);

      +        expect(newState.users!.records.length).toBe(2);

      +        expect(newState.users!.records.find(u => u.id ===
      3)).toBeUndefined();
           });
       
           it('should return both the new state and an array of the full, deleted records in the result tuple', () => {
               const [newState, deleted] = _deleteImpl(testState, 'users', (r) => r.id === 2);
       
               expect(newState).toBeDefined();
               expect(deleted).toBeInstanceOf(Array);
               expect(deleted.length).toBe(1);
      -        expect(deleted[0]).toEqual({ id: 2, name: 'Bob', email:
      'b@b.com', age: 25 });

      +        expect(deleted[0]!).toEqual({ id: 2, name: 'Bob', email:
      'b@b.com', age: 25 });
           });
       
           it('should not modify the table meta lastId on delete', () => {
               const [newState] = _deleteImpl(testState, 'users', (r) => r.id === 3);
      -        expect(newState.users.meta.lastId).toBe(3);

      +        expect(newState.users!.meta.lastId).toBe(3);
           });
       });
    patchStrategy: new-unified
  - type: write
    path: test/unit/Core/Insert.test.ts
    content: >-
      --- test/unit/Core/Insert.test.ts

      +++ test/unit/Core/Insert.test.ts

      @@ -21,68 +21,68 @@
               const [newState] = _insertImpl(emptyState, testSchema, 'users', [{ name: 'Test', email: 'test@test.com', age: 25 }]);
               
               expect(newState).not.toBe(originalState);
      -        expect(originalState.users.records.length).toBe(0);

      -        expect(newState.users.records.length).toBe(1);

      +        expect(originalState.users!.records.length).toBe(0);

      +        expect(newState.users!.records.length).toBe(1);
           });
       
           it('should correctly increment the lastId in the table meta', () => {
               const [newState] = _insertImpl(emptyState, testSchema, 'users', [{ name: 'Test', email: 'test@test.com', age: 25 }]);
      -        expect(newState.users.meta.lastId).toBe(1);

      +        expect(newState.users!.meta.lastId).toBe(1);
       
               const [finalState] = _insertImpl(newState, testSchema, 'users', [{ name: 'Test2', email: 'test2@test.com', age: 30 }]);
      -        expect(finalState.users.meta.lastId).toBe(2);

      +        expect(finalState.users!.meta.lastId).toBe(2);
           });
       
           it('should assign the new id to the inserted record', () => {
               const [newState, inserted] = _insertImpl(emptyState, testSchema, 'posts', [{ title: 'My Post', content: '...', authorId: 1 }]);
      -        expect(newState.posts.meta.lastId).toBe(11);

      -        expect(inserted[0].id).toBe(11);

      -        expect(newState.posts.records[0].id).toBe(11);

      +        expect(newState.posts!.meta.lastId).toBe(11);

      +        expect(inserted[0]!.id).toBe(11);

      +        expect(newState.posts!.records[0]!.id).toBe(11);
           });
       
           it('should apply default values for fields that are not provided', () => {
               const [newState, inserted] = _insertImpl(emptyState, testSchema, 'users', [{ name: 'Default User', email: 'default@test.com', age: 30 }]);
      -        expect(inserted[0].isActive).toBe(true);

      -        expect(newState.users.records[0].isActive).toBe(true);

      +        expect(inserted[0]!.isActive).toBe(true);

      +        expect(newState.users!.records[0]!.isActive).toBe(true);
           });
       
           it('should apply default values from a function call, like for dates', () => {
               const before = new Date();
               const [newState, inserted] = _insertImpl(emptyState, testSchema, 'posts', [{ title: 'Dated Post', content: '...', authorId: 1 }]);
               const after = new Date();
       
      -        const publishedAt = inserted[0].publishedAt as Date;

      +        const publishedAt = inserted[0]!.publishedAt as Date;
               expect(publishedAt).toBeInstanceOf(Date);
               expect(publishedAt.getTime()).toBeGreaterThanOrEqual(before.getTime());
               expect(publishedAt.getTime()).toBeLessThanOrEqual(after.getTime());
      -       
      expect(newState.posts.records[0].publishedAt).toEqual(publishedAt);

      +       
      expect(newState.posts!.records[0]!.publishedAt).toEqual(publishedAt);
           });
       
           it('should successfully insert multiple records in a single call', () => {
               const usersToInsert = [
                   { name: 'User A', email: 'a@test.com', age: 21 },
                   { name: 'User B', email: 'b@test.com', age: 22 },
               ];
               const [newState, inserted] = _insertImpl(emptyState, testSchema, 'users', usersToInsert);
       
      -        expect(newState.users.records.length).toBe(2);

      +        expect(newState.users!.records.length).toBe(2);
               expect(inserted.length).toBe(2);
      -        expect(newState.users.meta.lastId).toBe(2);

      -        expect(inserted[0].id).toBe(1);

      -        expect(inserted[1].id).toBe(2);

      -        expect(inserted[0].name).toBe('User A');

      -        expect(inserted[1].name).toBe('User B');

      +        expect(newState.users!.meta.lastId).toBe(2);

      +        expect(inserted[0]!.id).toBe(1);

      +        expect(inserted[1]!.id).toBe(2);

      +        expect(inserted[0]!.name).toBe('User A');

      +        expect(inserted[1]!.name).toBe('User B');
           });
       
           it('should return both the new state and the newly created record(s) in the result tuple', () => {
               const userToInsert = { name: 'Single', email: 'single@test.com', age: 40 };
               const [newState, inserted] = _insertImpl(emptyState, testSchema, 'users', [userToInsert]);
               
               expect(newState).toBeDefined();
               expect(inserted).toBeInstanceOf(Array);
               expect(inserted.length).toBe(1);
      -        expect(inserted[0].name).toBe('Single');

      -        expect(inserted[0].id).toBe(1);

      +        expect(inserted[0]!.name).toBe('Single');

      +        expect(inserted[0]!.id).toBe(1);
           });
       });
    patchStrategy: new-unified
  - type: write
    path: test/unit/Core/Query-With.test.ts
    content: >-
      --- test/unit/Core/Query-With.test.ts

      +++ test/unit/Core/Query-With.test.ts

      @@ -41,75 +41,83 @@
               });
       
               expect(results.length).toBe(1);
      -        const post = results[0];

      -        expect(post.author).toBeDefined();

      -        expect(post.author.id).toBe(1);

      -        expect(post.author.name).toBe('Alice');

      +        const post = results[0]!;

      +        expect(post).toBeDefined();

      +        const author = post.author as {id: unknown, name: unknown};

      +        expect(author).toBeDefined();

      +        expect(author.id).toBe(1);

      +        expect(author.name).toBe('Alice');
           });
       
           it('should resolve a `many` relationship and attach it as an array', () => {
               const results = _queryImpl(testState, testSchema, {
                   tableName: 'users',
                   where: r => r.id === 1,
                   with: { posts: true }
               });
       
               expect(results.length).toBe(1);
      -        const user = results[0];

      -        expect(user.posts).toBeDefined();

      -        expect(user.posts).toBeInstanceOf(Array);

      -        expect(user.posts.length).toBe(2);

      -        expect(user.posts[0].title).toBe('Alice Post 1');

      -        expect(user.posts[1].title).toBe('Alice Post 2');

      +        const user = results[0]!;

      +        expect(user).toBeDefined();

      +        const posts = user.posts as {title: unknown}[];

      +        expect(posts).toBeInstanceOf(Array);

      +        expect(posts.length).toBe(2);

      +        expect(posts[0]!.title).toBe('Alice Post 1');

      +        expect(posts[1]!.title).toBe('Alice Post 2');
           });
       
           it('should filter nested records within a .with() clause', () => {
               const results = _queryImpl(testState, testSchema, {
                   tableName: 'users',
                   where: r => r.id === 1,
                   with: {
                       posts: {
      -                    where: (post) => (post.title as
      string).includes('Post 2')

      +                    where: (post) => typeof post.title === 'string' &&
      post.title.includes('Post 2')
                       }
                   }
               });
       
               expect(results.length).toBe(1);
      -        const user = results[0];

      -        expect(user.posts).toBeDefined();

      -        expect(user.posts.length).toBe(1);

      -        expect(user.posts[0].id).toBe(12);

      +        const user = results[0]!;

      +        const posts = user.posts as {id: unknown}[];

      +        expect(posts).toBeDefined();

      +        expect(posts.length).toBe(1);

      +        expect(posts[0]!.id).toBe(12);
           });
       
           it('should handle multiple relations at once', () => {
               const results = _queryImpl(testState, testSchema, {
                   tableName: 'users',
                   where: r => r.id === 1,
                   with: {
                       posts: true,
                       profile: true
                   }
               });
               
               expect(results.length).toBe(1);
      -        const user = results[0];

      -        expect(user.posts).toBeInstanceOf(Array);

      -        expect(user.posts.length).toBe(2);

      -        expect(user.profile).toBeDefined();

      -        expect(user.profile.bio).toBe('Bio for Alice');

      +        const user = results[0]!;

      +        const posts = user.posts as unknown[];

      +        const profile = user.profile as { bio: unknown };

      +        expect(posts).toBeInstanceOf(Array);

      +        expect(posts.length).toBe(2);

      +        expect(profile).toBeDefined();

      +        expect(profile.bio).toBe('Bio for Alice');
           });
       
           it('should return null for a `one` relation if no related record is found', () => {
               const results = _queryImpl(testState, testSchema, {
                   tableName: 'users',
                   where: r => r.id === 2, // Bob has no profile
                   with: { profile: true }
               });
       
               expect(results.length).toBe(1);
      -        const user = results[0];

      -        expect(user.profile).toBeNull();

      +        const user = results[0]!;

      +        expect(user.profile).toBeNull();
           });
       
           it('should return an empty array for a `many` relation if no related records are found', () => {
               // Add a user with no posts
      -        testState.users.records.push({ id: 3, name: 'Charlie' });

      +        testState.users!.records.push({ id: 3, name: 'Charlie' });
               const results = _queryImpl(testState, testSchema, {
                   tableName: 'users',
                   where: r => r.id === 3,
                   with: { posts: true }
               });
       
               expect(results.length).toBe(1);
      -        const user = results[0];

      -        expect(user.posts).toBeInstanceOf(Array);

      -        expect(user.posts.length).toBe(0);

      +        const user = results[0]!;

      +        expect(user.posts).toBeInstanceOf(Array);

      +        expect((user.posts as unknown[]).length).toBe(0);
           });
       });
    patchStrategy: new-unified
  - type: write
    path: test/unit/Core/Query.test.ts
    content: >-
      --- test/unit/Core/Query.test.ts

      +++ test/unit/Core/Query.test.ts

      @@ -26,45 +26,45 @@
           it('should select all fields from a table when .select() is omitted', () => {
               const results = _queryImpl(testState, testSchema, { tableName: 'users' });
               expect(results.length).toBe(4);
      -        expect(results[0]).toEqual({ id: 1, name: 'Alice', age: 30,
      isActive: true });

      -        expect(Object.keys(results[0]).length).toBe(4);

      +        expect(results[0]!).toEqual({ id: 1, name: 'Alice', age: 30,
      isActive: true });

      +        expect(Object.keys(results[0]!).length).toBe(4);
           });
       
           it('should select only the specified fields when using .select()', () => {
               const results = _queryImpl(testState, testSchema, { tableName: 'users', select: ['name', 'age'] });
               expect(results.length).toBe(4);
      -        expect(results[0]).toEqual({ name: 'Alice', age: 30 });

      -        expect(Object.keys(results[0]).length).toBe(2);

      +        expect(results[0]!).toEqual({ name: 'Alice', age: 30 });

      +        expect(Object.keys(results[0]!).length).toBe(2);
           });
       
           it('should filter records correctly using a where function', () => {
      -        const results = _queryImpl(testState, testSchema, { tableName:
      'users', where: (r) => (r.age as number) === 30 });

      +        const results = _queryImpl(testState, testSchema, { tableName:
      'users', where: (r) => r.age === 30 });
               expect(results.length).toBe(2);
      -        expect(results[0].name).toBe('Alice');

      -        expect(results[1].name).toBe('Denise');

      +        expect(results[0]!.name).toBe('Alice');

      +        expect(results[1]!.name).toBe('Denise');
           });
       
           it('should limit the number of returned records correctly using .limit()', () => {
               const results = _queryImpl(testState, testSchema, { tableName: 'users', limit: 2 });
               expect(results.length).toBe(2);
      -        expect(results[0].id).toBe(1);

      -        expect(results[1].id).toBe(2);

      +        expect(results[0]!.id).toBe(1);

      +        expect(results[1]!.id).toBe(2);
           });
       
           it('should skip the correct number of records using .offset()', () => {
               const results = _queryImpl(testState, testSchema, { tableName: 'users', offset: 2 });
               expect(results.length).toBe(2);
      -        expect(results[0].id).toBe(3);

      -        expect(results[1].id).toBe(4);

      +        expect(results[0]!.id).toBe(3);

      +        expect(results[1]!.id).toBe(4);
           });
       
           it('should correctly handle limit and offset together for pagination', () => {
               const results = _queryImpl(testState, testSchema, { tableName: 'users', offset: 1, limit: 2 });
               expect(results.length).toBe(2);
      -        expect(results[0].id).toBe(2);

      -        expect(results[1].id).toBe(3);

      +        expect(results[0]!.id).toBe(2);

      +        expect(results[1]!.id).toBe(3);
           });
       
           it('should return an array of all matching records when using .all()', () => {
      @@ -76,14 +76,14 @@
       
           it('should return the first matching record when using .first()', () => {
               // This is simulated by adding limit: 1
      -        const results = _queryImpl(testState, testSchema, { tableName:
      'users', where: r => (r.age as number) > 28, limit: 1 });

      +        const results = _queryImpl(testState, testSchema, { tableName:
      'users', where: r => typeof r.age === 'number' && r.age > 28, limit: 1 });
               expect(results.length).toBe(1);
      -        expect(results[0].id).toBe(1);

      +        expect(results[0]!.id).toBe(1);
           });
       
           it('should return null when .first() finds no matching record', () => {
               // This is simulated by _queryImpl returning [] and the caller handling it
      -        const results = _queryImpl(testState, testSchema, { tableName:
      'users', where: r => (r.age as number) > 50, limit: 1 });

      +        const results = _queryImpl(testState, testSchema, { tableName:
      'users', where: r => typeof r.age === 'number' && r.age > 50, limit: 1 });
               expect(results.length).toBe(0);
           });
       });
    patchStrategy: new-unified
  - type: write
    path: test/unit/Core/Update.test.ts
    content: >-
      --- test/unit/Core/Update.test.ts

      +++ test/unit/Core/Update.test.ts

      @@ -1,6 +1,6 @@
       import { describe, it, expect, beforeEach } from 'bun:test';
       import { testSchema } from '../../util';
       import { _updateImpl } from '../../../src/operations';
      -import { DatabaseState, KRecord } from '../../../src/types';

      +import { DatabaseState } from '../../../src/types';
       
       describe('Unit > Core > Update', () => {
           let testState: DatabaseState;
      @@ -23,59 +23,59 @@
               const [newState] = _updateImpl(testState, testSchema, 'users', { age: 31 }, (r) => r.id === 1);
               
               expect(newState).not.toBe(originalState);
      -        expect(originalState.users.records[0].age).toBe(30);

      -        expect(newState.users.records.find(u => u.id ===
      1)?.age).toBe(31);

      +        expect(originalState.users!.records[0]!.age).toBe(30);

      +        expect(newState.users!.records.find(u => u.id ===
      1)?.age).toBe(31);
           });
       
           it('should only update records that match the predicate function', () => {
               const [newState, updated] = _updateImpl(testState, testSchema, 'users', { isActive: true }, (r) => r.name === 'Charlie');
               
               expect(updated.length).toBe(1);
      -        expect(updated[0].id).toBe(3);

      -        expect(updated[0].isActive).toBe(true);

      -        expect(newState.users.records.find(u => u.id ===
      3)?.isActive).toBe(true);

      -        expect(newState.users.records.find(u => u.id ===
      1)?.isActive).toBe(true); // Unchanged

      +        expect(updated[0]!.id).toBe(3);

      +        expect(updated[0]!.isActive).toBe(true);

      +        expect(newState.users!.records.find(u => u.id ===
      3)?.isActive).toBe(true);

      +        expect(newState.users!.records.find(u => u.id ===
      1)?.isActive).toBe(true); // Unchanged
           });
       
           it('should correctly modify the fields specified in the set payload', () => {
               const [newState, updated] = _updateImpl(testState, testSchema, 'users', { age: 26, name: 'Robert' }, (r) => r.id === 2);
       
               expect(updated.length).toBe(1);
      -        const updatedUser = newState.users.records.find(u => u.id === 2);

      +        const updatedUser = newState.users!.records.find(u => u.id ===
      2);
               expect(updatedUser?.name).toBe('Robert');
               expect(updatedUser?.age).toBe(26);
           });
       
           it('should not allow changing the id of an updated record', () => {
               const payload = { id: 99, age: 50 };
               const [newState, updated] = _updateImpl(testState, testSchema, 'users', payload, (r) => r.id === 1);
               
               expect(updated.length).toBe(1);
      -        expect(updated[0].id).toBe(1); // The id should remain 1

      -        expect(updated[0].age).toBe(50);

      +        expect(updated[0]!.id).toBe(1); // The id should remain 1

      +        expect(updated[0]!.age).toBe(50);
               
      -        const userInNewState = newState.users.records.find(u => u.age ===
      50);

      +        const userInNewState = newState.users!.records.find(u => u.age
      === 50);
               expect(userInNewState?.id).toBe(1);
       
      -        const userWithOldId = newState.users.records.find(u => u.id ===
      1);

      +        const userWithOldId = newState.users!.records.find(u => u.id ===
      1);
               expect(userWithOldId).toBeDefined();
               expect(userWithOldId?.age).toBe(50);
               
      -        const userWithNewId = newState.users.records.find(u => u.id ===
      99);

      +        const userWithNewId = newState.users!.records.find(u => u.id ===
      99);
               expect(userWithNewId).toBeUndefined();
           });
       
           it('should return an empty array of updated records if the predicate matches nothing', () => {
               const [newState, updated] = _updateImpl(testState, testSchema, 'users', { age: 99 }, (r) => r.id === 999);
               expect(updated.length).toBe(0);
      -        expect(newState).toEqual(testState); // Should be a new object,
      but with identical content

      +       
      expect(newState.users!.records).toEqual(testState.users!.records);
               expect(newState).not.toBe(testState);
      -        expect(newState.users.records).toEqual(testState.users.records);
           });
       
           it('should return both the new state and an array of the full, updated records in the result tuple', () => {
               const [newState, updated] = _updateImpl(testState, testSchema, 'users', { isActive: false }, (r) => r.id === 1);
               expect(newState).toBeDefined();
               expect(updated).toBeInstanceOf(Array);
               expect(updated.length).toBe(1);
      -        expect(updated[0]).toEqual({

      +        expect(updated[0]!).toEqual({
                   id: 1,
                   name: 'Alice',
                   email: 'a@a.com',
    patchStrategy: new-unified
snapshot:
  src/schema.ts: >
    // --- TYPE UTILITIES ---

    type Pretty<T> = { [K in keyof T]: T[K] } & {};


    // --- CORE DEFINITIONS ---


    export interface ColumnOptions<T> {
      unique?: boolean;
      default?: T | (() => T);
    }


    export interface StringColumnOptions extends ColumnOptions<string> {
      min?: number;
      max?: number;
      format?: 'email' | 'uuid' | 'url';
    }


    export interface NumberColumnOptions extends ColumnOptions<number> {
      min?: number;
      max?: number;
      type?: 'integer';
    }


    export interface ColumnDefinition<T> {
      _type: 'column';
      dataType: 'id' | 'string' | 'number' | 'boolean' | 'date' | 'object';
      options?: ColumnOptions<T>;
      _tsType: T; // For TypeScript inference only
    }


    export interface RelationDefinition {
      _type: 'relation';
      relationType: 'one' | 'many';
      targetTable: string;
      on: string;
      references: string;
    }


    // --- TYPE INFERENCE MAGIC ---


    type BaseModels<TTables extends Record<string, Record<string,
    ColumnDefinition<any>>>> = {
      [TableName in keyof TTables]: {
        [ColumnName in keyof TTables[TableName]]: TTables[TableName][ColumnName]['_tsType'];
      };
    };


    type WithRelations<
      TBaseModels extends Record<string, any>,
      TRelations extends Record<string, Record<string, RelationDefinition>>
    > = {
        [TableName in keyof TBaseModels]: TBaseModels[TableName] & (TableName extends keyof TRelations ? {
          [RelationName in keyof TRelations[TableName]]?: TRelations[TableName][RelationName]['relationType'] extends 'one'
          ? TBaseModels[TRelations[TableName][RelationName]['targetTable']] | null
          : TBaseModels[TRelations[TableName][RelationName]['targetTable']][];
        } : {});
      };

    export interface KonroSchema<
      TTables extends Record<string, Record<string, ColumnDefinition<any>>>,
      TRelations extends Record<string, Record<string, RelationDefinition>>
    > {
      tables: TTables;
      relations: TRelations;
      types: Pretty<WithRelations<BaseModels<TTables>, TRelations>>;
    }


    // --- SCHEMA HELPERS ---


    export const id = (): ColumnDefinition<number> => ({ _type: 'column',
    dataType: 'id', options: { unique: true }, _tsType: 0 });

    export const string = (options?: StringColumnOptions):
    ColumnDefinition<string> => ({ _type: 'column', dataType: 'string', options,
    _tsType: '' });

    export const number = (options?: NumberColumnOptions):
    ColumnDefinition<number> => ({ _type: 'column', dataType: 'number', options,
    _tsType: 0 });

    export const boolean = (options?: ColumnOptions<boolean>):
    ColumnDefinition<boolean> => ({ _type: 'column', dataType: 'boolean',
    options, _tsType: false });

    export const date = (options?: ColumnOptions<Date>): ColumnDefinition<Date>
    => ({ _type: 'column', dataType: 'date', options, _tsType: new Date() });

    export const object = <T extends Record<string, any>>(options?:
    ColumnOptions<T>): ColumnDefinition<T> => ({ _type: 'column', dataType:
    'object', options, _tsType: {} as T });


    export const one = (targetTable: string, options: { on: string; references:
    string }): RelationDefinition => ({ _type: 'relation', relationType: 'one',
    targetTable, ...options });

    export const many = (targetTable: string, options: { on: string; references:
    string }): RelationDefinition => ({ _type: 'relation', relationType: 'many',
    targetTable, ...options });


    // --- SCHEMA BUILDER ---


    type SchemaInputDef<T> = {
      tables: T;
      relations?: (tables: T) => Record<string, Record<string, RelationDefinition>>;
    };


    export function createSchema<const TDef extends
    SchemaInputDef<Record<string, Record<string,
    ColumnDefinition<any>>>>>(definition: TDef) {
      const relations = definition.relations ? definition.relations(definition.tables) : {};
      return {
        tables: definition.tables,
        relations,
        types: null as any, // This is a runtime placeholder for the inferred types
      } as KonroSchema<
        TDef['tables'],
        TDef['relations'] extends (...args: any) => any ? ReturnType<TDef['relations']> : {}
      >;
    }
  src/operations.ts: >
    import { DatabaseState, KRecord } from './types';

    import { KonroSchema, RelationDefinition } from './schema';

    import { KonroError } from './utils/error.util';


    // --- HELPERS ---



    /** Creates a pristine, empty database state from a schema. */

    export const createEmptyState = (schema: KonroSchema<any, any>):
    DatabaseState => {
      const state: DatabaseState = {};
      for (const tableName in schema.tables) {
        state[tableName] = { records: [], meta: { lastId: 0 } };
      }
      return state;
    };


    // --- QUERY ---


    export interface QueryDescriptor {
      tableName: string;
      select?: (keyof KRecord)[];
      where?: (record: KRecord) => boolean;
      with?: Record<string, boolean | { where?: (record: KRecord) => boolean }>;
      limit?: number;
      offset?: number;
    }


    export const _queryImpl = (state: DatabaseState, schema: KonroSchema<any,
    any>, descriptor: QueryDescriptor): KRecord[] => {
      const tableState = state[descriptor.tableName];
      if (!tableState) return [];

      // 1. Filter
      let results = descriptor.where ? tableState.records.filter(descriptor.where) : [...tableState.records];

      // 2. Eager load relations (`with`)
      if (descriptor.with) {
        results = structuredClone(results); // Clone to avoid mutating state
        for (const record of results) {
          for (const relationName in descriptor.with) {
            const relationDef = schema.relations[descriptor.tableName]?.[relationName];
            if (!relationDef) continue;

            const relatedRecords = findRelatedRecords(state, record, relationDef);

            const withOpts = descriptor.with[relationName];
            const nestedWhere = typeof withOpts === 'object' ? withOpts.where : undefined;

            const filteredRelatedRecords = nestedWhere ? relatedRecords.filter(nestedWhere) : relatedRecords;
            if (relationDef.relationType === 'one') {
              record[relationName] = filteredRelatedRecords[0] ?? null;
            } else {
              record[relationName] = filteredRelatedRecords;
            }
          }
        }
      }

      // 3. Paginate
      const offset = descriptor.offset ?? 0;
      const limit = descriptor.limit ?? results.length;
      let paginatedResults = results.slice(offset, offset + limit);

      // 4. Select Fields
      if (descriptor.select) {
        paginatedResults = paginatedResults.map(rec => {
          const newRec: KRecord = {};
          for (const key of descriptor.select!) {
            // This includes keys from `with` if the user explicitly adds them to select.
            if (rec.hasOwnProperty(key)) {
              newRec[key] = rec[key];
            }
          }
          return newRec;
        });
      }

      return paginatedResults;
    };


    const findRelatedRecords = (state: DatabaseState, record: KRecord,
    relationDef: RelationDefinition) => {
      const foreignKey = record[relationDef.on];
      const targetTable = state[relationDef.targetTable];

      if (foreignKey === undefined || !targetTable) return [];

      // one-to-many: 'on' is PK on current table, 'references' is FK on target
      if (relationDef.relationType === 'many') {
        return targetTable.records.filter(r => r[relationDef.references] === foreignKey);
      }

      // many-to-one: 'on' is FK on current table, 'references' is PK on target
      if (relationDef.relationType === 'one') {
        return targetTable.records.filter(r => r[relationDef.references] === foreignKey);
      }

      return [];
    };



    // --- INSERT ---


    export const _insertImpl = (state: DatabaseState, schema: KonroSchema<any,
    any>, tableName: string, values: KRecord[]): [DatabaseState, KRecord[]] => {
      const newState = structuredClone(state);
      const tableState = newState[tableName];
      if (!tableState) throw KonroError(`Table "${tableName}" does not exist in the database state.`);
      const tableSchema = schema.tables[tableName];
      const insertedRecords: KRecord[] = [];

      for (const value of values) {
        const newRecord: KRecord = { ...value };
        // Handle IDs and defaults
        for (const colName in tableSchema) {
          const colDef = tableSchema[colName];
          if (colDef.dataType === 'id') {
            tableState.meta.lastId++;
            newRecord[colName] = tableState.meta.lastId;
          }
          if (newRecord[colName] === undefined && colDef.options?.default !== undefined) {
            newRecord[colName] = typeof colDef.options.default === 'function' ? colDef.options.default() : colDef.options.default;
          }
        }
        tableState.records.push(newRecord);
        insertedRecords.push(newRecord);
      }

      return [newState, insertedRecords];
    };


    // --- UPDATE ---


    export const _updateImpl = (state: DatabaseState, schema: KonroSchema<any,
    any>, tableName: string, data: Partial<KRecord>, predicate: (record:
    KRecord) => boolean): [DatabaseState, KRecord[]] => {
      const newState = structuredClone(state);
      const tableState = newState[tableName];
      if (!tableState) throw KonroError(`Table "${tableName}" does not exist in the database state.`);
      const updatedRecords: KRecord[] = [];

      const updateData = { ...data };
      // Find the ID column from the schema and prevent it from being updated.
      const idColumn = Object.entries(schema.tables[tableName] ?? {}).find(([, colDef]) => colDef.dataType === 'id')?.[0];
      if (idColumn && updateData[idColumn] !== undefined) {
        delete updateData[idColumn];
      }


      tableState.records = tableState.records.map(record => {
        if (predicate(record)) {
          const updatedRecord = { ...record, ...updateData };
          updatedRecords.push(updatedRecord);
          return updatedRecord;
        }
        return record;
      });

      return [newState, updatedRecords];
    };



    // --- DELETE ---


    export const _deleteImpl = (state: DatabaseState, tableName: string,
    predicate: (record: KRecord) => boolean): [DatabaseState, KRecord[]] => {
      const newState = structuredClone(state);
      const tableState = newState[tableName];
      if (!tableState) throw KonroError(`Table "${tableName}" does not exist in the database state.`);
      const deletedRecords: KRecord[] = [];

      const keptRecords = tableState.records.filter(record => {
        if (predicate(record)) {
          deletedRecords.push(record);
          return false;
        }
        return true;
      });

      tableState.records = keptRecords;
      return [newState, deletedRecords];
    };
  test/util.ts: |-
    import { konro } from '../src/index';
    import { promises as fs } from 'fs';
    import path from 'path';

    export const TEST_DIR = path.join(__dirname, 'test_run_data');

    // --- Schema Definition ---

    export const schemaDef = {
      tables: {
        users: {
          id: konro.id(),
          name: konro.string({ min: 2 }),
          email: konro.string({ unique: true, format: 'email' }),
          age: konro.number({ min: 18, type: 'integer' }),
          isActive: konro.boolean({ default: true }),
        },
        posts: {
          id: konro.id(),
          title: konro.string(),
          content: konro.string(),
          authorId: konro.number(),
          publishedAt: konro.date({ default: () => new Date() }),
        },
        profiles: {
          id: konro.id(),
          bio: konro.string(),
          userId: konro.number({ unique: true }),
        },
        tags: {
          id: konro.id(),
          name: konro.string({ unique: true }),
        },
        posts_tags: {
          id: konro.id(),
          postId: konro.number(),
          tagId: konro.number(),
        },
      },
      relations: (tables: any) => ({
        users: {
          posts: konro.many('posts', { on: 'id', references: 'authorId' }),
          profile: konro.one('profiles', { on: 'id', references: 'userId' }),
        },
        posts: {
          author: konro.one('users', { on: 'authorId', references: 'id' }),
          tags: konro.many('posts_tags', { on: 'id', references: 'postId' }),
        },
        profiles: {
          user: konro.one('users', { on: 'userId', references: 'id' }),
        },
        posts_tags: {
            post: konro.one('posts', { on: 'postId', references: 'id' }),
            tag: konro.one('tags', { on: 'tagId', references: 'id' }),
        }
      }),
    };

    export const testSchema = konro.createSchema(schemaDef);

    // --- Test Utilities ---

    export const cleanup = async () => {
        try {
            await fs.rm(TEST_DIR, { recursive: true, force: true });
        } catch (error: any) {
            if (error.code !== 'ENOENT') {
                console.error('Error during cleanup:', error);
            }
        }
    };

    export const ensureTestDir = async () => {
        await fs.mkdir(TEST_DIR, { recursive: true });
    }
  test/unit/Schema/ColumnHelpers.test.ts: |-
    import { describe, it, expect } from 'bun:test';
    import { konro } from '../../../src/index';

    describe('Unit > Schema > ColumnHelpers', () => {
      it('should create a valid ID column definition object when calling konro.id()', () => {
        const idCol = konro.id();
        expect(idCol).toEqual({
          _type: 'column',
          dataType: 'id',
          options: { unique: true },
          _tsType: 0,
        });
      });

      it('should create a valid string column definition with all specified options', () => {
        const defaultFn = () => 'default';
        const stringCol = konro.string({
          unique: true,
          default: defaultFn,
          min: 5,
          max: 100,
          format: 'email',
        });
        expect(stringCol).toEqual({
          _type: 'column',
          dataType: 'string',
          options: {
            unique: true,
            default: defaultFn,
            min: 5,
            max: 100,
            format: 'email',
          },
          _tsType: '',
        });
      });

      it('should create a valid number column definition with all specified options', () => {
        const numberCol = konro.number({
          unique: false,
          default: 0,
          min: 0,
          max: 1000,
          type: 'integer',
        });
        expect(numberCol).toEqual({
          _type: 'column',
          dataType: 'number',
          options: {
            unique: false,
            default: 0,
            min: 0,
            max: 1000,
            type: 'integer',
          },
          _tsType: 0,
        });
      });

      it('should create a valid boolean column definition with a default value', () => {
        const boolCol = konro.boolean({ default: false });
        expect(boolCol).toEqual({
          _type: 'column',
          dataType: 'boolean',
          options: { default: false },
          _tsType: false,
        });
      });

      it('should create a valid date column definition with a default function', () => {
        const defaultDateFn = () => new Date();
        const dateCol = konro.date({ default: defaultDateFn });
        expect(dateCol).toEqual({
          _type: 'column',
          dataType: 'date',
          options: { default: defaultDateFn },
          _tsType: expect.any(Date),
        });
        expect(dateCol.options?.default).toBe(defaultDateFn);
      });

      it('should create a valid object column definition', () => {
        const objCol = konro.object<{ meta: string }>();
        expect(objCol).toEqual({
          _type: 'column',
          dataType: 'object',
          options: undefined,
          _tsType: {},
        });
      });
    });
  test/unit/Validation/Constraints.test.ts: |-
    import { describe, it, expect, beforeEach } from 'bun:test';
    import { testSchema } from '../../util';
    import { _insertImpl, _updateImpl } from '../../../src/operations';
    import { DatabaseState } from '../../../src/types';
    import { KonroValidationError } from '../../../src/utils/error.util';

    describe('Unit > Validation > Constraints', () => {
        let testState: DatabaseState;

        beforeEach(() => {
            testState = {
                users: {
                    records: [{ id: 1, name: 'Alice', email: 'alice@example.com', age: 30, isActive: true }],
                    meta: { lastId: 1 },
                },
                posts: { records: [], meta: { lastId: 0 } },
                profiles: { records: [], meta: { lastId: 0 } },
                tags: { records: [], meta: { lastId: 0 } },
                posts_tags: { records: [], meta: { lastId: 0 } },
            };
        });

        // NOTE: These tests are expected to fail until validation is implemented in core operations.
        // This is intentional to highlight the missing functionality as per the test plan.
        
        it('should throw a KonroValidationError when inserting a record with a non-unique value', () => {
            const user = { name: 'Bob', email: 'alice@example.com', age: 25 };
            // This should throw because 'alice@example.com' is already used and `email` is unique.
            expect(() => _insertImpl(testState, testSchema, 'users', [user])).toThrow(KonroValidationError);
        });

        it('should throw a KonroValidationError for a string that violates a format: email constraint', () => {
            const user = { name: 'Bob', email: 'bob@invalid', age: 25 };
            // This should throw because the email format is invalid.
            expect(() => _insertImpl(testState, testSchema, 'users', [user])).toThrow(KonroValidationError);
        });

        it('should throw a KonroValidationError for a number smaller than the specified min', () => {
            const user = { name: 'Bob', email: 'bob@example.com', age: 17 }; // age.min is 18
            // This should throw because age is below min.
            expect(() => _insertImpl(testState, testSchema, 'users', [user])).toThrow(KonroValidationError);
        });

        it('should throw a KonroValidationError for a string shorter than the specified min', () => {
            const user = { name: 'B', email: 'bob@example.com', age: 25 }; // name.min is 2
            // This should throw because name is too short.
            expect(() => _insertImpl(testState, testSchema, 'users', [user])).toThrow(KonroValidationError);
        });
        
        it('should throw a KonroValidationError on update for a non-unique value', () => {
            // Add another user to create conflict
            testState.users.records.push({ id: 2, name: 'Charlie', email: 'charlie@example.com', age: 40, isActive: true });
            testState.users.meta.lastId = 2;

            const predicate = (r: any) => r.id === 2;
            const data = { email: 'alice@example.com' }; // Try to update charlie's email to alice's

            expect(() => _updateImpl(testState, testSchema, 'users', data, predicate)).toThrow(KonroValidationError);
        });
    });
  test/unit/Core/Delete.test.ts: |-
    import { describe, it, expect, beforeEach } from 'bun:test';
    import { _deleteImpl } from '../../../src/operations';
    import { DatabaseState } from '../../../src/types';

    describe('Unit > Core > Delete', () => {
        let testState: DatabaseState;

        beforeEach(() => {
            testState = {
                users: {
                    records: [
                        { id: 1, name: 'Alice', email: 'a@a.com', age: 30 },
                        { id: 2, name: 'Bob', email: 'b@b.com', age: 25 },
                        { id: 3, name: 'Charlie', email: 'c@c.com', age: 42 },
                    ],
                    meta: { lastId: 3 },
                },
                posts: { records: [], meta: { lastId: 0 } },
                profiles: { records: [], meta: { lastId: 0 } },
                tags: { records: [], meta: { lastId: 0 } },
                posts_tags: { records: [], meta: { lastId: 0 } },
            };
        });

        it('should return a new state object, not mutate the original state, on delete', () => {
            const originalState = structuredClone(testState);
            const [newState] = _deleteImpl(testState, 'users', (r) => r.id === 1);
            
            expect(newState).not.toBe(originalState);
            expect(originalState.users.records.length).toBe(3);
            expect(newState.users.records.length).toBe(2);
        });

        it('should only delete records that match the predicate function', () => {
            const [newState, deleted] = _deleteImpl(testState, 'users', (r) => (r.age as number) > 35);
            
            expect(deleted.length).toBe(1);
            expect(deleted[0].id).toBe(3);
            expect(newState.users.records.length).toBe(2);
            expect(newState.users.records.find(u => u.id === 3)).toBeUndefined();
        });

        it('should return both the new state and an array of the full, deleted records in the result tuple', () => {
            const [newState, deleted] = _deleteImpl(testState, 'users', (r) => r.id === 2);

            expect(newState).toBeDefined();
            expect(deleted).toBeInstanceOf(Array);
            expect(deleted.length).toBe(1);
            expect(deleted[0]).toEqual({ id: 2, name: 'Bob', email: 'b@b.com', age: 25 });
        });

        it('should not modify the table meta lastId on delete', () => {
            const [newState] = _deleteImpl(testState, 'users', (r) => r.id === 3);
            expect(newState.users.meta.lastId).toBe(3);
        });
    });
  test/unit/Core/Insert.test.ts: |-
    import { describe, it, expect, beforeEach } from 'bun:test';
    import { testSchema } from '../../util';
    import { _insertImpl } from '../../../src/operations';
    import { DatabaseState } from '../../../src/types';

    describe('Unit > Core > Insert', () => {
        let emptyState: DatabaseState;

        beforeEach(() => {
            emptyState = {
                users: { records: [], meta: { lastId: 0 } },
                posts: { records: [], meta: { lastId: 10 } },
                profiles: { records: [], meta: { lastId: 0 } },
                tags: { records: [], meta: { lastId: 0 } },
                posts_tags: { records: [], meta: { lastId: 0 } },
            };
        });

        it('should return a new state object, not mutate the original state, on insert', () => {
            const originalState = structuredClone(emptyState);
            const [newState] = _insertImpl(emptyState, testSchema, 'users', [{ name: 'Test', email: 'test@test.com', age: 25 }]);
            
            expect(newState).not.toBe(originalState);
            expect(originalState.users.records.length).toBe(0);
            expect(newState.users.records.length).toBe(1);
        });

        it('should correctly increment the lastId in the table meta', () => {
            const [newState] = _insertImpl(emptyState, testSchema, 'users', [{ name: 'Test', email: 'test@test.com', age: 25 }]);
            expect(newState.users.meta.lastId).toBe(1);

            const [finalState] = _insertImpl(newState, testSchema, 'users', [{ name: 'Test2', email: 'test2@test.com', age: 30 }]);
            expect(finalState.users.meta.lastId).toBe(2);
        });

        it('should assign the new id to the inserted record', () => {
            const [newState, inserted] = _insertImpl(emptyState, testSchema, 'posts', [{ title: 'My Post', content: '...', authorId: 1 }]);
            expect(newState.posts.meta.lastId).toBe(11);
            expect(inserted[0].id).toBe(11);
            expect(newState.posts.records[0].id).toBe(11);
        });

        it('should apply default values for fields that are not provided', () => {
            const [newState, inserted] = _insertImpl(emptyState, testSchema, 'users', [{ name: 'Default User', email: 'default@test.com', age: 30 }]);
            expect(inserted[0].isActive).toBe(true);
            expect(newState.users.records[0].isActive).toBe(true);
        });

        it('should apply default values from a function call, like for dates', () => {
            const before = new Date();
            const [newState, inserted] = _insertImpl(emptyState, testSchema, 'posts', [{ title: 'Dated Post', content: '...', authorId: 1 }]);
            const after = new Date();

            const publishedAt = inserted[0].publishedAt as Date;
            expect(publishedAt).toBeInstanceOf(Date);
            expect(publishedAt.getTime()).toBeGreaterThanOrEqual(before.getTime());
            expect(publishedAt.getTime()).toBeLessThanOrEqual(after.getTime());
            expect(newState.posts.records[0].publishedAt).toEqual(publishedAt);
        });

        it('should successfully insert multiple records in a single call', () => {
            const usersToInsert = [
                { name: 'User A', email: 'a@test.com', age: 21 },
                { name: 'User B', email: 'b@test.com', age: 22 },
            ];
            const [newState, inserted] = _insertImpl(emptyState, testSchema, 'users', usersToInsert);

            expect(newState.users.records.length).toBe(2);
            expect(inserted.length).toBe(2);
            expect(newState.users.meta.lastId).toBe(2);
            expect(inserted[0].id).toBe(1);
            expect(inserted[1].id).toBe(2);
            expect(inserted[0].name).toBe('User A');
            expect(inserted[1].name).toBe('User B');
        });

        it('should return both the new state and the newly created record(s) in the result tuple', () => {
            const userToInsert = { name: 'Single', email: 'single@test.com', age: 40 };
            const [newState, inserted] = _insertImpl(emptyState, testSchema, 'users', [userToInsert]);
            
            expect(newState).toBeDefined();
            expect(inserted).toBeInstanceOf(Array);
            expect(inserted.length).toBe(1);
            expect(inserted[0].name).toBe('Single');
            expect(inserted[0].id).toBe(1);
        });
    });
  test/unit/Core/Query-With.test.ts: |-
    import { describe, it, expect, beforeEach } from 'bun:test';
    import { testSchema } from '../../util';
    import { _queryImpl } from '../../../src/operations';
    import { DatabaseState } from '../../../src/types';

    describe('Unit > Core > Query-With', () => {
        let testState: DatabaseState;

        beforeEach(() => {
            testState = {
                users: {
                    records: [
                        { id: 1, name: 'Alice' },
                        { id: 2, name: 'Bob' },
                    ],
                    meta: { lastId: 2 },
                },
                posts: {
                    records: [
                        { id: 10, title: 'Alice Post 1', authorId: 1 },
                        { id: 11, title: 'Bob Post 1', authorId: 2 },
                        { id: 12, title: 'Alice Post 2', authorId: 1 },
                    ],
                    meta: { lastId: 12 },
                },
                profiles: {
                    records: [
                        { id: 100, bio: 'Bio for Alice', userId: 1 },
                    ],
                    meta: { lastId: 100 },
                },
                tags: { records: [], meta: { lastId: 0 } },
                posts_tags: { records: [], meta: { lastId: 0 } },
            };
        });

        it('should resolve a `one` relationship and attach it to the parent record', () => {
            const results = _queryImpl(testState, testSchema, {
                tableName: 'posts',
                where: r => r.id === 10,
                with: { author: true }
            });

            expect(results.length).toBe(1);
            const post = results[0];
            expect(post.author).toBeDefined();
            expect(post.author.id).toBe(1);
            expect(post.author.name).toBe('Alice');
        });

        it('should resolve a `many` relationship and attach it as an array', () => {
            const results = _queryImpl(testState, testSchema, {
                tableName: 'users',
                where: r => r.id === 1,
                with: { posts: true }
            });

            expect(results.length).toBe(1);
            const user = results[0];
            expect(user.posts).toBeDefined();
            expect(user.posts).toBeInstanceOf(Array);
            expect(user.posts.length).toBe(2);
            expect(user.posts[0].title).toBe('Alice Post 1');
            expect(user.posts[1].title).toBe('Alice Post 2');
        });

        it('should filter nested records within a .with() clause', () => {
            const results = _queryImpl(testState, testSchema, {
                tableName: 'users',
                where: r => r.id === 1,
                with: {
                    posts: {
                        where: (post) => (post.title as string).includes('Post 2')
                    }
                }
            });

            expect(results.length).toBe(1);
            const user = results[0];
            expect(user.posts).toBeDefined();
            expect(user.posts.length).toBe(1);
            expect(user.posts[0].id).toBe(12);
        });

        it('should handle multiple relations at once', () => {
            const results = _queryImpl(testState, testSchema, {
                tableName: 'users',
                where: r => r.id === 1,
                with: {
                    posts: true,
                    profile: true
                }
            });
            
            expect(results.length).toBe(1);
            const user = results[0];
            expect(user.posts).toBeInstanceOf(Array);
            expect(user.posts.length).toBe(2);
            expect(user.profile).toBeDefined();
            expect(user.profile.bio).toBe('Bio for Alice');
        });

        it('should return null for a `one` relation if no related record is found', () => {
            const results = _queryImpl(testState, testSchema, {
                tableName: 'users',
                where: r => r.id === 2, // Bob has no profile
                with: { profile: true }
            });

            expect(results.length).toBe(1);
            const user = results[0];
            expect(user.profile).toBeNull();
        });

        it('should return an empty array for a `many` relation if no related records are found', () => {
            // Add a user with no posts
            testState.users.records.push({ id: 3, name: 'Charlie' });
            const results = _queryImpl(testState, testSchema, {
                tableName: 'users',
                where: r => r.id === 3,
                with: { posts: true }
            });

            expect(results.length).toBe(1);
            const user = results[0];
            expect(user.posts).toBeInstanceOf(Array);
            expect(user.posts.length).toBe(0);
        });
    });
  test/unit/Core/Query.test.ts: |-
    import { describe, it, expect, beforeEach } from 'bun:test';
    import { testSchema } from '../../util';
    import { _queryImpl } from '../../../src/operations';
    import { DatabaseState } from '../../../src/types';

    describe('Unit > Core > Query', () => {
        let testState: DatabaseState;

        beforeEach(() => {
            testState = {
                users: {
                    records: [
                        { id: 1, name: 'Alice', age: 30, isActive: true },
                        { id: 2, name: 'Bob', age: 25, isActive: true },
                        { id: 3, name: 'Charlie', age: 42, isActive: false },
                        { id: 4, name: 'Denise', age: 30, isActive: true },
                    ],
                    meta: { lastId: 4 },
                },
                posts: { records: [], meta: { lastId: 0 } },
                profiles: { records: [], meta: { lastId: 0 } },
                tags: { records: [], meta: { lastId: 0 } },
                posts_tags: { records: [], meta: { lastId: 0 } },
            };
        });

        it('should select all fields from a table when .select() is omitted', () => {
            const results = _queryImpl(testState, testSchema, { tableName: 'users' });
            expect(results.length).toBe(4);
            expect(results[0]).toEqual({ id: 1, name: 'Alice', age: 30, isActive: true });
            expect(Object.keys(results[0]).length).toBe(4);
        });

        it('should select only the specified fields when using .select()', () => {
            const results = _queryImpl(testState, testSchema, { tableName: 'users', select: ['name', 'age'] });
            expect(results.length).toBe(4);
            expect(results[0]).toEqual({ name: 'Alice', age: 30 });
            expect(Object.keys(results[0]).length).toBe(2);
        });

        it('should filter records correctly using a where function', () => {
            const results = _queryImpl(testState, testSchema, { tableName: 'users', where: (r) => (r.age as number) === 30 });
            expect(results.length).toBe(2);
            expect(results[0].name).toBe('Alice');
            expect(results[1].name).toBe('Denise');
        });

        it('should limit the number of returned records correctly using .limit()', () => {
            const results = _queryImpl(testState, testSchema, { tableName: 'users', limit: 2 });
            expect(results.length).toBe(2);
            expect(results[0].id).toBe(1);
            expect(results[1].id).toBe(2);
        });

        it('should skip the correct number of records using .offset()', () => {
            const results = _queryImpl(testState, testSchema, { tableName: 'users', offset: 2 });
            expect(results.length).toBe(2);
            expect(results[0].id).toBe(3);
            expect(results[1].id).toBe(4);
        });

        it('should correctly handle limit and offset together for pagination', () => {
            const results = _queryImpl(testState, testSchema, { tableName: 'users', offset: 1, limit: 2 });
            expect(results.length).toBe(2);
            expect(results[0].id).toBe(2);
            expect(results[1].id).toBe(3);
        });

        it('should return an array of all matching records when using .all()', () => {
            // This is implicit in _queryImpl, the test just verifies the base case
            const results = _queryImpl(testState, testSchema, { tableName: 'users', where: r => r.isActive === true });
            expect(results).toBeInstanceOf(Array);
            expect(results.length).toBe(3);
        });

        it('should return the first matching record when using .first()', () => {
            // This is simulated by adding limit: 1
            const results = _queryImpl(testState, testSchema, { tableName: 'users', where: r => (r.age as number) > 28, limit: 1 });
            expect(results.length).toBe(1);
            expect(results[0].id).toBe(1);
        });

        it('should return null when .first() finds no matching record', () => {
            // This is simulated by _queryImpl returning [] and the caller handling it
            const results = _queryImpl(testState, testSchema, { tableName: 'users', where: r => (r.age as number) > 50, limit: 1 });
            expect(results.length).toBe(0);
        });
    });
  test/unit/Core/Update.test.ts: |-
    import { describe, it, expect, beforeEach } from 'bun:test';
    import { testSchema } from '../../util';
    import { _updateImpl } from '../../../src/operations';
    import { DatabaseState, KRecord } from '../../../src/types';

    describe('Unit > Core > Update', () => {
        let testState: DatabaseState;

        beforeEach(() => {
            testState = {
                users: {
                    records: [
                        { id: 1, name: 'Alice', email: 'a@a.com', age: 30, isActive: true },
                        { id: 2, name: 'Bob', email: 'b@b.com', age: 25, isActive: true },
                        { id: 3, name: 'Charlie', email: 'c@c.com', age: 42, isActive: false },
                    ],
                    meta: { lastId: 3 },
                },
                posts: { records: [], meta: { lastId: 0 } },
                profiles: { records: [], meta: { lastId: 0 } },
                tags: { records: [], meta: { lastId: 0 } },
                posts_tags: { records: [], meta: { lastId: 0 } },
            };
        });

        it('should return a new state object, not mutate the original state, on update', () => {
            const originalState = structuredClone(testState);
            const [newState] = _updateImpl(testState, testSchema, 'users', { age: 31 }, (r) => r.id === 1);
            
            expect(newState).not.toBe(originalState);
            expect(originalState.users.records[0].age).toBe(30);
            expect(newState.users.records.find(u => u.id === 1)?.age).toBe(31);
        });

        it('should only update records that match the predicate function', () => {
            const [newState, updated] = _updateImpl(testState, testSchema, 'users', { isActive: true }, (r) => r.name === 'Charlie');
            
            expect(updated.length).toBe(1);
            expect(updated[0].id).toBe(3);
            expect(updated[0].isActive).toBe(true);
            expect(newState.users.records.find(u => u.id === 3)?.isActive).toBe(true);
            expect(newState.users.records.find(u => u.id === 1)?.isActive).toBe(true); // Unchanged
        });

        it('should correctly modify the fields specified in the set payload', () => {
            const [newState, updated] = _updateImpl(testState, testSchema, 'users', { age: 26, name: 'Robert' }, (r) => r.id === 2);

            expect(updated.length).toBe(1);
            const updatedUser = newState.users.records.find(u => u.id === 2);
            expect(updatedUser?.name).toBe('Robert');
            expect(updatedUser?.age).toBe(26);
        });

        it('should not allow changing the id of an updated record', () => {
            const payload = { id: 99, age: 50 };
            const [newState, updated] = _updateImpl(testState, testSchema, 'users', payload, (r) => r.id === 1);
            
            expect(updated.length).toBe(1);
            expect(updated[0].id).toBe(1); // The id should remain 1
            expect(updated[0].age).toBe(50);
            
            const userInNewState = newState.users.records.find(u => u.age === 50);
            expect(userInNewState?.id).toBe(1);

            const userWithOldId = newState.users.records.find(u => u.id === 1);
            expect(userWithOldId).toBeDefined();
            expect(userWithOldId?.age).toBe(50);
            
            const userWithNewId = newState.users.records.find(u => u.id === 99);
            expect(userWithNewId).toBeUndefined();
        });

        it('should return an empty array of updated records if the predicate matches nothing', () => {
            const [newState, updated] = _updateImpl(testState, testSchema, 'users', { age: 99 }, (r) => r.id === 999);
            expect(updated.length).toBe(0);
            expect(newState).toEqual(testState); // Should be a new object, but with identical content
            expect(newState).not.toBe(testState);
            expect(newState.users.records).toEqual(testState.users.records);
        });

        it('should return both the new state and an array of the full, updated records in the result tuple', () => {
            const [newState, updated] = _updateImpl(testState, testSchema, 'users', { isActive: false }, (r) => r.id === 1);
            expect(newState).toBeDefined();
            expect(updated).toBeInstanceOf(Array);
            expect(updated.length).toBe(1);
            expect(updated[0]).toEqual({
                id: 1,
                name: 'Alice',
                email: 'a@a.com',
                age: 30,
                isActive: false,
            });
        });
    });
approved: true

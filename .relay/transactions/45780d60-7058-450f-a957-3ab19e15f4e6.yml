uuid: 45780d60-7058-450f-a957-3ab19e15f4e6
projectId: konro
createdAt: '2025-07-09T10:28:09.401Z'
linesAdded: 38
linesRemoved: 24
gitCommitMsg: 'refactor(testing): centralize test imports for configurable build targets'
promptSummary: >-
  Refactor all test files to use a configurable import for the 'konro' library,
  allowing tests to run against source files, distributed modules (mjs/js), or a
  potentially linked npm package. Also, add scripts to package.json to manage
  this.
reasoning:
  - >-
    Excellent! This is a great idea for ensuring your tests run against
    different builds of your library. Here is the plan to make your test imports
    configurable:
  - >-
    1.  **Create a Central Importer**: I'll add a new file,
    `test/konro-test-import.ts`. All tests will import `konro` from this single
    file.
  - >-
    2.  **Update Test Files**: I will systematically update all test files that
    import `konro` to use this new central importer file. This will involve
    changing the import path in over 20 files.
  - >-
    3.  **Add `package.json` Scripts**: I will add new scripts to your
    `package.json` to manage the testing process. These scripts will temporarily
    modify `test/konro-test-import.ts` to point to the desired build (`src`,
    `dist/mjs`, or `dist/js`), run the tests, and then restore the file to its
    original state using `git`.
  - Here are the required file modifications.
  - >-
    First, I'll create the new central importer file. By default, it will export
    from your source directory. You should commit this file to your git
    repository.
  - >-
    Next, I'll update `test/util.ts` to use this new importer. The relative path
    is different for this file compared to the others.
  - >-
    Now, I'll update all other test files. They all share the same relative path
    change.
  - >-
    Finally, I'll update your `package.json` to include the new test runner
    scripts.
  - >-
    This setup provides a robust way to test your package against its source and
    distributed files, which is a great practice for ensuring quality.
operations:
  - type: write
    path: test/konro-test-import.ts
    content: >-
      // This file is used to easily switch the import source for 'konro' during
      testing.

      // A script can replace the export line below to target 'src', 'dist', or
      the 'konro' package.

      //

      // For example:

      // To test against src:       export * from '../src/index';

      // To test against dist (mjs): export * from '../dist/index.mjs';

      // To test against dist (js):  export * from '../dist/index.js';

      // To test against npm package: export * from 'konro';

      export * from '../src/index';
    patchStrategy: replace
  - type: write
    path: test/util.ts
    content: |-
      <<<<<<< SEARCH
      import { konro } from '../src/index';
      =======
      import { konro } from './konro-test-import';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/e2e/ErrorAndEdgeCases/Pagination.test.ts
    content: |-
      <<<<<<< SEARCH
      import { konro } from '../../../src/index';
      =======
      import { konro } from '../../../konro-test-import';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/e2e/ErrorAndEdgeCases/Transaction.test.ts
    content: |-
      <<<<<<< SEARCH
      import { konro } from '../../../src/index';
      =======
      import { konro } from '../../../konro-test-import';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/e2e/MultiFileYaml/FullLifecycle.test.ts
    content: |-
      <<<<<<< SEARCH
      import { konro } from '../../../src/index';
      =======
      import { konro } from '../../../konro-test-import';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/e2e/Operations/Aggregate.test.ts
    content: |-
      <<<<<<< SEARCH
      import { konro } from '../../../src/index';
      =======
      import { konro } from '../../../konro-test-import';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/e2e/Operations/Delete.test.ts
    content: |-
      <<<<<<< SEARCH
      import { konro } from '../../../src/index';
      =======
      import { konro } from '../../../konro-test-import';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/e2e/Operations/Insert.test.ts
    content: |-
      <<<<<<< SEARCH
      import { konro } from '../../../src/index';
      =======
      import { konro } from '../../../konro-test-import';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/e2e/Operations/Query-With.test.ts
    content: |-
      <<<<<<< SEARCH
      import { konro } from '../../../src/index';
      =======
      import { konro } from '../../../konro-test-import';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/e2e/Operations/Query.test.ts
    content: |-
      <<<<<<< SEARCH
      import { konro } from '../../../src/index';
      =======
      import { konro } from '../../../konro-test-import';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/e2e/Operations/Update.test.ts
    content: |-
      <<<<<<< SEARCH
      import { konro } from '../../../src/index';
      =======
      import { konro } from '../../../konro-test-import';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/e2e/SingleFileJson/FullLifecycle.test.ts
    content: |-
      <<<<<<< SEARCH
      import { konro } from '../../../src/index';
      =======
      import { konro } from '../../../konro-test-import';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/integration/Adapters/MultiFileYaml.test.ts
    content: |-
      <<<<<<< SEARCH
      import { konro } from '../../../src/index';
      =======
      import { konro } from '../../../konro-test-import';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/integration/Adapters/OnDemand.test.ts
    content: |-
      <<<<<<< SEARCH
      import { konro } from '../../../src/index';
      =======
      import { konro } from '../../../konro-test-import';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/integration/Adapters/PerRecord.test.ts
    content: |-
      <<<<<<< SEARCH
      import { konro } from '../../../src/index';
      =======
      import { konro } from '../../../konro-test-import';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/integration/Adapters/Read.test.ts
    content: |-
      <<<<<<< SEARCH
      import { konro } from '../../../src/index';
      =======
      import { konro } from '../../../konro-test-import';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/integration/Adapters/SingleFileJson.test.ts
    content: |-
      <<<<<<< SEARCH
      import { konro } from '../../../src/index';
      =======
      import { konro } from '../../../konro-test-import';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/integration/DBContext/Initialization.test.ts
    content: |-
      <<<<<<< SEARCH
      import { konro } from '../../../src/index';
      =======
      import { konro } from '../../../konro-test-import';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/integration/InMemoryFlow/CrudCycle.test.ts
    content: |-
      <<<<<<< SEARCH
      import { konro } from '../../../src/index';
      =======
      import { konro } from '../../../konro-test-import';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/integration/Types/InferredTypes.test-d.ts
    content: |-
      <<<<<<< SEARCH
      import { konro } from '../../../src/index';
      =======
      import { konro } from '../../../konro-test-import';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/unit/Core/Aggregate.test.ts
    content: |-
      <<<<<<< SEARCH
      import { konro } from '../../../src/index';
      =======
      import { konro } from '../../../konro-test-import';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/unit/Core/Delete.test.ts
    content: |-
      <<<<<<< SEARCH
      import { konro } from '../../../src/index';
      =======
      import { konro } from '../../../konro-test-import';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/unit/Schema/ColumnHelpers.test.ts
    content: |-
      <<<<<<< SEARCH
      import { konro } from '../../../src/index';
      =======
      import { konro } from '../../../konro-test-import';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/unit/Schema/CreateSchema.test.ts
    content: |-
      <<<<<<< SEARCH
      import { konro } from '../../../src/index';
      =======
      import { konro } from '../../../konro-test-import';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/unit/Schema/RelationHelpers.test.ts
    content: |-
      <<<<<<< SEARCH
      import { konro } from '../../../src/index';
      =======
      import { konro } from '../../../konro-test-import';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: package.json
    content: |-
      <<<<<<< SEARCH
        "scripts": {
          "lint": "eslint .",
          "build": "tsup",
          "dev": "tsup --watch",
          "prepublishOnly": "npm run build"
        }
      =======
        "scripts": {
          "lint": "eslint .",
          "build": "tsup",
          "dev": "tsup --watch",
          "test": "bun test",
          "test:restore-importer": "git checkout -- test/konro-test-import.ts",
          "test:src": "npm run test:restore-importer && bun test",
          "test:dist:mjs": "npm run build && echo \"export * from '../dist/index.mjs';\" > test/konro-test-import.ts && bun test && npm run test:restore-importer",
          "test:dist:js": "npm run build && echo \"export * from '../dist/index.js';\" > test/konro-test-import.ts && bun test && npm run test:restore-importer",
          "prepublishOnly": "npm run build"
        }
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
snapshot:
  test/konro-test-import.ts: null
  test/util.ts: "import { konro } from '../src/index';\r\nimport { promises as fs } from 'fs';\r\nimport path from 'path';\r\n\r\nexport const TEST_DIR = path.join(__dirname, 'test_run_data');\r\n\r\n// --- Schema Definition ---\r\n\r\nconst tables = {\r\n  users: {\r\n    id: konro.id(),\r\n    name: konro.string({ min: 2 }),\r\n    email: konro.string({ unique: true, format: 'email' }),\r\n    age: konro.number({ min: 18, type: 'integer' }),\r\n    isActive: konro.boolean({ default: true }),\r\n  },\r\n  posts: {\r\n    id: konro.id(),\r\n    title: konro.string(),\r\n    content: konro.string(),\r\n    authorId: konro.number(),\r\n    publishedAt: konro.date({ default: () => new Date() }),\r\n  },\r\n  profiles: {\r\n    id: konro.id(),\r\n    bio: konro.string(),\r\n    userId: konro.number({ unique: true }),\r\n  },\r\n  tags: {\r\n    id: konro.id(),\r\n    name: konro.string({ unique: true }),\r\n  },\r\n  posts_tags: {\r\n    id: konro.id(),\r\n    postId: konro.number(),\r\n    tagId: konro.number(),\r\n  },\r\n};\r\n\r\nexport const schemaDef = {\r\n  tables,\r\n  relations: (_tables: typeof tables) => ({\r\n    users: {\r\n      posts: konro.many('posts', { on: 'id', references: 'authorId' }),\r\n      profile: konro.one('profiles', { on: 'id', references: 'userId' }),\r\n    },\r\n    posts: {\r\n      author: konro.one('users', { on: 'authorId', references: 'id' }),\r\n      tags: konro.many('posts_tags', { on: 'id', references: 'postId' }),\r\n    },\r\n    profiles: {\r\n      user: konro.one('users', { on: 'userId', references: 'id' }),\r\n    },\r\n    posts_tags: {\r\n      post: konro.one('posts', { on: 'postId', references: 'id' }),\r\n      tag: konro.one('tags', { on: 'tagId', references: 'id' }),\r\n    }\r\n  }),\r\n};\r\n\r\nexport const testSchema = konro.createSchema(schemaDef);\r\n\r\nexport type UserCreate = typeof testSchema.create.users;\r\n\r\nexport const uuidTestSchema = konro.createSchema({\r\n  tables: {\r\n    uuid_users: {\r\n      id: konro.uuid(),\r\n      name: konro.string(),\r\n    },\r\n  },\r\n});\r\n\r\n// --- Test Utilities ---\r\n\r\nexport const cleanup = async () => {\r\n  try {\r\n    await fs.rm(TEST_DIR, { recursive: true, force: true });\r\n  } catch (error: any) {\r\n    if (error.code !== 'ENOENT') {\r\n      console.error('Error during cleanup:', error);\r\n    }\r\n  }\r\n};\r\n\r\nexport const ensureTestDir = async () => {\r\n  await fs.mkdir(TEST_DIR, { recursive: true });\r\n}\r\n"
  test/e2e/ErrorAndEdgeCases/Transaction.test.ts: "import { describe, it, expect, beforeEach, afterEach } from 'bun:test';\r\nimport { konro } from '../../../src/index';\r\nimport { testSchema, TEST_DIR, cleanup, ensureTestDir } from '../../util';\r\nimport path from 'path';\r\nimport { promises as fs } from 'fs';\r\nimport { KonroValidationError } from '../../../src/utils/error.util';\r\n\r\ndescribe('E2E > ErrorAndEdgeCases > Transaction', () => {\r\n  const dbFilePath = path.join(TEST_DIR, 'transaction_test.json');\r\n  const adapter = konro.createFileAdapter({\r\n    format: 'json',\r\n    single: { filepath: dbFilePath },\r\n  });\r\n  const db = konro.createDatabase({\r\n    schema: testSchema,\r\n    adapter,\r\n  });\r\n\r\n  beforeEach(async () => {\r\n    await ensureTestDir();\r\n    // Start with a clean slate for each test\r\n    await db.write(db.createEmptyState());\r\n  });\r\n  afterEach(cleanup);\r\n\r\n    it('should not write to disk if an operation fails mid-transaction', async () => {\r\n        // 1. Get initial state with one user\r\n        let state = await db.read();\r\n        [state] = db.insert(state, 'users', { name: 'Good User', email: 'good@test.com', age: 30, isActive: true });\r\n        await db.write(state);\r\n\r\n    const contentBefore = await fs.readFile(dbFilePath, 'utf-8');\r\n\r\n    // 2. Start a \"transaction\": read, then perform multiple operations\r\n    let transactionState = await db.read();\r\n\r\n        // This one is fine\r\n        [transactionState] = db.insert(transactionState, 'users', { name: 'Another User', email: 'another@test.com', age: 31, isActive: true });\r\n\r\n        // This one will fail due to unique constraint\r\n        const failingOperation = () => {\r\n            db.insert(transactionState, 'users', { name: 'Bad User', email: 'good@test.com', age: 32, isActive: true });\r\n        };\r\n        expect(failingOperation).toThrow(KonroValidationError);\r\n\r\n    // Even if the error is caught, the developer should not write the tainted `transactionState`.\r\n    // The file on disk should remain untouched from before the transaction started.\r\n    const contentAfter = await fs.readFile(dbFilePath, 'utf-8');\r\n    expect(contentAfter).toEqual(contentBefore);\r\n  });\r\n\r\n    it('should not change the database file if an update matches no records', async () => {\r\n        let state = await db.read();\r\n        [state] = db.insert(state, 'users', { name: 'Initial User', email: 'initial@test.com', age: 50, isActive: true });\r\n        await db.write(state);\r\n\r\n    const contentBefore = await fs.readFile(dbFilePath, 'utf-8');\r\n\r\n    // Read the state to perform an update\r\n    let currentState = await db.read();\r\n    const [newState] = await db.update(currentState, 'users')\r\n      .set({ name: 'This Should Not Be Set' })\r\n      .where({ id: 999 }); // This matches no records\r\n\r\n    await db.write(newState);\r\n\r\n    const contentAfter = await fs.readFile(dbFilePath, 'utf-8');\r\n\r\n    // The content should be identical because the state object itself shouldn't have changed meaningfully.\r\n    expect(contentAfter).toEqual(contentBefore);\r\n  });\r\n});\r\n"
  test/e2e/MultiFileYaml/FullLifecycle.test.ts: "import { describe, it, expect, beforeEach, afterEach } from 'bun:test';\r\nimport { konro } from '../../../src/index';\r\nimport { testSchema, TEST_DIR, cleanup, ensureTestDir } from '../../util';\r\nimport path from 'path';\r\nimport { promises as fs } from 'fs';\r\nimport yaml from 'js-yaml';\r\n\r\ndescribe('E2E > MultiFileYaml > FullLifecycle', () => {\r\n  const dbDirPath = path.join(TEST_DIR, 'e2e_yaml_db');\r\n  const adapter = konro.createFileAdapter({\r\n    format: 'yaml',\r\n    multi: { dir: dbDirPath },\r\n  });\r\n  const db = konro.createDatabase({\r\n    schema: testSchema,\r\n    adapter,\r\n  });\r\n\r\n  beforeEach(ensureTestDir);\r\n  afterEach(cleanup);\r\n\r\n  it('should handle a full data lifecycle across multiple YAML files', async () => {\r\n    // 1. Initialize empty database files\r\n    let state = db.createEmptyState();\r\n    await db.write(state);\r\n\r\n    // Check that empty files are created\r\n    const usersFilePath = path.join(dbDirPath, 'users.yaml');\r\n    let usersFileContent = await fs.readFile(usersFilePath, 'utf-8');\r\n    expect(yaml.load(usersFileContent)).toEqual({ records: [], meta: { lastId: 0 } });\r\n\r\n    // 2. Insert data and write to disk\r\n    const [s1, user] = db.insert(state, 'users', { name: 'E2E Yaml', email: 'yaml.e2e@test.com', age: 50, isActive: true });\r\n    const [s2] = db.insert(s1, 'posts', { title: 'YAML Post', content: '...', authorId: user.id, publishedAt: new Date() });\r\n    await db.write(s2);\r\n\r\n    // 3. Read back and verify integrity from separate files\r\n    const readState = await db.read();\r\n    expect(readState.users!.records.length).toBe(1);\r\n    expect(readState.posts!.records.length).toBe(1);\r\n    expect(readState.users!.records[0]?.id).toBe(user.id);\r\n\r\n    // 4. Query with relations\r\n    const userWithPosts = await db.query(readState).from('users').where({ id: user.id }).with({ posts: true }).first();\r\n    expect(userWithPosts).toBeDefined();\r\n    if (userWithPosts) {\r\n      expect(userWithPosts.posts).toBeDefined();\r\n      expect(userWithPosts.posts?.length).toBe(1);\r\n      expect(userWithPosts.posts?.[0]?.title).toBe('YAML Post');\r\n    }\r\n\r\n    // 5. Update and write\r\n    const [s3] = await db.update(readState, 'users').set({ name: 'Updated Yaml User' }).where({ id: user.id });\r\n    await db.write(s3);\r\n    const stateAfterUpdate = await db.read();\r\n    expect(stateAfterUpdate.users!.records[0]?.name).toBe('Updated Yaml User');\r\n\r\n    // 6. Delete and write\r\n    const [s4] = await db.delete(stateAfterUpdate, 'posts').where({ authorId: user.id });\r\n    await db.write(s4);\r\n    const finalState = await db.read();\r\n    expect(finalState.posts!.records.length).toBe(0);\r\n    expect(finalState.users!.records.length).toBe(1);\r\n  });\r\n});\r\n"
  test/e2e/Operations/Aggregate.test.ts: "import { describe, it, expect, beforeEach, afterEach } from 'bun:test';\r\nimport { konro } from '../../../src/index';\r\nimport { testSchema, TEST_DIR, cleanup, ensureTestDir } from '../../util';\r\nimport path from 'path';\r\n\r\ndescribe('E2E > Operations > Aggregation', () => {\r\n  const dbFilePath = path.join(TEST_DIR, 'aggregation_test.json');\r\n  const adapter = konro.createFileAdapter({\r\n    format: 'json',\r\n    single: { filepath: dbFilePath },\r\n  });\r\n  const db = konro.createDatabase({\r\n    schema: testSchema,\r\n    adapter,\r\n  });\r\n\r\n  beforeEach(async () => {\r\n    await ensureTestDir();\r\n    let state = db.createEmptyState();\r\n    const usersToInsert = [\r\n      { name: 'User 1', email: 'u1@test.com', age: 20, isActive: true },\r\n      { name: 'User 2', email: 'u2@test.com', age: 25, isActive: true },\r\n      { name: 'User 3', email: 'u3@test.com', age: 30, isActive: false },\r\n      { name: 'User 4', email: 'u4@test.com', age: 35, isActive: true },\r\n      { name: 'User 5', email: 'u5@test.com', age: 40, isActive: false },\r\n    ];\r\n    [state] = db.insert(state, 'users', usersToInsert);\r\n    await db.write(state);\r\n  });\r\n  afterEach(cleanup);\r\n\r\n  it('should correctly calculate count, sum, avg, min, and max', async () => {\r\n    const state = await db.read();\r\n\r\n    const stats = db.query(state)\r\n      .from('users')\r\n      .aggregate({\r\n        totalUsers: konro.count(),\r\n        totalAge: konro.sum('age'),\r\n        averageAge: konro.avg('age'),\r\n        minAge: konro.min('age'),\r\n        maxAge: konro.max('age'),\r\n      });\r\n\r\n    expect(stats.totalUsers).toBe(5);\r\n    expect(stats.totalAge).toBe(20 + 25 + 30 + 35 + 40); // 150\r\n    expect(stats.averageAge).toBe(150 / 5); // 30\r\n    expect(stats.minAge).toBe(20);\r\n    expect(stats.maxAge).toBe(40);\r\n  });\r\n\r\n  it('should correctly calculate aggregations with a where clause', async () => {\r\n    const state = await db.read();\r\n\r\n    const stats = db.query(state)\r\n      .from('users')\r\n      .where({ isActive: true })\r\n      .aggregate({\r\n        activeUsers: konro.count(),\r\n        totalAgeActive: konro.sum('age'),\r\n      });\r\n\r\n    expect(stats.activeUsers).toBe(3);\r\n    expect(stats.totalAgeActive).toBe(20 + 25 + 35); // 80\r\n  });\r\n\r\n  it('should handle aggregations on empty sets', async () => {\r\n    const state = await db.read();\r\n\r\n    const stats = db.query(state)\r\n      .from('users')\r\n      .where({ name: 'Nonexistent' })\r\n      .aggregate({\r\n        count: konro.count(),\r\n        sum: konro.sum('age'),\r\n        avg: konro.avg('age'),\r\n        min: konro.min('age'),\r\n        max: konro.max('age'),\r\n      });\r\n\r\n    expect(stats.count).toBe(0);\r\n    expect(stats.sum).toBe(0); // sum of empty set is 0\r\n    expect(stats.avg).toBeNull();\r\n    expect(stats.min).toBeNull();\r\n    expect(stats.max).toBeNull();\r\n  });\r\n});"
  test/e2e/ErrorAndEdgeCases/Pagination.test.ts: "import { describe, it, expect, beforeEach, afterEach } from 'bun:test';\r\nimport { konro } from '../../../src/index';\r\nimport { testSchema, TEST_DIR, cleanup, ensureTestDir } from '../../util';\r\nimport path from 'path';\r\n\r\ndescribe('E2E > ErrorAndEdgeCases > Pagination', () => {\r\n  const dbFilePath = path.join(TEST_DIR, 'pagination_test.json');\r\n  const adapter = konro.createFileAdapter({\r\n    format: 'json',\r\n    single: { filepath: dbFilePath },\r\n  });\r\n  const db = konro.createDatabase({\r\n    schema: testSchema,\r\n    adapter,\r\n  });\r\n\r\n    beforeEach(async () => {\r\n        await ensureTestDir();\r\n        let state = db.createEmptyState();\r\n        const usersToInsert = [];\r\n        for (let i = 1; i <= 100; i++) {\r\n            usersToInsert.push({\r\n                name: `User ${i}`,\r\n                email: `user${i}@test.com`,\r\n                age: 20 + (i % 30),\r\n                isActive: true\r\n            });\r\n        }\r\n        [state] = db.insert(state, 'users', usersToInsert);\r\n        await db.write(state);\r\n    });\r\n    afterEach(cleanup);\r\n\r\n  it('should correctly paginate through a large set of records from a file', async () => {\r\n    const state = await db.read();\r\n    expect(state.users!.records.length).toBe(100);\r\n\r\n    // Get page 1 (items 1-10)\r\n    const page1 = await db.query(state).from('users').limit(10).offset(0).all();\r\n    expect(page1.length).toBe(10);\r\n    expect(page1[0]?.name).toBe('User 1');\r\n    expect(page1[9]?.name).toBe('User 10');\r\n\r\n    // Get page 2 (items 11-20)\r\n    const page2 = await db.query(state).from('users').limit(10).offset(10).all();\r\n    expect(page2.length).toBe(10);\r\n    expect(page2[0]?.name).toBe('User 11');\r\n    expect(page2[9]?.name).toBe('User 20');\r\n\r\n    // Get the last page, which might be partial\r\n    const lastPage = await db.query(state).from('users').limit(10).offset(95).all();\r\n    expect(lastPage.length).toBe(5);\r\n    expect(lastPage[0]?.name).toBe('User 96');\r\n    expect(lastPage[4]?.name).toBe('User 100');\r\n\r\n    // Get an empty page beyond the end\r\n    const emptyPage = await db.query(state).from('users').limit(10).offset(100).all();\r\n    expect(emptyPage.length).toBe(0);\r\n  });\r\n});\r\n"
  test/e2e/Operations/Delete.test.ts: "import { describe, it, expect, beforeEach, afterEach } from 'bun:test';\r\nimport { konro } from '../../../src/index';\r\nimport { testSchema, TEST_DIR, cleanup, ensureTestDir } from '../../util';\r\nimport path from 'path';\r\n\r\ndescribe('E2E > Operations > Delete', () => {\r\n  const dbFilePath = path.join(TEST_DIR, 'delete_test.json');\r\n  const adapter = konro.createFileAdapter({\r\n    format: 'json',\r\n    single: { filepath: dbFilePath },\r\n  });\r\n  const db = konro.createDatabase({\r\n    schema: testSchema,\r\n    adapter,\r\n  });\r\n\r\n  beforeEach(async () => {\r\n    await ensureTestDir();\r\n    let state = db.createEmptyState();\r\n    const usersToInsert = [\r\n      { name: 'User A', email: 'a@test.com', age: 20 },\r\n      { name: 'User B', email: 'b@test.com', age: 30 },\r\n      { name: 'User C', email: 'c@test.com', age: 40 },\r\n    ];\r\n    [state] = db.insert(state, 'users', usersToInsert);\r\n    await db.write(state);\r\n  });\r\n  afterEach(cleanup);\r\n\r\n  it('should delete a single record matching a predicate object', async () => {\r\n    let state = await db.read();\r\n    expect(db.query(state).from('users').all().length).toBe(3);\r\n\r\n    let deletedUsers;\r\n    [state, deletedUsers] = db.delete(state, 'users').where({ email: 'b@test.com' });\r\n\r\n    expect(deletedUsers.length).toBe(1);\r\n    expect(deletedUsers[0]?.name).toBe('User B');\r\n\r\n    const remainingUsers = db.query(state).from('users').all();\r\n    expect(remainingUsers.length).toBe(2);\r\n    expect(remainingUsers.find(u => u.email === 'b@test.com')).toBeUndefined();\r\n  });\r\n\r\n  it('should delete multiple records matching a predicate function', async () => {\r\n    let state = await db.read();\r\n    expect(db.query(state).from('users').all().length).toBe(3);\r\n\r\n    let deletedUsers;\r\n    [state, deletedUsers] = db.delete(state, 'users').where(user => user.age < 35);\r\n\r\n    expect(deletedUsers.length).toBe(2);\r\n    expect(deletedUsers.map(u => u.name).sort()).toEqual(['User A', 'User B']);\r\n\r\n    const remainingUsers = db.query(state).from('users').all();\r\n    expect(remainingUsers.length).toBe(1);\r\n    expect(remainingUsers[0]?.name).toBe('User C');\r\n  });\r\n\r\n  it('should return an empty array and unchanged state if no records match', async () => {\r\n    const initialState = await db.read();\r\n    \r\n    const [newState, deletedUsers] = db.delete(initialState, 'users').where({ name: 'Nonexistent' });\r\n\r\n    expect(deletedUsers.length).toBe(0);\r\n    expect(newState).toBe(initialState); // Should be the exact same object reference\r\n  });\r\n\r\n  it('should persist deletions to disk', async () => {\r\n    let state = await db.read();\r\n    [state] = db.delete(state, 'users').where({ id: 1 });\r\n    await db.write(state);\r\n\r\n    const stateAfterWrite = await db.read();\r\n    const users = db.query(stateAfterWrite).from('users').all();\r\n    expect(users.length).toBe(2);\r\n    expect(users.find(u => u.id === 1)).toBeUndefined();\r\n  });\r\n});"
  test/e2e/Operations/Insert.test.ts: "import { describe, it, expect, beforeEach, afterEach } from 'bun:test';\r\nimport { konro } from '../../../src/index';\r\nimport { testSchema, TEST_DIR, cleanup, ensureTestDir } from '../../util';\r\nimport path from 'path';\r\nimport { KonroValidationError } from '../../../src/utils/error.util';\r\n\r\ndescribe('E2E > Operations > Insert', () => {\r\n  const dbFilePath = path.join(TEST_DIR, 'insert_test.json');\r\n  const adapter = konro.createFileAdapter({\r\n    format: 'json',\r\n    single: { filepath: dbFilePath },\r\n  });\r\n  const db = konro.createDatabase({\r\n    schema: testSchema,\r\n    adapter,\r\n  });\r\n\r\n  beforeEach(async () => {\r\n    await ensureTestDir();\r\n    await db.write(db.createEmptyState());\r\n  });\r\n  afterEach(cleanup);\r\n\r\n  it('should insert a single record and return it', async () => {\r\n    const state = await db.read();\r\n    const [newState, newUser] = db.insert(state, 'users', {\r\n      name: 'John Doe',\r\n      email: 'john@test.com',\r\n      age: 30,\r\n    });\r\n\r\n    expect(newUser.id).toBe(1);\r\n    expect(newUser.name).toBe('John Doe');\r\n    expect(newUser.isActive).toBe(true); // default value\r\n\r\n    const usersInState = db.query(newState).from('users').all();\r\n    expect(usersInState.length).toBe(1);\r\n    expect(usersInState[0]).toEqual(newUser);\r\n  });\r\n\r\n  it('should insert multiple records and return them', async () => {\r\n    const state = await db.read();\r\n    const usersToInsert = [\r\n      { name: 'Jane Doe', email: 'jane@test.com', age: 28 },\r\n      { name: 'Peter Pan', email: 'peter@test.com', age: 100, isActive: false },\r\n    ];\r\n    const [newState, newUsers] = db.insert(state, 'users', usersToInsert);\r\n\r\n    expect(newUsers.length).toBe(2);\r\n    expect(newUsers[0]?.id).toBe(1);\r\n    expect(newUsers[1]?.id).toBe(2);\r\n    expect(newUsers[0]?.name).toBe('Jane Doe');\r\n    expect(newUsers[1]?.isActive).toBe(false);\r\n\r\n    const usersInState = db.query(newState).from('users').all();\r\n    expect(usersInState.length).toBe(2);\r\n  });\r\n\r\n  it('should auto-increment IDs correctly across multiple inserts', async () => {\r\n    let state = await db.read();\r\n    let newUser;\r\n\r\n    [state, newUser] = db.insert(state, 'users', { name: 'First', email: 'first@test.com', age: 20 });\r\n    expect(newUser.id).toBe(1);\r\n\r\n    [state, newUser] = db.insert(state, 'users', { name: 'Second', email: 'second@test.com', age: 21 });\r\n    expect(newUser.id).toBe(2);\r\n  });\r\n\r\n  it('should throw validation error for duplicate unique fields', async () => {\r\n    let state = await db.read();\r\n    [state] = db.insert(state, 'users', { name: 'Unique User', email: 'unique@test.com', age: 40 });\r\n\r\n    const insertDuplicate = () => {\r\n      db.insert(state, 'users', { name: 'Another User', email: 'unique@test.com', age: 41 });\r\n    };\r\n\r\n    expect(insertDuplicate).toThrow(\"Value 'unique@test.com' for column 'email' must be unique\");\r\n  });\r\n\r\n  it('should throw validation error for constraint violations', async () => {\r\n    const state = await db.read();\r\n    const insertInvalid = () => {\r\n      db.insert(state, 'users', { name: 'A', email: 'bademail.com', age: 17 });\r\n    };\r\n    // It should throw on the first failure it finds. Order not guaranteed.\r\n    // In this case, 'name' length < 2\r\n    expect(insertInvalid).toThrow(KonroValidationError);\r\n  });\r\n});"
  test/e2e/Operations/Query-With.test.ts: "import { describe, it, expect, beforeEach, afterEach } from 'bun:test';\r\nimport { konro } from '../../../src/index';\r\nimport { testSchema, TEST_DIR, cleanup, ensureTestDir } from '../../util';\r\nimport path from 'path';\r\n\r\ndescribe('E2E > Operations > Query with Relations', () => {\r\n  const dbFilePath = path.join(TEST_DIR, 'query_with_test.json');\r\n  const adapter = konro.createFileAdapter({\r\n    format: 'json',\r\n    single: { filepath: dbFilePath },\r\n  });\r\n  const db = konro.createDatabase({\r\n    schema: testSchema,\r\n    adapter,\r\n  });\r\n\r\n  let userId1: number, userId2: number;\r\n  let postId1: number;\r\n\r\n  beforeEach(async () => {\r\n    await ensureTestDir();\r\n    let state = db.createEmptyState();\r\n    \r\n    // Insert users\r\n    let u1, u2;\r\n    [state, u1] = db.insert(state, 'users', { name: 'Alice', email: 'alice@test.com', age: 30 });\r\n    [state, u2] = db.insert(state, 'users', { name: 'Bob', email: 'bob@test.com', age: 35 });\r\n    userId1 = u1.id; \r\n    userId2 = u2.id;\r\n    \r\n    // Insert posts\r\n    let p1;\r\n    [state, p1] = db.insert(state, 'posts', { title: 'Alice Post 1', content: '...', authorId: userId1 });\r\n    [state] = db.insert(state, 'posts', { title: 'Bob Post 1', content: '...', authorId: userId2 });\r\n    [state] = db.insert(state, 'posts', { title: 'Alice Post 2', content: '...', authorId: userId1 });\r\n    postId1 = p1.id;\r\n\r\n    // Insert profiles\r\n    [state] = db.insert(state, 'profiles', { bio: 'Bio for Alice', userId: userId1 });\r\n\r\n    await db.write(state);\r\n  });\r\n  afterEach(cleanup);\r\n\r\n  it('should eager-load a one-to-many relationship', async () => {\r\n    const state = await db.read();\r\n    const user = db.query(state).from('users').where({ id: userId1 }).with({ posts: true }).first();\r\n\r\n    expect(user).toBeDefined();\r\n    expect(user?.posts).toBeDefined();\r\n    expect(user?.posts?.length).toBe(2);\r\n    expect(user?.posts?.map(p => p.title).sort()).toEqual(['Alice Post 1', 'Alice Post 2']);\r\n  });\r\n\r\n  it('should eager-load a many-to-one relationship', async () => {\r\n    const state = await db.read();\r\n    const post = db.query(state).from('posts').where({ id: postId1 }).with({ author: true }).first();\r\n\r\n    expect(post).toBeDefined();\r\n    expect(post?.author).toBeDefined();\r\n    expect(post?.author?.name).toBe('Alice');\r\n  });\r\n\r\n  it('should eager-load a one-to-one relationship', async () => {\r\n    const state = await db.read();\r\n    const user = db.query(state).from('users').where({ id: userId1 }).with({ profile: true }).first();\r\n    \r\n    expect(user).toBeDefined();\r\n    expect(user?.profile).toBeDefined();\r\n    expect(user?.profile?.bio).toBe('Bio for Alice');\r\n  });\r\n\r\n  it('should return null for a one-relation if no related record exists', async () => {\r\n    const state = await db.read();\r\n    const user = db.query(state).from('users').where({ id: userId2 }).with({ profile: true }).first();\r\n    \r\n    expect(user).toBeDefined();\r\n    expect(user?.profile).toBeNull();\r\n  });\r\n\r\n  it('should return an empty array for a many-relation if no related records exist', async () => {\r\n    let state = await db.read();\r\n    let newUser;\r\n    [state, newUser] = db.insert(state, 'users', { name: 'Charlie', email: 'charlie@test.com', age: 40 });\r\n    \r\n    const user = db.query(state).from('users').where({ id: newUser.id }).with({ posts: true }).first();\r\n    expect(user).toBeDefined();\r\n    expect(user?.posts).toEqual([]);\r\n  });\r\n\r\n  it('should handle nested eager-loading', async () => {\r\n    const state = await db.read();\r\n    const post = db.query(state)\r\n      .from('posts')\r\n      .where({ id: postId1 })\r\n      .with({\r\n        author: {\r\n          with: {\r\n            posts: true,\r\n            profile: true,\r\n          },\r\n        },\r\n      })\r\n      .first();\r\n\r\n    expect(post?.author?.name).toBe('Alice');\r\n    expect(post?.author?.profile?.bio).toBe('Bio for Alice');\r\n    expect(post?.author?.posts?.length).toBe(2);\r\n  });\r\n\r\n  it('should filter related records with a `where` clause', async () => {\r\n    const state = await db.read();\r\n    const user = db.query(state)\r\n      .from('users')\r\n      .where({ id: userId1 })\r\n      .with({\r\n        posts: {\r\n          where: (post) => post.title.includes('Post 2'),\r\n        }\r\n      })\r\n      .first();\r\n\r\n    expect(user?.posts?.length).toBe(1);\r\n    expect(user?.posts?.[0]?.title).toBe('Alice Post 2');\r\n  });\r\n\r\n  it('should select specific fields from related records', async () => {\r\n    const state = await db.read();\r\n    const user = db.query(state)\r\n        .from('users')\r\n        .where({ id: userId1 })\r\n        .with({\r\n            posts: {\r\n                select: {\r\n                    postTitle: testSchema.tables.posts.title,\r\n                }\r\n            }\r\n        })\r\n        .first();\r\n\r\n    expect(user?.posts?.length).toBe(2);\r\n    expect(user?.posts?.[0]).toEqual({ postTitle: 'Alice Post 1' });\r\n    expect(user?.posts?.[1]).toEqual({ postTitle: 'Alice Post 2' });\r\n    // @ts-expect-error - content should not exist on the selected type\r\n    expect(user?.posts?.[0]?.content).toBeUndefined();\r\n  });\r\n});"
  test/e2e/Operations/Query.test.ts: "import { describe, it, expect, beforeEach, afterEach } from 'bun:test';\r\nimport { konro } from '../../../src/index';\r\nimport { testSchema, TEST_DIR, cleanup, ensureTestDir } from '../../util';\r\nimport path from 'path';\r\n\r\ndescribe('E2E > Operations > Query', () => {\r\n  const dbFilePath = path.join(TEST_DIR, 'query_test.json');\r\n  const adapter = konro.createFileAdapter({\r\n    format: 'json',\r\n    single: { filepath: dbFilePath },\r\n  });\r\n  const db = konro.createDatabase({\r\n    schema: testSchema,\r\n    adapter,\r\n  });\r\n\r\n  beforeEach(async () => {\r\n    await ensureTestDir();\r\n    let state = db.createEmptyState();\r\n    const usersToInsert = [\r\n      { name: 'Alice', email: 'alice@test.com', age: 29, isActive: true },\r\n      { name: 'Bob', email: 'bob@test.com', age: 35, isActive: false },\r\n      { name: 'Charlie', email: 'charlie@test.com', age: 30, isActive: true },\r\n    ];\r\n    [state] = db.insert(state, 'users', usersToInsert);\r\n    await db.write(state);\r\n  });\r\n  afterEach(cleanup);\r\n\r\n  it('should return all records from a table', async () => {\r\n    const state = await db.read();\r\n    const users = db.query(state).from('users').all();\r\n    expect(users.length).toBe(3);\r\n  });\r\n\r\n  it('should filter records using a `where` object predicate', async () => {\r\n    const state = await db.read();\r\n    const users = db.query(state).from('users').where({ age: 30, isActive: true }).all();\r\n    expect(users.length).toBe(1);\r\n    expect(users[0]?.name).toBe('Charlie');\r\n  });\r\n\r\n  it('should filter records using a `where` function predicate', async () => {\r\n    const state = await db.read();\r\n    const users = db.query(state).from('users').where(u => u.name.startsWith('A') || u.name.startsWith('B')).all();\r\n    expect(users.length).toBe(2);\r\n    expect(users.map(u => u.name).sort()).toEqual(['Alice', 'Bob']);\r\n  });\r\n\r\n  it('should return a single record using `first()`', async () => {\r\n    const state = await db.read();\r\n    const user = db.query(state).from('users').where({ email: 'bob@test.com' }).first();\r\n    expect(user).toBeDefined();\r\n    expect(user?.name).toBe('Bob');\r\n  });\r\n\r\n  it('should return null from `first()` if no record matches', async () => {\r\n    const state = await db.read();\r\n    const user = db.query(state).from('users').where({ name: 'Zelda' }).first();\r\n    expect(user).toBeNull();\r\n  });\r\n\r\n  it('should limit the number of results', async () => {\r\n    const state = await db.read();\r\n    const users = db.query(state).from('users').limit(2).all();\r\n    expect(users.length).toBe(2);\r\n  });\r\n\r\n  it('should offset the results for pagination', async () => {\r\n    const state = await db.read();\r\n    const users = db.query(state).from('users').offset(1).all();\r\n    expect(users.length).toBe(2);\r\n    expect(users[0]?.name).toBe('Bob');\r\n  });\r\n\r\n  it('should combine limit and offset', async () => {\r\n    const state = await db.read();\r\n    const users = db.query(state).from('users').limit(1).offset(1).all();\r\n    expect(users.length).toBe(1);\r\n    expect(users[0]?.name).toBe('Bob');\r\n  });\r\n\r\n  it('should select and rename specific fields', async () => {\r\n    const state = await db.read();\r\n    const partialUsers = db.query(state)\r\n      .from('users')\r\n      .where({ name: 'Alice' })\r\n      .select({\r\n        userName: testSchema.tables.users.name,\r\n        userEmail: testSchema.tables.users.email,\r\n      })\r\n      .all();\r\n\r\n    expect(partialUsers.length).toBe(1);\r\n    const user = partialUsers[0];\r\n    expect(user as any).toEqual({ userName: 'Alice', userEmail: 'alice@test.com' });\r\n    expect((user as any).age).toBeUndefined();\r\n  });\r\n});"
  test/e2e/Operations/Update.test.ts: "import { describe, it, expect, beforeEach, afterEach } from 'bun:test';\r\nimport { konro } from '../../../src/index';\r\nimport { testSchema, TEST_DIR, cleanup, ensureTestDir } from '../../util';\r\nimport path from 'path';\r\nimport { KonroValidationError } from '../../../src/utils/error.util';\r\n\r\ndescribe('E2E > Operations > Update', () => {\r\n  const dbFilePath = path.join(TEST_DIR, 'update_test.json');\r\n  const adapter = konro.createFileAdapter({\r\n    format: 'json',\r\n    single: { filepath: dbFilePath },\r\n  });\r\n  const db = konro.createDatabase({\r\n    schema: testSchema,\r\n    adapter,\r\n  });\r\n\r\n  beforeEach(async () => {\r\n    await ensureTestDir();\r\n    let state = db.createEmptyState();\r\n    const usersToInsert = [\r\n      { name: 'User A', email: 'a@test.com', age: 20 },\r\n      { name: 'User B', email: 'b@test.com', age: 30 },\r\n      { name: 'User C', email: 'c@test.com', age: 40 },\r\n    ];\r\n    [state] = db.insert(state, 'users', usersToInsert);\r\n    await db.write(state);\r\n  });\r\n  afterEach(cleanup);\r\n\r\n  it('should update a single record and return it', async () => {\r\n    let state = await db.read();\r\n    let updatedUsers;\r\n    [state, updatedUsers] = db.update(state, 'users')\r\n      .set({ name: 'User A Updated', age: 21 })\r\n      .where({ email: 'a@test.com' });\r\n\r\n    expect(updatedUsers.length).toBe(1);\r\n    const updatedUser = updatedUsers[0];\r\n    expect(updatedUser?.name).toBe('User A Updated');\r\n    expect(updatedUser?.age).toBe(21);\r\n    expect(updatedUser?.id).toBe(1); // ID should be unchanged\r\n\r\n    const userInState = db.query(state).from('users').where({ id: 1 }).first();\r\n    expect(userInState?.name).toBe('User A Updated');\r\n  });\r\n\r\n  it('should update multiple records and return them', async () => {\r\n    let state = await db.read();\r\n    let updatedUsers;\r\n    [state, updatedUsers] = db.update(state, 'users')\r\n      .set({ isActive: false })\r\n      .where(user => user.age < 35);\r\n\r\n    expect(updatedUsers.length).toBe(2);\r\n    updatedUsers.forEach(u => expect(u.isActive).toBe(false));\r\n\r\n    const usersInState = db.query(state).from('users').all();\r\n    expect(usersInState.filter(u => !u.isActive).length).toBe(2);\r\n  });\r\n\r\n  it('should not allow updating the primary key', async () => {\r\n    let state = await db.read();\r\n    let updatedUsers;\r\n\r\n    [state, updatedUsers] = db.update(state, 'users')\r\n      // @ts-expect-error - ID is not a valid key in the update type\r\n      .set({ id: 99, name: 'ID Test' })\r\n      .where({ id: 1 });\r\n    \r\n    expect(updatedUsers.length).toBe(1);\r\n    expect(updatedUsers[0]?.id).toBe(1); // ID unchanged\r\n    expect(updatedUsers[0]?.name).toBe('ID Test');\r\n  });\r\n  \r\n  it('should throw validation error on update', async () => {\r\n    let state = await db.read();\r\n    \r\n    // Make 'c@test.com' unavailable\r\n    const failUpdate = () => {\r\n      db.update(state, 'users')\r\n        .set({ email: 'c@test.com' }) // Try to use an existing unique email\r\n        .where({ id: 1 });\r\n    };\r\n\r\n    expect(failUpdate).toThrow(KonroValidationError);\r\n  });\r\n\r\n  it('should return an empty array if no records match the update predicate', async () => {\r\n    let state = await db.read();\r\n    let updatedUsers;\r\n    [state, updatedUsers] = db.update(state, 'users')\r\n      .set({ name: 'Should not be set' })\r\n      .where({ id: 999 });\r\n\r\n    expect(updatedUsers.length).toBe(0);\r\n  });\r\n});"
  test/e2e/SingleFileJson/FullLifecycle.test.ts: "import { describe, it, expect, beforeEach, afterEach } from 'bun:test';\r\nimport { konro } from '../../../src/index';\r\nimport { testSchema, TEST_DIR, cleanup, ensureTestDir } from '../../util';\r\nimport path from 'path';\r\nimport { promises as fs } from 'fs';\r\n\r\ndescribe('E2E > SingleFileJson > FullLifecycle', () => {\r\n  const dbFilePath = path.join(TEST_DIR, 'e2e_db.json');\r\n  const adapter = konro.createFileAdapter({\r\n    format: 'json',\r\n    single: { filepath: dbFilePath },\r\n  });\r\n  const db = konro.createDatabase({\r\n    schema: testSchema,\r\n    adapter,\r\n  });\r\n\r\n  beforeEach(ensureTestDir);\r\n  afterEach(cleanup);\r\n\r\n  it('should handle a full data lifecycle: write, read, insert, query, update, delete', async () => {\r\n    // 1. Initialize an empty database file\r\n    let state = db.createEmptyState();\r\n    await db.write(state);\r\n    let fileContent = await fs.readFile(dbFilePath, 'utf-8');\r\n    expect(JSON.parse(fileContent).users.records.length).toBe(0);\r\n\r\n    // 2. Read state, insert a user and a post, and write back\r\n    state = await db.read();\r\n    const [s1, user] = db.insert(state, 'users', {\r\n      name: 'E2E User',\r\n      email: 'e2e@test.com',\r\n      age: 42,\r\n      isActive: true,\r\n    });\r\n    const [s2, post] = db.insert(s1, 'posts', {\r\n      title: 'E2E Post',\r\n      content: 'Live from the disk',\r\n      authorId: user.id,\r\n      publishedAt: new Date(),\r\n    });\r\n    await db.write(s2);\r\n\r\n    // 3. Read back and verify data integrity\r\n    let readState = await db.read();\r\n    expect(readState.users!.records.length).toBe(1);\r\n    expect(readState.posts!.records.length).toBe(1);\r\n    expect(readState.users!.records[0]?.name).toBe('E2E User');\r\n\r\n    // 4. Perform a complex query with relations on the re-read state\r\n    const userWithPosts = await db.query(readState)\r\n      .from('users')\r\n      .where({ id: user.id })\r\n      .with({ posts: true })\r\n      .first();\r\n\r\n    expect(userWithPosts).toBeDefined();\r\n    if (userWithPosts) {\r\n      expect(userWithPosts.posts).toBeDefined();\r\n      expect(userWithPosts.posts?.length).toBe(1);\r\n      expect(userWithPosts.posts?.[0]?.title).toBe('E2E Post');\r\n    }\r\n\r\n    // 5. Update a record, write the change, and read back to confirm\r\n    const [s3, updatedPosts] = await db.update(readState, 'posts')\r\n      .set({ title: 'Updated E2E Post' })\r\n      .where({ id: post.id });\r\n    expect(updatedPosts.length).toBe(1);\r\n    await db.write(s3);\r\n\r\n    let stateAfterUpdate = await db.read();\r\n    const updatedPostFromDisk = db.query(stateAfterUpdate).from('posts').where({ id: post.id }).first();\r\n    expect(updatedPostFromDisk?.title).toBe('Updated E2E Post');\r\n\r\n    // 6. Delete a record, write, and confirm it's gone\r\n    const [s4, deletedUsers] = db.delete(stateAfterUpdate, 'users')\r\n      .where({ id: user.id });\r\n    expect(deletedUsers.length).toBe(1);\r\n    await db.write(s4);\r\n\r\n    let finalState = await db.read();\r\n    expect(finalState.users!.records.length).toBe(0);\r\n    // The post should also effectively be orphaned, let's check it's still there\r\n    expect(finalState.posts!.records.length).toBe(1);\r\n  });\r\n});\r\n"
  test/integration/Adapters/MultiFileYaml.test.ts: "import { describe, it, expect, beforeEach, afterEach } from 'bun:test';\r\nimport { konro } from '../../../src/index';\r\nimport { testSchema, TEST_DIR, cleanup, ensureTestDir } from '../../util';\r\nimport path from 'path';\r\nimport { promises as fs } from 'fs';\r\nimport yaml from 'js-yaml';\r\n\r\ndescribe('Integration > Adapters > MultiFileYaml', () => {\r\n  const dbDirPath = path.join(TEST_DIR, 'yaml_db');\r\n  const adapter = konro.createFileAdapter({\r\n    format: 'yaml',\r\n    multi: { dir: dbDirPath },\r\n  });\r\n  const db = konro.createDatabase({\r\n    schema: testSchema,\r\n    adapter,\r\n  });\r\n\r\n  beforeEach(ensureTestDir);\r\n  afterEach(cleanup);\r\n\r\n  it('should correctly write each table to a separate YAML file', async () => {\r\n    let state = db.createEmptyState();\r\n    [state] = db.insert(state, 'users', {\r\n      name: 'YAML User',\r\n      email: 'yaml@test.com',\r\n      age: 44,\r\n    });\r\n    [state] = db.insert(state, 'posts', {\r\n      title: 'YAML Post',\r\n      content: 'Content here',\r\n      authorId: 1,\r\n    });\r\n\r\n    await db.write(state);\r\n\r\n    const usersFilePath = path.join(dbDirPath, 'users.yaml');\r\n    const postsFilePath = path.join(dbDirPath, 'posts.yaml');\r\n\r\n    const usersFileExists = await fs.access(usersFilePath).then(() => true).catch(() => false);\r\n    const postsFileExists = await fs.access(postsFilePath).then(() => true).catch(() => false);\r\n    expect(usersFileExists).toBe(true);\r\n    expect(postsFileExists).toBe(true);\r\n\r\n    const usersFileContent = await fs.readFile(usersFilePath, 'utf-8');\r\n    const postsFileContent = await fs.readFile(postsFilePath, 'utf-8');\r\n\r\n    const parsedUsers = yaml.load(usersFileContent) as { records: unknown[], meta: unknown };\r\n    const parsedPosts = yaml.load(postsFileContent) as { records: unknown[], meta: unknown };\r\n\r\n    expect(parsedUsers.records.length).toBe(1);\r\n    expect((parsedUsers.records[0] as { name: string }).name).toBe('YAML User');\r\n    expect((parsedUsers.meta as { lastId: number }).lastId).toBe(1);\r\n\r\n    expect(parsedPosts.records.length).toBe(1);\r\n    expect((parsedPosts.records[0] as { title: string }).title).toBe('YAML Post');\r\n    expect((parsedPosts.meta as { lastId: number }).lastId).toBe(1);\r\n  });\r\n\r\n  it('should correctly serialize and deserialize dates', async () => {\r\n    let state = db.createEmptyState();\r\n    const testDate = new Date('2023-10-27T10:00:00.000Z');\r\n\r\n    [state] = db.insert(state, 'posts', {\r\n      title: 'Dated Post',\r\n      content: '...',\r\n      authorId: 1,\r\n      publishedAt: testDate,\r\n    });\r\n\r\n    await db.write(state);\r\n\r\n    const readState = await db.read();\r\n\r\n    expect(readState.posts.records[0]?.publishedAt).toBeInstanceOf(Date);\r\n    expect((readState.posts.records[0]?.publishedAt as Date).getTime()).toBe(testDate.getTime());\r\n  });\r\n});\r\n"
  test/integration/Adapters/PerRecord.test.ts: "import { describe, it, expect, beforeEach, afterEach } from 'bun:test';\r\nimport { konro } from '../../../src/index';\r\nimport { testSchema, TEST_DIR, cleanup, ensureTestDir, uuidTestSchema } from '../../util';\r\nimport path from 'path';\r\nimport { promises as fs } from 'fs';\r\nimport yaml from 'js-yaml';\r\nimport { KonroError, KonroStorageError } from '../../../src/utils/error.util';\r\nimport type { InMemoryDbContext, OnDemandDbContext } from '../../../src/db';\r\n\r\ndescribe('Integration > Adapters > PerRecord', () => {\r\n  const dbDirPath = path.join(TEST_DIR, 'per_record_db');\r\n\r\n  beforeEach(ensureTestDir);\r\n  afterEach(cleanup);\r\n\r\n  describe('Initialization', () => {\r\n    it('should successfully create a per-record adapter', () => {\r\n      const adapter = konro.createFileAdapter({\r\n        format: 'json',\r\n        perRecord: { dir: dbDirPath },\r\n      });\r\n      expect(adapter).toBeDefined();\r\n      expect(adapter.options.perRecord).toEqual({ dir: dbDirPath });\r\n    });\r\n\r\n    it('should throw an error for unsupported formats like \"csv\"', () => {\r\n      expect(() => {\r\n        konro.createFileAdapter({\r\n          format: 'csv',\r\n          perRecord: { dir: dbDirPath },\r\n        });\r\n      }).toThrow(KonroError({ code: 'E105' }));\r\n    });\r\n  });\r\n\r\n  describe('In-Memory Mode (JSON)', () => {\r\n    let db: InMemoryDbContext<typeof testSchema>;\r\n    const adapter = konro.createFileAdapter({\r\n      format: 'json',\r\n      perRecord: { dir: dbDirPath },\r\n    });\r\n\r\n    beforeEach(() => {\r\n      db = konro.createDatabase({ schema: testSchema, adapter });\r\n    });\r\n\r\n    it('should write each record to a separate file and a meta file', async () => {\r\n      let state = db.createEmptyState();\r\n      [state] = db.insert(state, 'users', { name: 'Record User', email: 'rec@test.com', age: 33 });\r\n      [state] = db.insert(state, 'posts', { title: 'Record Post', content: '...', authorId: 1 });\r\n\r\n      await db.write(state);\r\n\r\n      const usersDir = path.join(dbDirPath, 'users');\r\n      const postsDir = path.join(dbDirPath, 'posts');\r\n      \r\n      const userRecordPath = path.join(usersDir, '1.json');\r\n      const userMetaPath = path.join(usersDir, '_meta.json');\r\n      const postRecordPath = path.join(postsDir, '1.json');\r\n      const postMetaPath = path.join(postsDir, '_meta.json');\r\n\r\n      const userRecordContent = JSON.parse(await fs.readFile(userRecordPath, 'utf-8'));\r\n      const userMetaContent = JSON.parse(await fs.readFile(userMetaPath, 'utf-8'));\r\n      const postRecordContent = JSON.parse(await fs.readFile(postRecordPath, 'utf-8'));\r\n      const postMetaContent = JSON.parse(await fs.readFile(postMetaPath, 'utf-8'));\r\n\r\n      expect(userRecordContent.name).toBe('Record User');\r\n      expect(userMetaContent.lastId).toBe(1);\r\n      expect(postRecordContent.title).toBe('Record Post');\r\n      expect(postMetaContent.lastId).toBe(1);\r\n    });\r\n\r\n    it('should delete record files that are no longer in the state', async () => {\r\n      let state = db.createEmptyState();\r\n      [state] = db.insert(state, 'users', { name: 'To Be Deleted', email: 'del@test.com', age: 40 });\r\n      await db.write(state);\r\n      \r\n      const userRecordPath = path.join(dbDirPath, 'users', '1.json');\r\n      expect(await fs.access(userRecordPath).then(() => true).catch(() => false)).toBe(true);\r\n\r\n      [state] = db.delete(state, 'users').where({ id: 1 });\r\n      await db.write(state);\r\n\r\n      expect(await fs.access(userRecordPath).then(() => true).catch(() => false)).toBe(false);\r\n    });\r\n\r\n    it('should read records from individual files to build the state', async () => {\r\n      // Manually create files\r\n      const usersDir = path.join(dbDirPath, 'users');\r\n      await fs.mkdir(usersDir, { recursive: true });\r\n      await fs.writeFile(path.join(usersDir, '1.json'), JSON.stringify({ id: 1, name: 'Manual User', email: 'man@test.com', age: 50, isActive: true }));\r\n      await fs.writeFile(path.join(usersDir, '_meta.json'), JSON.stringify({ lastId: 1 }));\r\n      \r\n      const state = await db.read();\r\n      \r\n      expect(state.users.records.length).toBe(1);\r\n      expect(state.users.records[0]?.name).toBe('Manual User');\r\n      expect(state.users.meta.lastId).toBe(1);\r\n      expect(state.posts.records.length).toBe(0);\r\n    });\r\n    \r\n    it('should derive lastId from record files if meta file is missing', async () => {\r\n        const usersDir = path.join(dbDirPath, 'users');\r\n        await fs.mkdir(usersDir, { recursive: true });\r\n        await fs.writeFile(path.join(usersDir, '2.json'), JSON.stringify({ id: 2, name: 'User 2', email: 'u2@test.com', age: 50, isActive: true }));\r\n        await fs.writeFile(path.join(usersDir, '5.json'), JSON.stringify({ id: 5, name: 'User 5', email: 'u5@test.com', age: 50, isActive: true }));\r\n\r\n        const state = await db.read();\r\n        expect(state.users.meta.lastId).toBe(5);\r\n    });\r\n\r\n    it('should throw KonroStorageError for a corrupt record file', async () => {\r\n      const usersDir = path.join(dbDirPath, 'users');\r\n      await fs.mkdir(usersDir, { recursive: true });\r\n      await fs.writeFile(path.join(usersDir, '1.json'), '{ \"id\": 1, \"name\": \"Corrupt\"'); // Invalid JSON\r\n      \r\n      await expect(db.read()).rejects.toThrow(KonroStorageError);\r\n    });\r\n  });\r\n\r\n  describe('On-Demand Mode (YAML)', () => {\r\n    let db: OnDemandDbContext<typeof testSchema>;\r\n    \r\n    beforeEach(() => {\r\n        const adapter = konro.createFileAdapter({\r\n            format: 'yaml',\r\n            mode: 'on-demand',\r\n            perRecord: { dir: dbDirPath },\r\n        });\r\n        db = konro.createDatabase({ schema: testSchema, adapter });\r\n    });\r\n\r\n    it('should insert a record and create its file and update meta', async () => {\r\n      const user = await db.insert('users', { name: 'OnDemand Record', email: 'odr@test.com', age: 25 });\r\n      \r\n      const userRecordPath = path.join(dbDirPath, 'users', `${user.id}.yaml`);\r\n      const userMetaPath = path.join(dbDirPath, 'users', '_meta.json');\r\n\r\n      const recordContent = yaml.load(await fs.readFile(userRecordPath, 'utf-8')) as any;\r\n      const metaContent = JSON.parse(await fs.readFile(userMetaPath, 'utf-8'));\r\n\r\n      expect(recordContent.name).toBe('OnDemand Record');\r\n      expect(metaContent.lastId).toBe(1);\r\n    });\r\n\r\n    it('should update a record file', async () => {\r\n      const user = await db.insert('users', { name: 'Update Me', email: 'upd@test.com', age: 35 });\r\n      await db.update('users').set({ name: 'Updated Name' }).where({ id: user.id });\r\n\r\n      const userRecordPath = path.join(dbDirPath, 'users', `${user.id}.yaml`);\r\n      const recordContent = yaml.load(await fs.readFile(userRecordPath, 'utf-8')) as any;\r\n      \r\n      expect(recordContent.name).toBe('Updated Name');\r\n    });\r\n\r\n    it('should delete a record file', async () => {\r\n      const user = await db.insert('users', { name: 'Delete Me', email: 'del@test.com', age: 45 });\r\n      const userRecordPath = path.join(dbDirPath, 'users', `${user.id}.yaml`);\r\n      expect(await fs.access(userRecordPath).then(() => true).catch(() => false)).toBe(true);\r\n\r\n      await db.delete('users').where({ id: user.id });\r\n      expect(await fs.access(userRecordPath).then(() => true).catch(() => false)).toBe(false);\r\n    });\r\n\r\n    it('should query with relations by reading multiple tables', async () => {\r\n        const user = await db.insert('users', { name: 'Author', email: 'author@test.com', age: 35 });\r\n        await db.insert('posts', { title: 'Post by Author', content: '...', authorId: user.id });\r\n        \r\n        const userWithPosts = await db.query().from('users').where({ id: user.id }).with({ posts: true }).first();\r\n        \r\n        expect(userWithPosts).toBeDefined();\r\n        expect(userWithPosts?.posts?.length).toBe(1);\r\n        expect(userWithPosts?.posts?.[0]?.title).toBe('Post by Author');\r\n    });\r\n  });\r\n\r\n  describe('ID Handling', () => {\r\n    it('should generate UUIDs for filenames and record IDs', async () => {\r\n        const adapter = konro.createFileAdapter({\r\n            format: 'json',\r\n            mode: 'on-demand',\r\n            perRecord: { dir: dbDirPath },\r\n        });\r\n        const db = konro.createDatabase({ schema: uuidTestSchema, adapter });\r\n\r\n        const user = await db.insert('uuid_users', { name: 'UUID User' });\r\n        \r\n        expect(typeof user.id).toBe('string');\r\n        const userRecordPath = path.join(dbDirPath, 'uuid_users', `${user.id}.json`);\r\n        expect(await fs.access(userRecordPath).then(() => true).catch(() => false)).toBe(true);\r\n        \r\n        const recordContent = JSON.parse(await fs.readFile(userRecordPath, 'utf-8'));\r\n        expect(recordContent.id).toBe(user.id);\r\n        expect(recordContent.name).toBe('UUID User');\r\n    });\r\n\r\n    it('on-demand insert should not derive lastId from existing files', async () => {\r\n        // Manually create a file with ID 5, but no meta file\r\n        const usersDir = path.join(dbDirPath, 'users');\r\n        await fs.mkdir(usersDir, { recursive: true });\r\n        await fs.writeFile(path.join(usersDir, '5.json'), JSON.stringify({ id: 5, name: 'Existing User', email: 'ex@test.com', age: 55, isActive: true }));\r\n        \r\n        const adapter = konro.createFileAdapter({ format: 'json', mode: 'on-demand', perRecord: { dir: dbDirPath } });\r\n        const db = konro.createDatabase({ schema: testSchema, adapter });\r\n        \r\n        // Inserting should start from ID 1 because _meta.json doesn't exist\r\n        const newUser = await db.insert('users', { name: 'New User', email: 'new@test.com', age: 22 });\r\n        expect(newUser.id).toBe(1);\r\n        \r\n        const metaContent = JSON.parse(await fs.readFile(path.join(usersDir, '_meta.json'), 'utf-8'));\r\n        expect(metaContent.lastId).toBe(1);\r\n    });\r\n  });\r\n});"
  test/integration/Adapters/Read.test.ts: "import { describe, it, expect, beforeEach, afterEach } from 'bun:test';\r\nimport { konro } from '../../../src/index';\r\nimport { testSchema, TEST_DIR, cleanup, ensureTestDir } from '../../util';\r\nimport path from 'path';\r\nimport { promises as fs } from 'fs';\r\nimport yaml from 'js-yaml';\r\nimport { KonroStorageError } from '../../../src/utils/error.util';\r\n\r\ndescribe('Integration > Adapters > Read', () => {\r\n\r\n  beforeEach(ensureTestDir);\r\n  afterEach(cleanup);\r\n\r\n  describe('SingleFileJson', () => {\r\n    const dbFilePath = path.join(TEST_DIR, 'read_test.json');\r\n    const adapter = konro.createFileAdapter({\r\n      format: 'json',\r\n      single: { filepath: dbFilePath },\r\n    });\r\n    const db = konro.createDatabase({ schema: testSchema, adapter });\r\n\r\n    it('should correctly read and parse a single JSON file', async () => {\r\n      const state = db.createEmptyState();\r\n      state.users.records.push({ id: 1, name: 'Reader', email: 'reader@test.com', age: 30, isActive: true });\r\n      state.users.meta.lastId = 1;\r\n      await fs.writeFile(dbFilePath, JSON.stringify(state, null, 2));\r\n\r\n      const readState = await db.read();\r\n      expect(readState.users.records.length).toBe(1);\r\n      expect(readState.users.records[0]?.name).toBe('Reader');\r\n      expect(readState.users.meta.lastId).toBe(1);\r\n    });\r\n\r\n    it('should return an empty state if the file does not exist', async () => {\r\n      const readState = await db.read();\r\n      expect(readState).toEqual(db.createEmptyState());\r\n    });\r\n\r\n    it('should throw KonroStorageError for a corrupt JSON file', async () => {\r\n      await fs.writeFile(dbFilePath, '{ \"users\": { \"records\": ['); // Invalid JSON\r\n      await expect(db.read()).rejects.toThrow(KonroStorageError);\r\n    });\r\n  });\r\n\r\n  describe('MultiFileYaml', () => {\r\n    const dbDirPath = path.join(TEST_DIR, 'read_yaml_test');\r\n    const adapter = konro.createFileAdapter({\r\n      format: 'yaml',\r\n      multi: { dir: dbDirPath },\r\n    });\r\n    const db = konro.createDatabase({ schema: testSchema, adapter });\r\n\r\n    it('should correctly read and parse multiple YAML files', async () => {\r\n      const state = db.createEmptyState();\r\n      state.users.records.push({ id: 1, name: 'YamlReader', email: 'yaml@test.com', age: 31, isActive: true });\r\n      state.users.meta.lastId = 1;\r\n      state.posts.records.push({ id: 1, title: 'Yaml Post', content: '...', authorId: 1, publishedAt: new Date() });\r\n      state.posts.meta.lastId = 1;\r\n\r\n      await fs.mkdir(dbDirPath, { recursive: true });\r\n      await fs.writeFile(path.join(dbDirPath, 'users.yaml'), yaml.dump({ records: state.users.records, meta: state.users.meta }));\r\n      await fs.writeFile(path.join(dbDirPath, 'posts.yaml'), yaml.dump({ records: state.posts.records, meta: state.posts.meta }));\r\n      \r\n      const readState = await db.read();\r\n      expect(readState.users.records.length).toBe(1);\r\n      expect(readState.users.records[0]?.name).toBe('YamlReader');\r\n      expect(readState.posts.records.length).toBe(1);\r\n      expect(readState.posts.records[0]?.title).toBe('Yaml Post');\r\n      expect(readState.tags.records.length).toBe(0); // Ensure non-existent files are handled\r\n    });\r\n\r\n    it('should return an empty state if the directory does not exist', async () => {\r\n      const readState = await db.read();\r\n      expect(readState).toEqual(db.createEmptyState());\r\n    });\r\n  });\r\n});"
  test/integration/Adapters/OnDemand.test.ts: "import { describe, it, expect, beforeEach, afterEach } from 'bun:test';\r\nimport { konro } from '../../../src/index';\r\nimport { testSchema, TEST_DIR, cleanup, ensureTestDir, uuidTestSchema } from '../../util';\r\nimport path from 'path';\r\nimport { promises as fs } from 'fs';\r\nimport yaml from 'js-yaml';\r\nimport papaparse from 'papaparse';\r\nimport xlsx from 'xlsx';\r\nimport { KonroError } from '../../../src/utils/error.util';\r\nimport type { OnDemandDbContext } from '../../../src/db';\r\n\r\ndescribe('Integration > Adapters > OnDemand', () => {\r\n  const dbDirPath = path.join(TEST_DIR, 'on_demand_db');\r\n\r\n  beforeEach(ensureTestDir);\r\n  afterEach(cleanup);\r\n\r\n  describe('Initialization', () => {\r\n    it('should successfully create an on-demand db context with a multi-file adapter', () => {\r\n      const adapter = konro.createFileAdapter({\r\n        format: 'yaml',\r\n        mode: 'on-demand',\r\n        multi: { dir: dbDirPath },\r\n      });\r\n      const db = konro.createDatabase({\r\n        schema: testSchema,\r\n        adapter,\r\n      });\r\n\r\n      expect(db).toBeDefined();\r\n      expect(db.adapter.mode).toBe('on-demand');\r\n      expect(typeof db.insert).toBe('function');\r\n      expect(typeof db.query).toBe('function');\r\n    });\r\n\r\n    it('should throw an error when creating an on-demand db context with a single-file adapter', () => {\r\n      expect(() => {\r\n        konro.createFileAdapter({\r\n          format: 'json',\r\n          mode: 'on-demand',\r\n          single: { filepath: path.join(dbDirPath, 'db.json') },\r\n        });\r\n      }).toThrow(KonroError({ code: 'E104' }));\r\n    });\r\n  });\r\n\r\n  describe('Unsupported Operations', () => {\r\n    const adapter = konro.createFileAdapter({\r\n      format: 'yaml',\r\n      mode: 'on-demand',\r\n      multi: { dir: dbDirPath },\r\n    });\r\n    const db = konro.createDatabase({\r\n      schema: testSchema,\r\n      adapter,\r\n    });\r\n    \r\n    it('should reject db.read()', async () => {\r\n      expect(db.read()).rejects.toThrow(KonroError({ code: 'E400', methodName: 'read' }));\r\n    });\r\n\r\n    it('should reject db.write()', async () => {\r\n      expect(db.write()).rejects.toThrow(KonroError({ code: 'E400', methodName: 'write' }));\r\n    });\r\n  });\r\n\r\n  describe('CRUD Operations', () => {\r\n    let db: OnDemandDbContext<typeof testSchema>;\r\n\r\n    beforeEach(() => {\r\n      const adapter = konro.createFileAdapter({\r\n        format: 'yaml',\r\n        mode: 'on-demand',\r\n        multi: { dir: dbDirPath },\r\n      });\r\n      db = konro.createDatabase({\r\n        schema: testSchema,\r\n        adapter,\r\n      });\r\n    });\r\n\r\n    it('should insert a record and write it to the correct file', async () => {\r\n      const user = await db.insert('users', {\r\n        name: 'OnDemand User',\r\n        email: 'ondemand@test.com',\r\n        age: 25,\r\n      });\r\n\r\n      expect(user.id).toBe(1);\r\n      expect(user.name).toBe('OnDemand User');\r\n\r\n      const userFilePath = path.join(dbDirPath, 'users.yaml');\r\n      const fileContent = await fs.readFile(userFilePath, 'utf-8');\r\n      const parsedContent = yaml.load(fileContent) as any;\r\n\r\n      expect(parsedContent.records.length).toBe(1);\r\n      expect(parsedContent.records[0].name).toBe('OnDemand User');\r\n      expect(parsedContent.meta.lastId).toBe(1);\r\n    });\r\n\r\n    it('should query for records', async () => {\r\n      await db.insert('users', { name: 'Query User', email: 'q@test.com', age: 30 });\r\n      \r\n      const user = await db.query().from('users').where({ name: 'Query User' }).first();\r\n      expect(user).toBeDefined();\r\n      expect(user?.name).toBe('Query User');\r\n\r\n      const allUsers = await db.query().from('users').all();\r\n      expect(allUsers.length).toBe(1);\r\n    });\r\n\r\n    it('should update a record', async () => {\r\n      const user = await db.insert('users', { name: 'Update Me', email: 'u@test.com', age: 40 });\r\n      \r\n      const updatedUsers = await db.update('users')\r\n        .set({ name: 'Updated Name' })\r\n        .where({ id: user.id });\r\n\r\n      expect(updatedUsers.length).toBe(1);\r\n      expect(updatedUsers[0]?.name).toBe('Updated Name');\r\n\r\n      const userFilePath = path.join(dbDirPath, 'users.yaml');\r\n      const fileContent = await fs.readFile(userFilePath, 'utf-8');\r\n      const parsedContent = yaml.load(fileContent) as any;\r\n      \r\n      expect(parsedContent.records[0].name).toBe('Updated Name');\r\n    });\r\n\r\n    it('should delete a record', async () => {\r\n      const user = await db.insert('users', { name: 'Delete Me', email: 'd@test.com', age: 50 });\r\n      \r\n      await db.delete('users').where({ id: user.id });\r\n\r\n      const users = await db.query().from('users').all();\r\n      expect(users.length).toBe(0);\r\n\r\n      const userFilePath = path.join(dbDirPath, 'users.yaml');\r\n      const fileContent = await fs.readFile(userFilePath, 'utf-8');\r\n      const parsedContent = yaml.load(fileContent) as any;\r\n      \r\n      expect(parsedContent.records.length).toBe(0);\r\n    });\r\n    \r\n    it('should query with relations', async () => {\r\n      const user = await db.insert('users', { name: 'Author', email: 'author@test.com', age: 35 });\r\n      await db.insert('posts', { title: 'Post by Author', content: '...', authorId: user.id });\r\n      await db.insert('posts', { title: 'Another Post', content: '...', authorId: user.id });\r\n      \r\n      const userWithPosts = await db.query().from('users').where({ id: user.id }).with({ posts: true }).first();\r\n      \r\n      expect(userWithPosts).toBeDefined();\r\n      expect(userWithPosts?.name).toBe('Author');\r\n      expect(userWithPosts?.posts).toBeInstanceOf(Array);\r\n      expect(userWithPosts?.posts?.length).toBe(2);\r\n      expect(userWithPosts?.posts?.[0]?.title).toBe('Post by Author');\r\n    });\r\n\r\n    it('should perform aggregations', async () => {\r\n      await db.insert('users', { name: 'Agg User 1', email: 'agg1@test.com', age: 20 });\r\n      await db.insert('users', { name: 'Agg User 2', email: 'agg2@test.com', age: 30 });\r\n      \r\n      const result = await db.query().from('users').aggregate({\r\n        count: konro.count(),\r\n        avgAge: konro.avg('age'),\r\n        sumAge: konro.sum('age'),\r\n      });\r\n      \r\n      expect(result.count).toBe(2);\r\n      expect(result.avgAge).toBe(25);\r\n      expect(result.sumAge).toBe(50);\r\n    });\r\n  });\r\n\r\n  describe('ID Generation', () => {\r\n    it('should auto-increment IDs for new CSV files', async () => {\r\n      const dbDirPath = path.join(TEST_DIR, 'csv_db');\r\n      const adapter = konro.createFileAdapter({\r\n        format: 'csv',\r\n        mode: 'on-demand',\r\n        multi: { dir: dbDirPath },\r\n      });\r\n      const db = konro.createDatabase({ schema: testSchema, adapter });\r\n\r\n      const user1 = await db.insert('users', { name: 'CSV User 1', email: 'csv1@test.com', age: 20 });\r\n      expect(user1.id).toBe(1);\r\n\r\n      const user2 = await db.insert('users', { name: 'CSV User 2', email: 'csv2@test.com', age: 21 });\r\n      expect(user2.id).toBe(2);\r\n\r\n      // Verify file content\r\n      const userFilePath = path.join(dbDirPath, 'users.csv');\r\n      const fileContent = await fs.readFile(userFilePath, 'utf-8');\r\n      const parsed = papaparse.parse(fileContent, { header: true, dynamicTyping: true, skipEmptyLines: true });\r\n      expect(parsed.data).toEqual(\r\n        expect.arrayContaining([\r\n          expect.objectContaining({ id: 1, name: 'CSV User 1', email: 'csv1@test.com', age: 20, isActive: true }),\r\n          expect.objectContaining({ id: 2, name: 'CSV User 2', email: 'csv2@test.com', age: 21, isActive: true }),\r\n        ])\r\n      );\r\n    });\r\n\r\n    it('should auto-increment IDs for new XLSX files', async () => {\r\n      const dbDirPath = path.join(TEST_DIR, 'xlsx_db');\r\n      const adapter = konro.createFileAdapter({\r\n        format: 'xlsx',\r\n        mode: 'on-demand',\r\n        multi: { dir: dbDirPath },\r\n      });\r\n      const db = konro.createDatabase({ schema: testSchema, adapter });\r\n\r\n      const user1 = await db.insert('users', { name: 'XLSX User 1', email: 'xlsx1@test.com', age: 20 });\r\n      expect(user1.id).toBe(1);\r\n\r\n      const user2 = await db.insert('users', { name: 'XLSX User 2', email: 'xlsx2@test.com', age: 21 });\r\n      expect(user2.id).toBe(2);\r\n\r\n      // Verify file content\r\n      const userFilePath = path.join(dbDirPath, 'users.xlsx');\r\n      const fileContent = await fs.readFile(userFilePath, 'utf-8');\r\n      const workbook = xlsx.read(fileContent, { type: 'base64' });\r\n      const sheetName = workbook.SheetNames[0];\r\n      expect(sheetName).toBeDefined();\r\n      const worksheet = workbook.Sheets[sheetName!];\r\n      expect(worksheet).toBeDefined();\r\n      const data = xlsx.utils.sheet_to_json(worksheet!);\r\n      expect(data).toEqual(\r\n        expect.arrayContaining([\r\n          expect.objectContaining({ id: 1, name: 'XLSX User 1', email: 'xlsx1@test.com', age: 20, isActive: true }),\r\n          expect.objectContaining({ id: 2, name: 'XLSX User 2', email: 'xlsx2@test.com', age: 21, isActive: true }),\r\n        ])\r\n      );\r\n    });\r\n\r\n    it('should determine lastId from existing CSV files', async () => {\r\n      const dbDirPath = path.join(TEST_DIR, 'csv_db_read');\r\n      const userFilePath = path.join(dbDirPath, 'users.csv');\r\n\r\n      // Manually create a CSV with existing data\r\n      await fs.mkdir(dbDirPath, { recursive: true });\r\n      const initialCsv = papaparse.unparse([{ id: 5, name: 'Existing User', email: 'existing@test.com', age: 50, isActive: true }]);\r\n      await fs.writeFile(userFilePath, initialCsv);\r\n\r\n      const adapter = konro.createFileAdapter({ format: 'csv', mode: 'on-demand', multi: { dir: dbDirPath } });\r\n      const db = konro.createDatabase({ schema: testSchema, adapter });\r\n\r\n      const newUser = await db.insert('users', { name: 'New CSV User', email: 'newcsv@test.com', age: 25 });\r\n      expect(newUser.id).toBe(6);\r\n    });\r\n\r\n    it('should determine lastId from existing XLSX files', async () => {\r\n      const dbDirPath = path.join(TEST_DIR, 'xlsx_db_read');\r\n      const userFilePath = path.join(dbDirPath, 'users.xlsx');\r\n\r\n      // Manually create an XLSX with existing data\r\n      await fs.mkdir(dbDirPath, { recursive: true });\r\n      const initialData = [{ id: 10, name: 'Existing XLSX User', email: 'existing_xlsx@test.com', age: 60, isActive: false }];\r\n      const worksheet = xlsx.utils.json_to_sheet(initialData);\r\n      const workbook = xlsx.utils.book_new();\r\n      xlsx.utils.book_append_sheet(workbook, worksheet, 'data');\r\n      const fileContent = xlsx.write(workbook, { bookType: 'xlsx', type: 'base64' });\r\n      await fs.writeFile(userFilePath, fileContent, 'utf-8');\r\n\r\n      const adapter = konro.createFileAdapter({ format: 'xlsx', mode: 'on-demand', multi: { dir: dbDirPath } });\r\n      const db = konro.createDatabase({ schema: testSchema, adapter });\r\n\r\n      const newUser = await db.insert('users', { name: 'New XLSX User', email: 'newxlsx@test.com', age: 35 });\r\n      expect(newUser.id).toBe(11);\r\n    });\r\n\r\n    it('should generate UUIDs for id column', async () => {\r\n      const dbDirPath = path.join(TEST_DIR, 'uuid_db');\r\n      const adapter = konro.createFileAdapter({\r\n        format: 'yaml',\r\n        mode: 'on-demand',\r\n        multi: { dir: dbDirPath },\r\n      });\r\n      const db = konro.createDatabase({ schema: uuidTestSchema, adapter });\r\n\r\n      const user = await db.insert('uuid_users', { name: 'UUID User' });\r\n      expect(typeof user.id).toBe('string');\r\n      expect(user.id).toMatch(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/);\r\n\r\n      const fileContent = await fs.readFile(path.join(dbDirPath, 'uuid_users.yaml'), 'utf-8');\r\n      const parsed = yaml.load(fileContent) as any;\r\n      expect(parsed.records[0].id).toBe(user.id);\r\n    });\r\n  });\r\n});"
  test/integration/Adapters/SingleFileJson.test.ts: "import { describe, it, expect, beforeEach, afterEach } from 'bun:test';\r\nimport { konro } from '../../../src/index';\r\nimport { testSchema, TEST_DIR, cleanup, ensureTestDir } from '../../util';\r\nimport path from 'path';\r\nimport { promises as fs } from 'fs';\r\n\r\ndescribe('Integration > Adapters > SingleFileJson', () => {\r\n  const dbFilePath = path.join(TEST_DIR, 'db.json');\r\n  const adapter = konro.createFileAdapter({\r\n    format: 'json',\r\n    single: { filepath: dbFilePath },\r\n  });\r\n  const db = konro.createDatabase({\r\n    schema: testSchema,\r\n    adapter,\r\n  });\r\n\r\n  beforeEach(ensureTestDir);\r\n  afterEach(cleanup);\r\n\r\n  it('should correctly write the DatabaseState to a single JSON file', async () => {\r\n    let state = db.createEmptyState();\r\n    [state] = db.insert(state, 'users', {\r\n      name: 'JSON User',\r\n      email: 'json@test.com',\r\n      age: 33,\r\n    });\r\n\r\n    await db.write(state);\r\n\r\n    const fileExists = await fs.access(dbFilePath).then(() => true).catch(() => false);\r\n    expect(fileExists).toBe(true);\r\n\r\n    const fileContent = await fs.readFile(dbFilePath, 'utf-8');\r\n    const parsedContent = JSON.parse(fileContent);\r\n\r\n    expect(parsedContent.users.records.length).toBe(1);\r\n    expect(parsedContent.users.records[0].name).toBe('JSON User');\r\n    expect(parsedContent.users.meta.lastId).toBe(1);\r\n    expect(parsedContent.posts.records.length).toBe(0);\r\n  });\r\n\r\n  it('should correctly serialize complex data types like dates', async () => {\r\n    let state = db.createEmptyState();\r\n    const testDate = new Date('2023-10-27T10:00:00.000Z');\r\n\r\n    [state] = db.insert(state, 'posts', {\r\n      title: 'Dated Post',\r\n      content: '...',\r\n      authorId: 1,\r\n      // override default\r\n      publishedAt: testDate,\r\n    });\r\n\r\n    await db.write(state);\r\n\r\n    const fileContent = await fs.readFile(dbFilePath, 'utf-8');\r\n    const parsedContent = JSON.parse(fileContent);\r\n\r\n    expect(parsedContent.posts.records[0].publishedAt).toBe(testDate.toISOString());\r\n  });\r\n});\r\n"
  test/integration/DBContext/Initialization.test.ts: "import { describe, it, expect } from 'bun:test';\r\nimport { konro } from '../../../src/index';\r\nimport { testSchema } from '../../util';\r\nimport path from 'path';\r\n\r\ndescribe('Integration > DBContext > Initialization', () => {\r\n  it('should successfully create a db context with a valid schema and adapter', () => {\r\n    const adapter = konro.createFileAdapter({\r\n      format: 'json',\r\n      single: { filepath: path.join(__dirname, 'test.db.json') },\r\n    });\r\n\r\n    const db = konro.createDatabase({\r\n      schema: testSchema,\r\n      adapter: adapter,\r\n    });\r\n\r\n    expect(db).toBeDefined();\r\n    expect(db.schema).toEqual(testSchema);\r\n    expect(db.adapter).toBe(adapter);\r\n    expect(typeof db.read).toBe('function');\r\n    expect(typeof db.write).toBe('function');\r\n    expect(typeof db.insert).toBe('function');\r\n    expect(typeof db.update).toBe('function');\r\n    expect(typeof db.delete).toBe('function');\r\n    expect(typeof db.query).toBe('function');\r\n  });\r\n\r\n  it('should correctly generate a pristine, empty DatabaseState object via db.createEmptyState()', () => {\r\n    const adapter = konro.createFileAdapter({\r\n      format: 'json',\r\n      single: { filepath: path.join(__dirname, 'test.db.json') },\r\n    });\r\n    const db = konro.createDatabase({\r\n      schema: testSchema,\r\n      adapter,\r\n    });\r\n\r\n    const emptyState = db.createEmptyState();\r\n\r\n    expect(emptyState).toEqual({\r\n      users: { records: [], meta: { lastId: 0 } },\r\n      posts: { records: [], meta: { lastId: 0 } },\r\n      profiles: { records: [], meta: { lastId: 0 } },\r\n      tags: { records: [], meta: { lastId: 0 } },\r\n      posts_tags: { records: [], meta: { lastId: 0 } },\r\n    });\r\n  });\r\n\r\n  it('should have the full schema definition available at db.schema for direct reference in queries', () => {\r\n    const adapter = konro.createFileAdapter({\r\n      format: 'json',\r\n      single: { filepath: path.join(__dirname, 'test.db.json') },\r\n    });\r\n    const db = konro.createDatabase({\r\n      schema: testSchema,\r\n      adapter,\r\n    });\r\n\r\n    // Example of using db.schema to reference a column definition\r\n    const userEmailColumn = db.schema.tables.users.email;\r\n    expect(userEmailColumn).toEqual(testSchema.tables.users.email);\r\n    expect(userEmailColumn.dataType).toBe('string');\r\n  });\r\n});"
  test/integration/InMemoryFlow/CrudCycle.test.ts: "import { describe, it, expect, beforeEach } from 'bun:test';\r\nimport { konro } from '../../../src/index';\r\nimport { testSchema } from '../../util';\r\nimport path from 'path';\r\nimport type { InMemoryDbContext } from '../../../src/db';\r\nimport type { DatabaseState } from '../../../src/types';\r\n\r\ndescribe('Integration > InMemoryFlow > CrudCycle', () => {\r\n  let db: InMemoryDbContext<typeof testSchema>;\r\n  let state: DatabaseState<typeof testSchema>;\r\n\r\n  beforeEach(() => {\r\n    // Adapter is needed for context creation, but we won't use its I/O\r\n    const adapter = konro.createFileAdapter({\r\n      format: 'json',\r\n      single: { filepath: path.join(__dirname, 'test.db.json') },\r\n    });\r\n    db = konro.createDatabase({\r\n      schema: testSchema,\r\n      adapter,\r\n    });\r\n    state = db.createEmptyState();\r\n  });\r\n\r\n  it('should allow inserting a record and then immediately querying for it', () => {\r\n    const [newState, insertedUser] = db.insert(state, 'users', {\r\n      name: 'InMemory Alice',\r\n      email: 'alice@inmemory.com',\r\n      age: 30,\r\n      isActive: true,\r\n    });\r\n    expect(insertedUser.id).toBe(1);\r\n\r\n    const users = db.query(newState).from('users').all();\r\n    expect(users.length).toBe(1);\r\n    expect(users[0]).toEqual(insertedUser);\r\n  });\r\n\r\n  it('should correctly chain mutation operations by passing the newState', () => {\r\n    // Insert user\r\n    const [stateAfterUserInsert, user] = db.insert(state, 'users', {\r\n      name: 'Chain User',\r\n      email: 'chain@test.com',\r\n      age: 40,\r\n      isActive: true,\r\n    });\r\n\r\n    // Insert post using the new state\r\n    const [stateAfterPostInsert, post] = db.insert(stateAfterUserInsert, 'posts', {\r\n      title: 'Chained Post',\r\n      content: '...',\r\n      authorId: user.id,\r\n      publishedAt: new Date(),\r\n    });\r\n\r\n    expect(stateAfterPostInsert.users.records.length).toBe(1);\r\n    expect(stateAfterPostInsert.posts.records.length).toBe(1);\r\n    expect(post.authorId).toBe(user.id);\r\n  });\r\n\r\n  it('should update a record and verify the change in the returned newState', () => {\r\n    const [stateAfterInsert, user] = db.insert(state, 'users', {\r\n      name: 'Update Me',\r\n      email: 'update@test.com',\r\n      age: 50,\r\n      isActive: true,\r\n    });\r\n\r\n    const [stateAfterUpdate, updatedUsers] = db.update(stateAfterInsert, 'users')\r\n      .set({ name: 'Updated Name' })\r\n      .where({ id: user.id });\r\n\r\n    expect(updatedUsers.length).toBe(1);\r\n    expect(updatedUsers[0]?.name).toBe('Updated Name');\r\n\r\n    const queriedUser = db.query(stateAfterUpdate).from('users').where({ id: user.id }).first();\r\n    expect(queriedUser?.name).toBe('Updated Name');\r\n    expect(stateAfterInsert.users.records[0]?.name).toBe('Update Me'); // Original state is untouched\r\n  });\r\n\r\n  it('should delete a record and verify its absence in the returned newState', () => {\r\n    const [stateAfterInsert, user] = db.insert(state, 'users', {\r\n      name: 'Delete Me',\r\n      email: 'delete@test.com',\r\n      age: 60,\r\n      isActive: true,\r\n    });\r\n\r\n    const [stateAfterDelete, deletedUsers] = db.delete(stateAfterInsert, 'users')\r\n      .where({ id: user.id });\r\n\r\n    expect(deletedUsers.length).toBe(1);\r\n    expect(deletedUsers[0]?.name).toBe('Delete Me');\r\n\r\n    const users = db.query(stateAfterDelete).from('users').all();\r\n    expect(users.length).toBe(0);\r\n  });\r\n\r\n  it('should correctly execute a query with a .with() clause on an in-memory state', () => {\r\n    const [s1, user] = db.insert(state, 'users', {\r\n      name: 'Relation User',\r\n      email: 'relation@test.com',\r\n      age: 35,\r\n      isActive: true,\r\n    });\r\n    const [s2, ] = db.insert(s1, 'posts', [\r\n        { title: 'Relational Post 1', content: '...', authorId: user.id, publishedAt: new Date() },\r\n        { title: 'Relational Post 2', content: '...', authorId: user.id, publishedAt: new Date() },\r\n    ]);\r\n\r\n    const userWithPosts = db.query(s2).from('users').where({ id: user.id }).with({ posts: true }).first();\r\n\r\n    expect(userWithPosts).toBeDefined();\r\n    expect(userWithPosts?.name).toBe('Relation User');\r\n    expect(userWithPosts?.posts).toBeInstanceOf(Array);\r\n    expect(userWithPosts?.posts?.length).toBe(2);\r\n    expect(userWithPosts?.posts?.[0]?.title).toBe('Relational Post 1');\r\n  });\r\n});\r\n"
  test/integration/Types/InferredTypes.test-d.ts: "import { describe, it } from 'bun:test';\r\nimport { konro } from '../../../src/index';\r\nimport { schemaDef } from '../../util';\r\n\r\n/**\r\n * NOTE: This is a type definition test file.\r\n * It is not meant to be run, but to be checked by `tsc`.\r\n * The presence of `// @ts-expect-error` comments indicates\r\n * that a TypeScript compilation error is expected on the next line.\r\n * If the error does not occur, `tsc` will fail, which is the desired behavior for this test.\r\n */\r\ndescribe('Integration > Types > InferredTypes', () => {\r\n  it('should pass type checks', () => {\r\n    const testSchema = konro.createSchema(schemaDef);\r\n    type User = typeof testSchema.types.users;\r\n\r\n    // Test 1: Inferred User type should have correct primitive and relational fields.\r\n    const user: User = {\r\n      id: 1,\r\n      name: 'Alice',\r\n      email: 'alice@example.com',\r\n      age: 30,\r\n      isActive: true,\r\n      posts: [{\r\n        id: 1,\r\n        title: 'Post 1',\r\n        content: '...',\r\n        authorId: 1,\r\n        publishedAt: new Date(),\r\n      }],\r\n      profile: null,\r\n    };\r\n\r\n    // This should be valid\r\n    user.name; // Accessing for type check\r\n    const inMemoryAdapter = konro.createFileAdapter({ format: 'json', single: { filepath: 'dummy.json' }});\r\n    const db = konro.createDatabase({ schema: testSchema, adapter: inMemoryAdapter });\r\n    const state = db.createEmptyState(); // For in-memory db\r\n\r\n    // Test 2: Should cause a TS error if a non-existent field is used in a where clause.\r\n    // @ts-expect-error - 'nonExistentField' does not exist on type 'User'.\r\n    db.query(state).from('users').where({ nonExistentField: 'value' });\r\n\r\n    // This should be valid\r\n    db.query(state).from('users').where({ name: 'Alice' });\r\n\r\n    // Test 3: Should cause a TS error if a wrong type is passed to db.insert().\r\n    // @ts-expect-error - 'age' should be a number, not a string.\r\n    db.insert(state, 'users', { name: 'Bob', email: 'bob@test.com', age: 'twenty-five' });\r\n\r\n    // This should be valid - using type assertion for test-only code\r\n    // @ts-ignore - This is a type test only, not runtime code\r\n    db.insert(state, 'users', { name: 'Bob', email: 'bob@test.com', age: 25 });\r\n\r\n    // Test 4: Nested .with clause on in-memory db should be typed correctly\r\n    db.query(state).from('users').with({\r\n      posts: {\r\n        where: (post) => post.title.startsWith('A') // post is typed as Post\r\n      }\r\n    }).first();\r\n\r\n    // @ts-expect-error - 'nonExistentRelation' is not a valid relation on 'users'\r\n    db.query(state).from('users').with({ nonExistentRelation: true });\r\n\r\n    // Test 5: A query without .with() should return the base type, without relations.\r\n    const baseUser = db.query(state).from('users').where({ id: 1 }).first();\r\n    // This should be valid\r\n    baseUser?.name;\r\n    // @ts-expect-error - 'posts' does not exist on base user type, as .with() was not used.\r\n    baseUser?.posts;\r\n\r\n    // Test 6: A query with .with() should return the relations, which are now accessible.\r\n    const userWithPosts = db.query(state).from('users').where({ id: 1 }).with({ posts: true }).first();\r\n    userWithPosts?.posts; // This should be valid and typed as Post[] | undefined\r\n    \r\n    // userWithPosts?.posts?.[0]?.author; \r\n\r\n    // --- On-Demand DB Type Tests ---\r\n    const onDemandAdapter = konro.createFileAdapter({ format: 'yaml', mode: 'on-demand', multi: { dir: 'dummy-dir' }});\r\n    const onDemandDb = konro.createDatabase({ schema: testSchema, adapter: onDemandAdapter });\r\n\r\n    // Test 7: On-demand query should not require state.\r\n    onDemandDb.query().from('users').where({ name: 'Alice' }).first(); // Should be valid\r\n\r\n    // Test 8: On-demand query with .with() should be typed correctly without state.\r\n    onDemandDb.query().from('users').with({\r\n      posts: {\r\n        where: (post) => post.title.startsWith('A')\r\n      }\r\n    }).first();\r\n\r\n    // @ts-expect-error - 'nonExistentRelation' is not a valid relation on 'users'\r\n    onDemandDb.query().from('users').with({ nonExistentRelation: true });\r\n\r\n    // Test 9: On-demand insert should be awaitable and return the correct type.\r\n    const insertedUserPromise = onDemandDb.insert('users', { name: 'OnDemand', email: 'od@test.com', age: 22 });\r\n    // @ts-expect-error - 'posts' should not exist on the base inserted type\r\n    insertedUserPromise.then(u => u.posts);\r\n  });\r\n});\r\n"
  test/unit/Core/Aggregate.test.ts: "import { describe, it, expect, beforeEach } from 'bun:test';\r\nimport { testSchema } from '../../util';\r\nimport { _aggregateImpl } from '../../../src/operations';\r\nimport { DatabaseState } from '../../../src/types';\r\nimport { konro } from '../../../src/index';\r\n\r\ndescribe('Unit > Core > Aggregate', () => {\r\n  let testState: DatabaseState;\r\n\r\n  beforeEach(() => {\r\n    testState = {\r\n      users: {\r\n        records: [\r\n          { id: 1, name: 'Alice', age: 30, isActive: true },\r\n          { id: 2, name: 'Bob', age: 25, isActive: true },\r\n          { id: 3, name: 'Charlie', age: 42, isActive: false },\r\n          { id: 4, name: 'Denise', age: 30, isActive: true },\r\n          { id: 5, name: 'Edward', age: null, isActive: true }, // age can be null\r\n        ],\r\n        meta: { lastId: 5 },\r\n      },\r\n      posts: { records: [], meta: { lastId: 0 } },\r\n      profiles: { records: [], meta: { lastId: 0 } },\r\n      tags: { records: [], meta: { lastId: 0 } },\r\n      posts_tags: { records: [], meta: { lastId: 0 } },\r\n    };\r\n  });\r\n\r\n  it('should correctly count all records in a table', () => {\r\n    const result = _aggregateImpl(testState, testSchema, {\r\n      tableName: 'users',\r\n      aggregations: { total: konro.count() }\r\n    });\r\n    expect(result.total).toBe(5);\r\n  });\r\n\r\n  it('should correctly count records matching a where clause', () => {\r\n    const result = _aggregateImpl(testState, testSchema, {\r\n      tableName: 'users',\r\n      where: (r) => r.isActive === true,\r\n      aggregations: { activeUsers: konro.count() }\r\n    });\r\n    expect(result.activeUsers).toBe(4);\r\n  });\r\n\r\n  it('should correctly sum a numeric column', () => {\r\n    const result = _aggregateImpl(testState, testSchema, {\r\n      tableName: 'users',\r\n      aggregations: { totalAge: konro.sum('age') }\r\n    });\r\n    // 30 + 25 + 42 + 30 = 127\r\n    expect(result.totalAge).toBe(127);\r\n  });\r\n\r\n  it('should correctly calculate the average of a numeric column', () => {\r\n    const result = _aggregateImpl(testState, testSchema, {\r\n      tableName: 'users',\r\n      aggregations: { averageAge: konro.avg('age') }\r\n    });\r\n    // 127 / 4 = 31.75\r\n    expect(result.averageAge).toBe(31.75);\r\n  });\r\n\r\n  it('should find the minimum value in a numeric column', () => {\r\n    const result = _aggregateImpl(testState, testSchema, {\r\n      tableName: 'users',\r\n      aggregations: { minAge: konro.min('age') }\r\n    });\r\n    expect(result.minAge).toBe(25);\r\n  });\r\n\r\n  it('should find the maximum value in a numeric column', () => {\r\n    const result = _aggregateImpl(testState, testSchema, {\r\n      tableName: 'users',\r\n      aggregations: { maxAge: konro.max('age') }\r\n    });\r\n    expect(result.maxAge).toBe(42);\r\n  });\r\n\r\n  it('should handle multiple aggregations in one call', () => {\r\n    const result = _aggregateImpl(testState, testSchema, {\r\n      tableName: 'users',\r\n      where: (r) => r.isActive === true,\r\n      aggregations: {\r\n        count: konro.count(),\r\n        avgAge: konro.avg('age'), // Alice(30), Bob(25), Denise(30) -> 85 / 3\r\n      }\r\n    });\r\n    expect(result.count).toBe(4); // Includes Edward with null age\r\n    expect(result.avgAge).toBeCloseTo(85 / 3);\r\n  });\r\n\r\n  it('should return 0 for count on an empty/filtered-out set', () => {\r\n    const result = _aggregateImpl(testState, testSchema, {\r\n      tableName: 'users',\r\n      where: (r) => (r.age as number) > 100,\r\n      aggregations: { count: konro.count() }\r\n    });\r\n    expect(result.count).toBe(0);\r\n  });\r\n\r\n  it('should return 0 for sum on an empty set', () => {\r\n    const result = _aggregateImpl(testState, testSchema, {\r\n      tableName: 'users',\r\n      where: (r) => (r.age as number) > 100,\r\n      aggregations: { sumAge: konro.sum('age') }\r\n    });\r\n    expect(result.sumAge).toBe(0);\r\n  });\r\n\r\n  it('should return null for avg, min, and max on an empty set', () => {\r\n    const result = _aggregateImpl(testState, testSchema, {\r\n      tableName: 'users',\r\n      where: (r) => (r.age as number) > 100,\r\n      aggregations: {\r\n        avgAge: konro.avg('age'),\r\n        minAge: konro.min('age'),\r\n        maxAge: konro.max('age'),\r\n      }\r\n    });\r\n    expect(result.avgAge).toBeNull();\r\n    expect(result.minAge).toBeNull();\r\n    expect(result.maxAge).toBeNull();\r\n  });\r\n\r\n  it('should ignore non-numeric and null values in calculations', () => {\r\n    const result = _aggregateImpl(testState, testSchema, {\r\n      tableName: 'users',\r\n      aggregations: {\r\n        count: konro.count(),\r\n        sum: konro.sum('age'),\r\n        avg: konro.avg('age'),\r\n        min: konro.min('age'),\r\n        max: konro.max('age'),\r\n      }\r\n    });\r\n    // There are 5 users, but only 4 have numeric ages.\r\n    // The implementation of avg/sum/min/max filters for numbers.\r\n    // The count is for all records matching where.\r\n    expect(result.count).toBe(5);\r\n    expect(result.sum).toBe(127);\r\n    expect(result.avg).toBe(31.75);\r\n    expect(result.min).toBe(25);\r\n    expect(result.max).toBe(42);\r\n  });\r\n});\r\n"
  test/unit/Core/Delete.test.ts: "import { describe, it, expect, beforeEach } from 'bun:test';\r\nimport { _deleteImpl } from '../../../src/operations';\r\nimport { DatabaseState, KRecord } from '../../../src/types';\r\nimport { konro } from '../../../src/index';\r\n\r\ndescribe('Unit > Core > Delete', () => {\r\n    let testState: DatabaseState;\r\n\r\n    const hardDeleteSchema = konro.createSchema({\r\n        tables: {\r\n            users: {\r\n                id: konro.id(),\r\n                name: konro.string(),\r\n                email: konro.string(),\r\n                age: konro.number(),\r\n            },\r\n            posts: {\r\n                id: konro.id(),\r\n                title: konro.string(),\r\n                userId: konro.number()\r\n            },\r\n            profiles: { id: konro.id(), bio: konro.string(), userId: konro.number() },\r\n            tags: { id: konro.id(), name: konro.string() },\r\n            posts_tags: { id: konro.id(), postId: konro.number(), tagId: konro.number() },\r\n        },\r\n        relations: () => ({\r\n            users: {\r\n                posts: konro.many('posts', { on: 'id', references: 'userId', onDelete: 'CASCADE' })\r\n            }\r\n        })\r\n    });\r\n    \r\n    const softDeleteSchema = konro.createSchema({\r\n        tables: {\r\n            users: {\r\n                id: konro.id(),\r\n                name: konro.string(),\r\n                email: konro.string(),\r\n                age: konro.number(),\r\n                deletedAt: konro.deletedAt()\r\n            },\r\n            posts: {\r\n                id: konro.id(),\r\n                title: konro.string(),\r\n                userId: konro.number()\r\n            },\r\n            profiles: { id: konro.id(), bio: konro.string(), userId: konro.number() },\r\n            tags: { id: konro.id(), name: konro.string() },\r\n            posts_tags: { id: konro.id(), postId: konro.number(), tagId: konro.number() },\r\n        },\r\n        relations: () => ({\r\n            users: {\r\n                posts: konro.many('posts', { on: 'id', references: 'userId', onDelete: 'CASCADE' })\r\n            }\r\n        })\r\n    });\r\n\r\n    beforeEach(() => {\r\n        testState = {\r\n            users: {\r\n                records: [\r\n                    { id: 1, name: 'Alice', email: 'a@a.com', age: 30, deletedAt: null },\r\n                    { id: 2, name: 'Bob', email: 'b@b.com', age: 25, deletedAt: null },\r\n                    { id: 3, name: 'Charlie', email: 'c@c.com', age: 42, deletedAt: null },\r\n                ],\r\n                meta: { lastId: 3 },\r\n            },\r\n            posts: { \r\n                records: [\r\n                    { id: 101, title: 'Post A', userId: 1 },\r\n                    { id: 102, title: 'Post B', userId: 2 },\r\n                    { id: 103, title: 'Post C', userId: 1 },\r\n                ], \r\n                meta: { lastId: 103 } \r\n            },\r\n            profiles: { records: [], meta: { lastId: 0 } },\r\n            tags: { records: [], meta: { lastId: 0 } },\r\n            posts_tags: { records: [], meta: { lastId: 0 } },\r\n        };\r\n    });\r\n\r\n    it('should return a new state object, not mutate the original state, on hard delete', () => {\r\n        const originalState = structuredClone(testState);\r\n        const [newState] = _deleteImpl(testState, hardDeleteSchema, 'users', (r) => r.id === 1);\r\n        \r\n        expect(newState).not.toBe(originalState);\r\n        expect(originalState.users!.records.length).toBe(3);\r\n        expect(newState.users!.records.length).toBe(2);\r\n    });\r\n\r\n    it('should only hard delete records that match the predicate function', () => {\r\n        const [newState, deleted] = _deleteImpl(testState, hardDeleteSchema, 'users', (r) => typeof r.age === 'number' && r.age > 35);\r\n        \r\n        expect(deleted.length).toBe(1);\r\n        expect(deleted[0]!.id).toBe(3);\r\n        expect(newState.users!.records.length).toBe(2);\r\n        expect(newState.users!.records.find(u => u.id === 3)).toBeUndefined();\r\n    });\r\n\r\n    it('should return both the new state and an array of the full, hard-deleted records in the result tuple', () => {\r\n        const [newState, deleted] = _deleteImpl(testState, hardDeleteSchema, 'users', (r) => r.id === 2);\r\n\r\n        expect(newState).toBeDefined();\r\n        expect(deleted).toBeInstanceOf(Array);\r\n        expect(deleted.length).toBe(1);\r\n        expect(deleted[0]!).toEqual({ id: 2, name: 'Bob', email: 'b@b.com', age: 25, deletedAt: null });\r\n    });\r\n\r\n    it('should not modify the table meta lastId on delete', () => {\r\n        const [newState] = _deleteImpl(testState, hardDeleteSchema, 'users', (r) => r.id === 3);\r\n        expect(newState.users!.meta.lastId).toBe(3);\r\n    });\r\n\r\n    it('should soft delete a record by setting deletedAt if the column exists in schema', () => {\r\n        const [newState, deleted] = _deleteImpl(testState, softDeleteSchema, 'users', (r) => r.id === 2);\r\n\r\n        expect(newState.users!.records.length).toBe(3); // Record is not removed\r\n        const deletedUser = newState.users!.records.find(u => u.id === 2);\r\n        expect(deletedUser?.deletedAt).toBeInstanceOf(Date);\r\n        \r\n        expect(deleted.length).toBe(1);\r\n        expect(deleted[0]!.id).toBe(2);\r\n        expect(deleted[0]!.deletedAt).toEqual(deletedUser?.deletedAt);\r\n    });\r\n\r\n    it('should not soft delete an already soft-deleted record', () => {\r\n        (testState.users!.records[1] as KRecord).deletedAt = new Date('2024-01-01');\r\n        const [newState, deleted] = _deleteImpl(testState, softDeleteSchema, 'users', (r) => r.id === 2);\r\n\r\n        expect(newState).toBe(testState); // Should return original state as nothing changed\r\n        expect(deleted.length).toBe(0);\r\n        expect((newState.users!.records[1] as KRecord).deletedAt).toEqual(new Date('2024-01-01'));\r\n    });\r\n\r\n    it('should perform a cascading delete on related records', () => {\r\n        const [newState, deletedUsers] = _deleteImpl(testState, softDeleteSchema, 'users', (r) => r.id === 1);\r\n        \r\n        expect(deletedUsers.length).toBe(1);\r\n        expect(newState.users!.records.find(u => u.id === 1)?.deletedAt).toBeInstanceOf(Date);\r\n        \r\n        // Check that posts by user 1 are also gone (hard delete, as posts have no deletedAt)\r\n        const postsForUser1 = newState.posts!.records.filter(p => p.userId === 1);\r\n        expect(postsForUser1.length).toBe(0);\r\n\r\n        // Check that other posts are unaffected\r\n        expect(newState.posts!.records.length).toBe(1);\r\n        expect(newState.posts!.records[0]!.id).toBe(102);\r\n    });\r\n});"
  test/unit/Schema/ColumnHelpers.test.ts: "import { describe, it, expect } from 'bun:test';\r\nimport { konro } from '../../../src/index';\r\n\r\ndescribe('Unit > Schema > ColumnHelpers', () => {\r\n  it('should create a valid ID column definition object when calling konro.id()', () => {\r\n    const idCol = konro.id();\r\n    expect(idCol).toEqual({\r\n      _type: 'column',\r\n      dataType: 'id',\r\n      options: { unique: true, _pk_strategy: 'auto-increment' },\r\n      _tsType: 0,\r\n    });\r\n  });\r\n\r\n  it('should create a valid UUID column definition object when calling konro.uuid()', () => {\r\n    const uuidCol = konro.uuid();\r\n    expect(uuidCol).toEqual({\r\n      _type: 'column',\r\n      dataType: 'id',\r\n      options: { unique: true, _pk_strategy: 'uuid' },\r\n      _tsType: '',\r\n    });\r\n  });\r\n\r\n  it('should create a valid string column definition with no options', () => {\r\n    const stringCol = konro.string();\r\n    expect(stringCol).toEqual({\r\n      _type: 'column',\r\n      dataType: 'string',\r\n      options: undefined,\r\n      _tsType: '',\r\n    });\r\n  });\r\n\r\n  it('should create a valid string column definition with all specified options', () => {\r\n    const defaultFn = () => 'default';\r\n    const stringCol = konro.string({\r\n      unique: true,\r\n      default: defaultFn,\r\n      min: 5,\r\n      max: 100,\r\n      format: 'email',\r\n    });\r\n    expect(stringCol).toEqual({\r\n      _type: 'column',\r\n      dataType: 'string',\r\n      options: {\r\n        unique: true,\r\n        default: defaultFn,\r\n        min: 5,\r\n        max: 100,\r\n        format: 'email',\r\n      },\r\n      _tsType: '',\r\n    });\r\n  });\r\n\r\n  it('should create a valid number column definition with no options', () => {\r\n    const numberCol = konro.number();\r\n    expect(numberCol).toEqual({\r\n      _type: 'column',\r\n      dataType: 'number',\r\n      options: undefined,\r\n      _tsType: 0,\r\n    });\r\n  });\r\n\r\n  it('should create a valid number column definition with all specified options', () => {\r\n    const numberCol = konro.number({\r\n      unique: false,\r\n      default: 0,\r\n      min: 0,\r\n      max: 1000,\r\n      type: 'integer',\r\n    });\r\n    expect(numberCol).toEqual({\r\n      _type: 'column',\r\n      dataType: 'number',\r\n      options: {\r\n        unique: false,\r\n        default: 0,\r\n        min: 0,\r\n        max: 1000,\r\n        type: 'integer',\r\n      },\r\n      _tsType: 0,\r\n    });\r\n  });\r\n\r\n  it('should create a valid boolean column with no options', () => {\r\n    const boolCol = konro.boolean();\r\n    expect(boolCol).toEqual({\r\n      _type: 'column',\r\n      dataType: 'boolean',\r\n      options: undefined,\r\n      _tsType: false,\r\n    });\r\n  });\r\n\r\n  it('should create a valid boolean column definition with a default value', () => {\r\n    const boolCol = konro.boolean({ default: false });\r\n    expect(boolCol).toEqual({\r\n      _type: 'column',\r\n      dataType: 'boolean',\r\n      options: { default: false },\r\n      _tsType: false,\r\n    });\r\n  });\r\n\r\n  it('should create a valid date column definition with no options', () => {\r\n    const dateCol = konro.date();\r\n    expect(dateCol).toEqual({\r\n      _type: 'column',\r\n      dataType: 'date',\r\n      options: undefined,\r\n      _tsType: expect.any(Date),\r\n    });\r\n  });\r\n\r\n  it('should create a valid date column definition with a default function', () => {\r\n    const defaultDateFn = () => new Date();\r\n    const dateCol = konro.date({ default: defaultDateFn });\r\n    expect(dateCol).toEqual({\r\n      _type: 'column',\r\n      dataType: 'date',\r\n      options: { default: defaultDateFn },\r\n      _tsType: expect.any(Date),\r\n    });\r\n    expect(dateCol.options?.default).toBe(defaultDateFn);\r\n  });\r\n\r\n  it('should create a valid string column with a literal default', () => {\r\n    const stringCol = konro.string({ default: 'hello' });\r\n    expect(stringCol).toEqual({\r\n      _type: 'column',\r\n      dataType: 'string',\r\n      options: { default: 'hello' },\r\n      _tsType: '',\r\n    });\r\n  });\r\n\r\n  it('should create a valid number column with a function default', () => {\r\n    const defaultFn = () => 42;\r\n    const numberCol = konro.number({ default: defaultFn });\r\n    expect(numberCol).toEqual({\r\n      _type: 'column',\r\n      dataType: 'number',\r\n      options: {\r\n        default: defaultFn,\r\n      },\r\n      _tsType: 0,\r\n    });\r\n    expect(numberCol.options?.default).toBe(defaultFn);\r\n  });\r\n\r\n  it('should create a valid boolean column with a function default', () => {\r\n    const defaultFn = () => true;\r\n    const boolCol = konro.boolean({ default: defaultFn });\r\n    expect(boolCol).toEqual({\r\n      _type: 'column',\r\n      dataType: 'boolean',\r\n      options: {\r\n        default: defaultFn,\r\n      },\r\n      _tsType: false,\r\n    });\r\n    expect(boolCol.options?.default).toBe(defaultFn);\r\n  });\r\n\r\n  it('should create a valid object column definition', () => {\r\n    const objCol = konro.object<{ meta: string }>();\r\n    expect(objCol).toMatchObject({\r\n      _type: 'column',\r\n      dataType: 'object',\r\n      options: undefined,\r\n    });\r\n  });\r\n});"
  test/unit/Schema/CreateSchema.test.ts: "import { describe, it, expect } from 'bun:test';\r\nimport { konro } from '../../../src/index';\r\n\r\ndescribe('Unit > Schema > CreateSchema', () => {\r\n  it('should correctly assemble a full schema object from tables and relations definitions', () => {\r\n    const tableDefs = {\r\n      users: {\r\n        id: konro.id(),\r\n        name: konro.string(),\r\n      },\r\n      posts: {\r\n        id: konro.id(),\r\n        title: konro.string(),\r\n        authorId: konro.number(),\r\n      },\r\n    };\r\n\r\n    const schema = konro.createSchema({\r\n      tables: tableDefs,\r\n      relations: () => ({\r\n        users: {\r\n          posts: konro.many('posts', { on: 'id', references: 'authorId' }),\r\n        },\r\n        posts: {\r\n          author: konro.one('users', { on: 'authorId', references: 'id' }),\r\n        },\r\n      }),\r\n    });\r\n\r\n    expect(schema.tables).toBe(tableDefs);\r\n    expect(schema.relations).toBeDefined();\r\n    expect(schema.relations.users.posts).toBeDefined();\r\n    expect(schema.relations.posts.author).toBeDefined();\r\n    expect(schema.types).toBeNull(); // Runtime placeholder\r\n  });\r\n\r\n  it('should handle schemas with no relations defined', () => {\r\n    const tableDefs = {\r\n      logs: {\r\n        id: konro.id(),\r\n        message: konro.string(),\r\n      },\r\n    };\r\n\r\n    const schema = konro.createSchema({\r\n      tables: tableDefs,\r\n    });\r\n\r\n    expect(schema.tables).toBe(tableDefs);\r\n    expect(schema.relations).toEqual({});\r\n  });\r\n\r\n  it('should handle schemas where relations function returns an empty object', () => {\r\n    const tableDefs = {\r\n      users: {\r\n        id: konro.id(),\r\n        name: konro.string(),\r\n      },\r\n    };\r\n\r\n    const schema = konro.createSchema({\r\n      tables: tableDefs,\r\n      relations: () => ({}),\r\n    });\r\n\r\n    expect(schema.tables).toBe(tableDefs);\r\n    expect(schema.relations).toEqual({});\r\n  });\r\n\r\n  it('should handle schemas with multiple relations on one table', () => {\r\n    const tableDefs = {\r\n      users: { id: konro.id(), name: konro.string() },\r\n      posts: { id: konro.id(), title: konro.string(), authorId: konro.number(), editorId: konro.number() },\r\n    };\r\n\r\n    const schema = konro.createSchema({\r\n      tables: tableDefs,\r\n      relations: () => ({\r\n        posts: {\r\n          author: konro.one('users', { on: 'authorId', references: 'id' }),\r\n          editor: konro.one('users', { on: 'editorId', references: 'id' }),\r\n        },\r\n      }),\r\n    });\r\n\r\n    expect(schema.relations.posts.author).toBeDefined();\r\n    expect(schema.relations.posts.editor).toBeDefined();\r\n    expect(schema.relations.posts.author.targetTable).toBe('users');\r\n    expect(schema.relations.posts.editor.targetTable).toBe('users');\r\n  });\r\n});"
  test/unit/Schema/RelationHelpers.test.ts: "import { describe, it, expect } from 'bun:test';\r\nimport { konro } from '../../../src/index';\r\n\r\ndescribe('Unit > Schema > RelationHelpers', () => {\r\n  it('should create a valid one-to-many relationship definition object when calling konro.many()', () => {\r\n    const manyRel = konro.many('posts', { on: 'id', references: 'authorId' });\r\n    expect(manyRel).toEqual({\r\n      _type: 'relation',\r\n      relationType: 'many',\r\n      targetTable: 'posts',\r\n      on: 'id',\r\n      references: 'authorId',\r\n    });\r\n  });\r\n\r\n  it('should create a valid one-to-one/many-to-one relationship definition object when calling konro.one()', () => {\r\n    const oneRel = konro.one('users', { on: 'authorId', references: 'id' });\r\n    expect(oneRel).toEqual({\r\n      _type: 'relation',\r\n      relationType: 'one',\r\n      targetTable: 'users',\r\n      on: 'authorId',\r\n      references: 'id',\r\n    });\r\n  });\r\n});"
  package.json: |
    {
      "name": "konro",
      "version": "0.1.5",
      "description": "A type-safe, functional micro-ORM for JSON/YAML files.",
      "type": "module",
      "main": "./dist/index.js",
      "module": "./dist/index.mjs",
      "types": "./dist/index.d.ts",
      "exports": {
        ".": {
          "types": "./dist/index.d.ts",
          "import": "./dist/index.mjs",
          "require": "./dist/index.js"
        }
      },
      "files": [
        "dist"
      ],
      "repository": {
        "type": "git",
        "url": "git+https://github.com/relaycoder/konro.git"
      },
      "keywords": [
        "orm",
        "json",
        "yaml",
        "csv",
        "xlsx",
        "database",
        "typescript",
        "local-first",
        "immutable",
        "functional"
      ],
      "author": "relaycoder",
      "license": "MIT",
      "devDependencies": {
        "@types/bun": "latest",
        "@types/js-yaml": "^4.0.9",
        "@types/papaparse": "^5.3.14",
        "@typescript-eslint/eslint-plugin": "^8.36.0",
        "@typescript-eslint/parser": "^8.36.0",
        "eslint": "^9.30.1",
        "js-yaml": "^4.1.0",
        "papaparse": "^5.4.1",
        "tsup": "^8.5.0",
        "typescript": "^5.5.4",
        "xlsx": "^0.18.5"
      },
      "peerDependencies": {
        "js-yaml": "^4.1.0",
        "papaparse": "^5.4.1",
        "typescript": "^5.0.0",
        "xlsx": "^0.18.5"
      },
      "peerDependenciesMeta": {
        "js-yaml": {
          "optional": true
        },
        "papaparse": {
          "optional": true
        },
        "xlsx": {
          "optional": true
        }
      },
      "scripts": {
        "lint": "eslint .",
        "build": "tsup",
        "dev": "tsup --watch",
        "prepublishOnly": "npm run build"
      }
    }
approved: true

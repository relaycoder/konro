uuid: ddc43615-568d-4767-8e6f-99abeb7a5b3a
projectId: konro
createdAt: '2025-07-09T07:45:12.042Z'
linesAdded: 39
linesRemoved: 37
gitCommitMsg: 'fix(ts): resolve compilation errors from type refactoring'
promptSummary: Fix 40 TypeScript errors caused by the previous refactoring.
reasoning:
  - >-
    I've identified and addressed the 40 TypeScript errors. The root causes were
    a combination of missing `export` keywords for shared types, missing
    imports, unused imports after refactoring, and implicitly `any` typed
    parameters in function implementations.
  - 'Here is my step-by-step plan to fix these issues:'
  - >-
    1.  **Export Interfaces from `types.ts`**: I will add the `export` keyword
    to all the builder (`ChainedQueryBuilder`, `UpdateBuilder`, etc.) and
    context (`InMemoryDbContext`, etc.) interfaces in `src/types.ts`. This makes
    them available for import in other modules.
  - >-
    2.  **Fix `adapter.ts` Imports**: The file `src/adapter.ts` uses
    strategy-specific types (`SingleFileStrategy`, etc.) that were moved to
    `types.ts`. I will add the necessary imports.
  - >-
    3.  **Clean Up Unused Imports**: I will remove the now-unused imports from
    `src/operations.ts` and `src/schema.ts` to resolve the "declared but never
    used" errors.
  - >-
    4.  **Refactor `db.ts`**: This file has the most issues. I will perform the
    following changes:
  - >-
    *   Move the `normalizePredicate` helper function to the module's top-level
    scope so it can be used by all database context creators.
  - >-
    *   Re-export the main `DbContext` types so that test files can continue to
    import them from `src/db.ts` as they did before.
  - >-
    *   Add explicit type annotations to all builder method parameters
    (`select`, `where`, `set`, `limit`, etc.) to fix the "implicitly has an
    'any' type" errors. This also improves code clarity and robustness.
  - '*   Remove unused type imports.'
  - >-
    These changes will resolve all compilation errors and improve the overall
    structure and type safety of the codebase.
  - '### `src/types.ts`'
  - >-
    I'll start by exporting all the necessary builder and context interfaces to
    make them accessible across the project.
  - '### `src/adapter.ts`'
  - Next, I'll fix the missing imports for the file strategy types.
  - '### `src/operations.ts`'
  - Here, I'll remove the unused imports.
  - '### `src/schema.ts`'
  - Similarly, I'll clean up the imports in the schema definition file.
  - '### `src/db.ts`'
  - >-
    Finally, I'll apply the significant refactoring to `db.ts` to resolve the
    remaining errors related to scoping, missing exports, and implicit `any`
    types.
operations:
  - type: write
    path: src/types.ts
    content: >-
      <<<<<<< SEARCH

      interface ChainedQueryBuilder<S extends KonroSchema<any, any>, TName
      extends keyof S['tables'], TReturn> {

      =======

      export interface ChainedQueryBuilder<S extends KonroSchema<any, any>,
      TName extends keyof S['tables'], TReturn> {

      >>>>>>> REPLACE

      <<<<<<< SEARCH

      interface QueryBuilder<S extends KonroSchema<any, any>> {

      =======

      export interface QueryBuilder<S extends KonroSchema<any, any>> {

      >>>>>>> REPLACE

      <<<<<<< SEARCH

      interface UpdateBuilder<S extends KonroSchema<any, any>, TBase, TCreate> {

      =======

      export interface UpdateBuilder<S extends KonroSchema<any, any>, TBase,
      TCreate> {

      >>>>>>> REPLACE

      <<<<<<< SEARCH

      interface DeleteBuilder<S extends KonroSchema<any, any>, TBase> {

      =======

      export interface DeleteBuilder<S extends KonroSchema<any, any>, TBase> {

      >>>>>>> REPLACE

      <<<<<<< SEARCH

      interface OnDemandChainedQueryBuilder<S extends KonroSchema<any, any>,
      TName extends keyof S['tables'], TReturn> {

      =======

      export interface OnDemandChainedQueryBuilder<S extends KonroSchema<any,
      any>, TName extends keyof S['tables'], TReturn> {

      >>>>>>> REPLACE

      <<<<<<< SEARCH

      interface OnDemandQueryBuilder<S extends KonroSchema<any, any>> {

      =======

      export interface OnDemandQueryBuilder<S extends KonroSchema<any, any>> {

      >>>>>>> REPLACE

      <<<<<<< SEARCH

      interface OnDemandUpdateBuilder<TBase, TCreate> {

      =======

      export interface OnDemandUpdateBuilder<TBase, TCreate> {

      >>>>>>> REPLACE

      <<<<<<< SEARCH

      interface OnDemandDeleteBuilder<TBase> {

      =======

      export interface OnDemandDeleteBuilder<TBase> {

      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/adapter.ts
    content: |-
      --- src/adapter.ts
      +++ src/adapter.ts
      @@ -8,6 +8,9 @@
         FileStorageAdapter,
         FileAdapterOptions,
         ColumnDefinition,
      +  SingleFileStrategy,
      +  MultiFileStrategy,
      +  PerRecordStrategy,
         KonroSchema,
         Serializer,
         FsProvider,
    patchStrategy: new-unified
  - type: write
    path: src/operations.ts
    content: |-
      --- src/operations.ts
      +++ src/operations.ts
      @@ -4,8 +4,6 @@
         KRecord,
         KonroSchema,
         RelationDefinition,
      -  ColumnDefinition,
      -  AggregationDefinition,
         WithClause,
         QueryDescriptor,
         AggregationDescriptor,
    patchStrategy: new-unified
  - type: write
    path: src/schema.ts
    content: |-
      --- src/schema.ts
      +++ src/schema.ts
      @@ -9,7 +9,6 @@
       import type {
         KonroSchema,
         ColumnDefinition,
      -  BaseRelationDefinition,
         OneRelationDefinition,
         ManyRelationDefinition,
         AggregationDefinition
    patchStrategy: new-unified
  - type: write
    path: src/db.ts
    content: >-
      --- src/db.ts

      +++ src/db.ts

      @@ -1,10 +1,7 @@
       import path from 'path';
       import type {
         AggregationDefinition,
      -  ColumnDefinition,
         KonroSchema,
      -  RelationDefinition,
         StorageAdapter,
         FileStorageAdapter,
         DatabaseState,
      @@ -35,30 +32,29 @@
       import { createPredicateFromPartial } from './utils/predicate.util';
       import { KonroError, KonroStorageError } from './utils/error.util';
       import { writeAtomic } from './fs';
      +

      +export type { InMemoryDbContext, OnDemandDbContext, DbContext };
       
       // --- CORE LOGIC (STATELESS & PURE) ---
       
       /**
      - * Creates the core, stateless database operations.

      - * These operations are pure functions that take a database state and
      return a new state,

      - * forming the foundation for both in-memory and on-demand modes.

      + * A helper to normalize a predicate argument into a function.
        */
      -function createCoreDbContext<S extends KonroSchema<any, any>>(schema: S)
      {

      -  // A helper to normalize a predicate argument

      -  const normalizePredicate = <T extends KRecord>(

      -    predicate: Partial<T> | ((record: T) => boolean)

      -  ): ((record: KRecord) => boolean) =>

      -    // The cast is necessary due to function argument contravariance.

      -    // The internal operations work on the wider `KRecord`, while the
      fluent API provides the specific `T`.

      -    (typeof predicate === 'function' ? predicate :
      createPredicateFromPartial(predicate)) as (record: KRecord) => boolean;

      +const normalizePredicate = <T extends KRecord>(

      +  predicate: Partial<T> | ((record: T) => boolean)

      +): ((record: KRecord) => boolean) =>

      +  // The cast is necessary due to function argument contravariance.

      +  // The internal operations work on the wider `KRecord`, while the
      fluent API provides the specific `T`.

      +  (typeof predicate === 'function' ? predicate :
      createPredicateFromPartial(predicate)) as (record: KRecord) => boolean;
       
      +/**

      + * Creates the core, stateless database operations.

      + * These operations are pure functions that take a database state and
      return a new state,

      + * forming the foundation for both in-memory and on-demand modes.

      + */

      +function createCoreDbContext<S extends KonroSchema<any, any>>(schema: S)
      {
         const query = (state: DatabaseState<S>): QueryBuilder<S> => ({
           from: <TName extends keyof S['tables']>(tableName: TName): ChainedQueryBuilder<S, TName, S['base'][TName]> => {
             const createBuilder = <TReturn>(currentDescriptor: QueryDescriptor): ChainedQueryBuilder<S, TName, TReturn> => ({
      -        select(fields) { return createBuilder<TReturn>({
      ...currentDescriptor, select: fields }); },

      -        where(predicate) { return createBuilder<TReturn>({
      ...currentDescriptor, where: normalizePredicate(predicate as
      Parameters<typeof normalizePredicate>[0]) }); },

      +        select(fields) { return createBuilder<TReturn>({
      ...currentDescriptor, select: fields as QueryDescriptor['select'] }); },

      +        where(predicate) { return createBuilder<TReturn>({
      ...currentDescriptor, where: normalizePredicate(predicate) }); },
               withDeleted() { return createBuilder<TReturn>({ ...currentDescriptor, withDeleted: true }); },
               with<W extends WithArgument<S['types'][TName]>>(relations: W) {
                 const newWith = { ...currentDescriptor.with, ...(relations as QueryDescriptor['with']) };
                 return createBuilder<TReturn & ResolveWith<S, TName, W>>({ ...currentDescriptor, with: newWith });
               },
      -        limit(count) { return createBuilder<TReturn>({
      ...currentDescriptor, limit: count }); },

      -        offset(count) { return createBuilder<TReturn>({
      ...currentDescriptor, offset: count }); },

      +        limit(count: number) { return createBuilder<TReturn>({
      ...currentDescriptor, limit: count }); },

      +        offset(count: number) { return createBuilder<TReturn>({
      ...currentDescriptor, offset: count }); },
               all: (): TReturn[] => _queryImpl(state as DatabaseState, schema, currentDescriptor) as TReturn[],
               first: (): TReturn | null => (_queryImpl(state as DatabaseState, schema, { ...currentDescriptor, limit: 1 })[0] ?? null) as TReturn | null,
               aggregate: <TAggs extends Record<string, AggregationDefinition>>(aggregations: TAggs) => {
      @@ -77,16 +73,16 @@
       
         const update = <T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T): UpdateBuilder<S, S['base'][T], S['create'][T]> => ({
      -    set: (data) => ({

      -      where: (predicate) => {

      -        const [newState, updatedRecords] = _updateImpl(state as
      DatabaseState, schema, tableName as string, data as Partial<KRecord>,
      normalizePredicate(predicate as Parameters<typeof
      normalizePredicate>[0]));

      +    set: (data: Partial<S['create'][T]>) => ({

      +      where: (predicate: Partial<S['base'][T]> | ((record: S['base'][T])
      => boolean)): [DatabaseState<S>, S['base'][T][]] => {

      +        const [newState, updatedRecords] = _updateImpl(state as
      DatabaseState, schema, tableName as string, data as Partial<KRecord>,
      normalizePredicate(predicate));
               return [newState as DatabaseState<S>, updatedRecords as S['base'][T][]];
             },
           }),
         });
       
         const del = <T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T): DeleteBuilder<S, S['base'][T]> => ({
      -    where: (predicate) => {

      -      const [newState, deletedRecords] = _deleteImpl(state as
      DatabaseState, schema, tableName as string, normalizePredicate(predicate
      as Parameters<typeof normalizePredicate>[0]));

      +    where: (predicate: Partial<S['base'][T]> | ((record: S['base'][T]) =>
      boolean)): [DatabaseState<S>, S['base'][T][]] => {

      +      const [newState, deletedRecords] = _deleteImpl(state as
      DatabaseState, schema, tableName as string,
      normalizePredicate(predicate));
             return [newState as DatabaseState<S>, deletedRecords as S['base'][T][]];
           },
         });
      @@ -115,16 +111,16 @@
         const query = (): OnDemandQueryBuilder<S> => ({
           from: <TName extends keyof S['tables']>(tableName: TName): OnDemandChainedQueryBuilder<S, TName, S['base'][TName]> => {
             const createBuilder = <TReturn>(currentDescriptor: QueryDescriptor): OnDemandChainedQueryBuilder<S, TName, TReturn> => ({
      -        select(fields) { return createBuilder<TReturn>({
      ...currentDescriptor, select: fields }); },

      -        where(predicate) { return createBuilder<TReturn>({
      ...currentDescriptor, where: normalizePredicate(predicate as
      Parameters<typeof normalizePredicate>[0]) }); },

      +        select(fields) { return createBuilder<TReturn>({
      ...currentDescriptor, select: fields as QueryDescriptor['select'] }); },

      +        where(predicate) { return createBuilder<TReturn>({
      ...currentDescriptor, where: normalizePredicate(predicate) }); },
               withDeleted() { return createBuilder<TReturn>({ ...currentDescriptor, withDeleted: true }); },
               with<W extends WithArgument<S['types'][TName]>>(relations: W) {
                 const newWith = { ...currentDescriptor.with, ...(relations as QueryDescriptor['with']) };
                 return createBuilder<TReturn & ResolveWith<S, TName, W>>({ ...currentDescriptor, with: newWith });
               },
      -        limit(count) { return createBuilder<TReturn>({
      ...currentDescriptor, limit: count }); },

      -        offset(count) { return createBuilder<TReturn>({
      ...currentDescriptor, offset: count }); },

      +        limit(count: number) { return createBuilder<TReturn>({
      ...currentDescriptor, limit: count }); },

      +        offset(count: number) { return createBuilder<TReturn>({
      ...currentDescriptor, offset: count }); },
               all: async (): Promise<TReturn[]> => {
                 const state = await io.getFullState();
                 return _queryImpl(state, schema, currentDescriptor) as TReturn[];
      @@ -146,12 +142,12 @@
       
         const update = <T extends keyof S['tables']>(tableName: T): OnDemandUpdateBuilder<S['base'][T], S['create'][T]> => ({
      -    set: (data) => ({

      -      where: (predicate) => io.update(core, tableName as string, data,
      normalizePredicate(predicate as Parameters<typeof normalizePredicate>[0]))
      as Promise<S['base'][T][]>,

      +    set: (data: Partial<S['create'][T]>) => ({

      +      where: (predicate: Partial<S['base'][T]> | ((record: S['base'][T])
      => boolean)) => io.update(core, tableName as string, data,
      normalizePredicate(predicate)) as Promise<S['base'][T][]>,
           }),
         });
       
         const del = <T extends keyof S['tables']>(tableName: T): OnDemandDeleteBuilder<S['base'][T]> => ({
      -    where: (predicate) => io.delete(core, tableName as string,
      normalizePredicate(predicate as Parameters<typeof normalizePredicate>[0]))
      as Promise<S['base'][T][]>,

      +    where: (predicate: Partial<S['base'][T]> | ((record: S['base'][T]) =>
      boolean)) => io.delete(core, tableName as string,
      normalizePredicate(predicate)) as Promise<S['base'][T][]>,
         });
       
         const notSupported = (methodName: string) => () => Promise.reject(KonroError({ code: 'E400', methodName }));
    patchStrategy: new-unified
snapshot:
  src/operations.ts: "import { randomUUID } from 'crypto';\r\nimport type {\n  DatabaseState,\n  KRecord,\n  KonroSchema,\n  RelationDefinition,\n  ColumnDefinition,\n  AggregationDefinition,\n  WithClause,\n  QueryDescriptor,\n  AggregationDescriptor,\n} from './types';\r\nimport { KonroError, KonroValidationError } from './utils/error.util';\r\n\r\n// --- HELPERS ---\r\n\r\n\r\n/** Creates a pristine, empty database state from a schema. */\r\nexport const createEmptyState = <S extends KonroSchema<any, any>>(schema: S): DatabaseState<S> => {\r\n  const state = {} as DatabaseState<S>;\r\n  for (const tableName in schema.tables) {\r\n    // This is a controlled cast, safe because we are iterating over the schema's tables.\r\n    (state as any)[tableName] = { records: [], meta: { lastId: 0 } };\r\n  }\r\n  return state;\r\n};\r\n\r\n// --- QUERY ---\r\n\r\nconst _processWith = <S extends KonroSchema<any, any>>(\r\n  recordsToProcess: KRecord[],\r\n  currentTableName: string,\r\n  withClause: WithClause,\r\n  schema: S,\r\n  state: DatabaseState\r\n): KRecord[] => {\r\n  // structuredClone is important to avoid mutating the records from the previous recursion level or the main state.\r\n  const resultsWithRelations = structuredClone(recordsToProcess);\r\n\r\n  for (const record of resultsWithRelations) {\r\n    for (const relationName in withClause) {\r\n      const relationDef = schema.relations[currentTableName]?.[relationName];\r\n      if (!relationDef) continue;\r\n\r\n      const withOpts = withClause[relationName];\r\n      // Skip if the value is `false` or something not truthy (though types should prevent this)\r\n      if (!withOpts) continue;\r\n\r\n      const relatedRecords = findRelatedRecords(state, record, relationDef);\r\n\r\n      const nestedWhere = typeof withOpts === 'object' ? withOpts.where : undefined;\r\n      const nestedSelect = typeof withOpts === 'object' ? withOpts.select : undefined;\r\n      const nestedWith = typeof withOpts === 'object' ? withOpts.with : undefined;\r\n\r\n      let processedRelatedRecords = nestedWhere ? relatedRecords.filter(nestedWhere) : [...relatedRecords];\r\n\r\n      // Recursively process deeper relations first\r\n      if (nestedWith && processedRelatedRecords.length > 0) {\r\n        processedRelatedRecords = _processWith(\r\n          processedRelatedRecords,\r\n          relationDef.targetTable,\r\n          nestedWith,\r\n          schema,\r\n          state\r\n        );\r\n      }\r\n\r\n      // Then, apply select on the (potentially already processed) related records\r\n      if (nestedSelect) {\r\n        const targetTableSchema = schema.tables[relationDef.targetTable];\r\n        if (!targetTableSchema) throw KonroError({ code: 'E201', tableName: relationDef.targetTable });\r\n\r\n        processedRelatedRecords = processedRelatedRecords.map(rec => {\r\n          const newRec: KRecord = {};\r\n          for (const outputKey in nestedSelect) {\r\n            const def = nestedSelect[outputKey];\r\n            if (!def) continue;\r\n            // nested with() does not support selecting relations, only columns, as per spec.\r\n            if (def._type === 'column') {\r\n              const colName = Object.keys(targetTableSchema).find(key => targetTableSchema[key] === def);\r\n              if (colName && rec.hasOwnProperty(colName)) {\r\n                newRec[outputKey] = rec[colName];\r\n              }\r\n            }\r\n          }\r\n          return newRec;\r\n        });\r\n      }\r\n\r\n      // Finally, attach the results to the parent record\r\n      if (relationDef.relationType === 'one') {\r\n        record[relationName] = processedRelatedRecords[0] ?? null;\r\n      } else {\r\n        record[relationName] = processedRelatedRecords;\r\n      }\r\n    }\r\n  }\r\n\r\n  return resultsWithRelations;\r\n};\r\n\r\nexport const _queryImpl = <S extends KonroSchema<any, any>>(state: DatabaseState, schema: S, descriptor: QueryDescriptor): KRecord[] => {\r\n  const tableState = state[descriptor.tableName];\r\n  if (!tableState) return [];\r\n\r\n  const tableSchema = schema.tables[descriptor.tableName];\r\n  if (!tableSchema) throw KonroError({ code: 'E201', tableName: descriptor.tableName });\r\n  const deletedAtColumn = Object.keys(tableSchema).find(key => tableSchema[key]?.options?._konro_sub_type === 'deletedAt');\r\n\r\n  // 1. Filter\r\n  let results: KRecord[];\r\n\r\n  // Auto-filter soft-deleted records unless opted-out\r\n  if (deletedAtColumn && !descriptor.withDeleted) {\r\n    results = tableState.records.filter(r => r[deletedAtColumn] === null || r[deletedAtColumn] === undefined);\r\n  } else {\r\n    results = [...tableState.records];\r\n  }\r\n  \r\n  results = descriptor.where ? results.filter(descriptor.where) : results;\r\n\r\n  // 2. Eager load relations (`with`) - must happen after filtering\r\n  if (descriptor.with) {\r\n    results = \r\n_processWith(results, descriptor.tableName, descriptor.with, schema, state);\r\n  }\r\n\r\n  // 3. Paginate\r\n  const offset = descriptor.offset ?? 0;\r\n  const limit = descriptor.limit ?? results.length;\r\n  let paginatedResults = results.slice(offset, offset + limit);\r\n\r\n  // 4. Select Fields\r\n  if (descriptor.select) {\r\n    const relationsSchema = schema.relations[descriptor.tableName] ?? {};\r\n\r\n    paginatedResults = paginatedResults.map(rec => {\r\n      const newRec: KRecord = {};\r\n      for (const outputKey in descriptor.select!) {\r\n        const def = descriptor.select![outputKey];\r\n        if (!def) continue;\r\n        if (def._type === 'column') {\r\n          const colName = Object.keys(tableSchema).find(key => tableSchema[key] === def);\r\n          if (colName && rec.hasOwnProperty(colName)) {\r\n            newRec[outputKey] = rec[colName];\r\n          }\r\n        } else if (def._type === 'relation') {\r\n          const relName = Object.keys(relationsSchema).find(key => relationsSchema[key] === def);\r\n          if (relName && rec.hasOwnProperty(relName)) {\r\n            newRec[outputKey] = rec[relName];\r\n          }\r\n        }\r\n      }\r\n      return newRec;\r\n    });\r\n  }\r\n\r\n  return paginatedResults;\r\n};\r\n\r\nconst findRelatedRecords = (state: DatabaseState, record: KRecord, relationDef: RelationDefinition) => {\r\n  const foreignKey = record[relationDef.on];\r\n  const targetTable = state[relationDef.targetTable];\r\n\r\n  if (foreignKey === undefined || !targetTable) return [];\r\n\r\n  // one-to-many: 'on' is PK on current table, 'references' is FK on target\r\n  if (relationDef.relationType === 'many') {\r\n    return targetTable.records.filter(r => r[relationDef.references] === foreignKey);\r\n  }\r\n\r\n  // many-to-one: 'on' is FK on current table, 'references' is PK on target\r\n  if (relationDef.relationType === 'one') {\r\n    return targetTable.records.filter(r => r[relationDef.references] === foreignKey);\r\n  }\r\n\r\n  return [];\r\n};\r\n\r\n// --- AGGREGATION ---\r\n\r\nexport const _aggregateImpl = <S extends KonroSchema<any, any>>(\r\n  state: DatabaseState,\r\n  _schema: S, // Not used but keep for API consistency\r\n  descriptor: AggregationDescriptor\r\n): Record<string, number | null> => {\r\n  const tableState = state[descriptor.tableName];\r\n  if (!tableState) return {};\r\n\r\n  const filteredRecords = descriptor.where ? tableState.records.filter(descriptor.where) : [...tableState.records];\r\n  const results: Record<string, number | null> = {};\r\n\r\n  for (const resultKey in descriptor.aggregations) {\r\n    const aggDef = descriptor.aggregations[resultKey];\r\n    if (!aggDef) continue;\r\n\r\n    if (aggDef.aggType === 'count') {\r\n      results[resultKey] = filteredRecords.length;\r\n      continue;\r\n    }\r\n\r\n    if (!aggDef.column) {\r\n      throw KonroError({ code: 'E203', aggType: aggDef.aggType });\r\n    }\r\n    const column = aggDef.column;\r\n\r\n    const values = filteredRecords.map(r => r[column]).filter(v => typeof v === 'number') as number[];\r\n\r\n    if (values.length === 0) {\r\n      if (aggDef.aggType === 'sum') {\r\n        results[resultKey] = 0; // sum of empty set is 0\r\n      } else {\r\n        results[resultKey] = null; // avg, min, max of empty set is null\r\n      }\r\n      continue;\r\n    }\r\n\r\n    switch (aggDef.aggType) {\r\n      case 'sum':\r\n        results[resultKey] = values.reduce((sum, val) => sum + val, 0);\r\n        break;\r\n      case 'avg':\r\n        results[resultKey] = values.reduce((sum, val) => sum + val, 0) / values.length;\r\n        break;\r\n      case 'min':\r\n        results[resultKey] = Math.min(...values);\r\n        break;\r\n      case 'max':\r\n        results[resultKey] = Math.max(...values);\r\n        break;\r\n    }\r\n  }\r\n  return results;\r\n};\r\n\r\n// --- INSERT ---\r\n\r\nexport const _insertImpl = <S extends KonroSchema<any, any>>(state: DatabaseState, schema: S, tableName: string, values: KRecord[]): [DatabaseState, KRecord[]] => {\r\n  const oldTableState = state[tableName];\r\n  if (!oldTableState) throw KonroError({ code: 'E200', tableName });\r\n\r\n  // To maintain immutability, we deep-clone only the table being modified.\r\n  const tableState = structuredClone(oldTableState);\r\n  const tableSchema = schema.tables[tableName];\r\n  if (!tableSchema) throw KonroError({ code: 'E201', tableName });\r\n  const insertedRecords: KRecord[] = [];\r\n\r\n  for (const value of values) {\r\n    const newRecord: KRecord = { ...value };\r\n    // Handle IDs and defaults\r\n    for (const colName in tableSchema) {\r\n      const colDef = tableSchema[colName];\r\n      if (colDef.dataType === 'id') {\r\n        if (newRecord[colName] === undefined) {\r\n          // Generate new PK if not provided\r\n          if (colDef.options?._pk_strategy === 'uuid') {\r\n            newRecord[colName] = randomUUID();\r\n          } else { // 'auto-increment' or legacy undefined strategy\r\n            tableState.meta.lastId++;\r\n            newRecord[colName] = tableState.meta.lastId;\r\n          }\r\n        } else {\r\n          // If user provided an ID for an auto-increment table, update lastId to avoid future collisions.\r\n          if (colDef.options?._pk_strategy !== 'uuid' && typeof newRecord[colName] === 'number') {\r\n            tableState.meta.lastId = Math.max(tableState.meta.lastId, newRecord[colName] as number);\r\n          }\r\n        }\r\n      }\r\n      if (newRecord[colName] === undefined && colDef.options?.default !== undefined) {\r\n        newRecord[colName] = typeof colDef.options.default === 'function' ? colDef.options.default() : colDef.options.default;\r\n      }\r\n    }\r\n\r\n    // Validate the record before inserting\r\n    validateRecord(newRecord, tableSchema, tableState.records);\r\n\r\n    tableState.records.push(newRecord);\r\n    insertedRecords.push(newRecord);\r\n  }\r\n\r\n  const newState = { ...state, [tableName]: tableState };\r\n  return [newState, insertedRecords];\r\n};\r\n\r\n// --- UPDATE ---\r\n\r\nexport const _updateImpl = <S extends KonroSchema<any, any>>(state: DatabaseState, schema: S, tableName: string, data: Partial<KRecord>, predicate: (record: KRecord) => boolean): [DatabaseState, KRecord[]] => {\r\n  const oldTableState = state[tableName];\r\n  if (!oldTableState) throw KonroError({ code: 'E200', tableName });\r\n\r\n  const tableSchema = schema.tables[tableName];\r\n  if (!tableSchema) {\r\n    throw KonroError({ code: 'E201', tableName });\r\n  }\r\n\r\n  const updatedRecords: KRecord[] = [];\r\n\r\n  // Auto-update 'updatedAt' timestamp\r\n  for (const colName of Object.keys(tableSchema)) {\r\n      if (tableSchema[colName]?.options?._konro_sub_type === 'updatedAt') {\r\n          (data as KRecord)[colName] = new Date();\r\n      }\r\n  }\r\n\r\n  const updateData = { ...data };\r\n  // Find the ID column from the schema and prevent it from being updated.\r\n  const idColumn = Object.entries(tableSchema).find(([, colDef]) => {\r\n    return colDef && typeof colDef === 'object' && '_type' in colDef && colDef._type === 'column' && 'dataType' in colDef && colDef.dataType === 'id';\r\n  })?.[0];\r\n  if (idColumn && updateData[idColumn] !== undefined) {\r\n    delete updateData[idColumn];\r\n  }\r\n\r\n  const newRecords = oldTableState.records.map(record => {\r\n    if (predicate(record)) {\r\n      const updatedRecord = { ...record, ...updateData };\r\n\r\n      // Validate the updated record, excluding current record from unique checks\r\n      const otherRecords = oldTableState.records.filter(r => r !== record);\r\n      validateRecord(updatedRecord, tableSchema, otherRecords);\r\n\r\n      updatedRecords.push(updatedRecord);\r\n      return updatedRecord;\r\n    }\r\n    return record;\r\n  });\r\n\r\n  if (updatedRecords.length === 0) {\r\n    return [state, []];\r\n  }\r\n\r\n  const tableState = { ...oldTableState, records: newRecords };\r\n  const newState = { ...state, [tableName]: tableState };\r\n\r\n  return [newState, updatedRecords];\r\n};\r\n\r\n\r\n// --- DELETE ---\r\n\r\nfunction applyCascades<S extends KonroSchema<any, any>>(\r\n  state: DatabaseState<S>,\r\n  schema: S,\r\n  tableName: string,\r\n  deletedRecords: KRecord[]\r\n): DatabaseState<S> {\r\n  if (deletedRecords.length === 0) {\r\n    return state;\r\n  }\r\n\r\n  let nextState = state;\r\n  const relations = schema.relations[tableName] ?? {};\r\n\r\n  for (const relationName in relations) {\r\n    const relationDef = relations[relationName];\r\n    // We only cascade from the \"one\" side of a one-to-many relationship, which is a 'many' type in Konro.\r\n    if (!relationDef || relationDef.relationType !== 'many' || !relationDef.onDelete) {\r\n      continue;\r\n    }\r\n\r\n    const sourceKey = relationDef.on;\r\n    const targetTable = relationDef.targetTable;\r\n    const targetKey = relationDef.references;\r\n\r\n    const sourceKeyValues = deletedRecords.map(r => r[sourceKey]).filter(v => v !== undefined);\r\n    if (sourceKeyValues.length === 0) continue;\r\n\r\n    const sourceKeySet = new Set(sourceKeyValues);\r\n    const predicate = (record: KRecord) => sourceKeySet.has(record[targetKey] as any);\r\n\r\n    if (relationDef.onDelete === 'CASCADE') {\r\n      // Recursively delete\r\n      const [newState, ] = _deleteImpl(nextState, schema, targetTable, predicate);\r\n      nextState = newState as DatabaseState<S>;\r\n    } else if (relationDef.onDelete === 'SET NULL') {\r\n      // Update FK to null\r\n      const [newState, ] = _updateImpl(nextState, schema, targetTable, { [targetKey]: null }, predicate);\r\n      nextState = newState as DatabaseState<S>;\r\n    }\r\n  }\r\n\r\n  return nextState;\r\n}\r\n\r\nexport const _deleteImpl = (state: DatabaseState, schema: KonroSchema<any, any>, tableName: string, predicate: (record: KRecord) => boolean): [DatabaseState, KRecord[]] => {\r\n  const oldTableState = state[tableName];\r\n  if (!oldTableState) throw KonroError({ code: 'E200', tableName });\r\n  const tableSchema = schema.tables[tableName];\r\n  if (!tableSchema) throw KonroError({ code: 'E201', tableName });\r\n\r\n  const deletedAtColumn = Object.keys(tableSchema).find(key => tableSchema[key]?.options?._konro_sub_type === 'deletedAt');\r\n\r\n  // Soft delete path\r\n  if (deletedAtColumn) {\r\n    // Use update implementation for soft-delete. It will also handle `updatedAt`.\r\n    const [baseState, recordsToUpdate] = _updateImpl(\r\n      state,\r\n      schema,\r\n      tableName,\r\n      { [deletedAtColumn]: new Date() },\r\n      (record) => !record[deletedAtColumn] && predicate(record)\r\n    );\r\n\r\n    if (recordsToUpdate.length === 0) return [state, []];\r\n    const finalState = applyCascades(baseState, schema, tableName, recordsToUpdate);\r\n    // The returned records are the ones that were just soft-deleted from this table.\r\n    return [finalState, recordsToUpdate];\r\n  } \r\n  \r\n  // Hard delete path\r\n  const recordsToDelete: KRecord[] = [];\r\n  const keptRecords = oldTableState.records.filter(r => predicate(r) ? (recordsToDelete.push(r), false) : true);\r\n\r\n  if (recordsToDelete.length === 0) return [state, []];\r\n\r\n  const baseState = { ...state, [tableName]: { ...oldTableState, records: keptRecords } };\r\n  const finalState = applyCascades(baseState, schema, tableName, recordsToDelete);\r\n\r\n  return [finalState, recordsToDelete];\r\n};\r\n\r\n// --- VALIDATION ---\r\n\r\nconst validateRecord = (record: KRecord, tableSchema: Record<string, any>, existingRecords: KRecord[]): void => {\r\n  for (const [columnName, colDef] of Object.entries(tableSchema)) {\r\n    if (!colDef || typeof colDef !== 'object' || !('dataType' in colDef)) continue;\r\n\r\n    const value = record[columnName];\r\n    const options = colDef.options || {};\r\n\r\n    // Skip validation for undefined values (they should have defaults applied already)\r\n    if (value === undefined) continue;\r\n\r\n    // Validate unique constraint\r\n    if (options.unique && existingRecords.some(r => r[columnName] === value)) {\r\n      throw KonroValidationError({ code: 'E300', value: String(value), columnName });\r\n    }\r\n\r\n    // Validate string constraints\r\n    if (colDef.dataType === 'string' && typeof value === 'string') {\r\n      // Min length\r\n      if (options.min !== undefined && value.length < options.min) {\r\n        throw KonroValidationError({ code: 'E301', value, columnName, min: options.min });\r\n      }\r\n\r\n      // Max length\r\n      if (options.max !== undefined && value.length > options.max) {\r\n        throw KonroValidationError({ code: 'E302', value, columnName, max: options.max });\r\n      }\r\n\r\n      // Format validation\r\n      if (options.format === 'email' && !isValidEmail(value)) {\r\n        throw KonroValidationError({ code: 'E303', value, columnName });\r\n      }\r\n    }\r\n\r\n    // Validate number constraints\r\n    if (colDef.dataType === 'number' && typeof value === 'number') {\r\n      // Min value\r\n      if (options.min !== undefined && value < options.min) {\r\n        throw KonroValidationError({ code: 'E304', value, columnName, min: options.min });\r\n      }\r\n\r\n      // Max value\r\n      if (options.max !== undefined && value > options.max) {\r\n        throw KonroValidationError({ code: 'E305', value, columnName, max: options.max });\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nconst isValidEmail = (email: string): boolean => {\r\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n  return emailRegex.test(email);\r\n};"
  src/types.ts: >-
    // --- Schema Definition Types (from schema.ts) ---


    /** The definition for a database column, created by helpers like
    `konro.string()`. */

    export interface ColumnDefinition<T> {
      readonly _type: 'column';
      readonly dataType: 'id' | 'string' | 'number' | 'boolean' | 'date' | 'object';
      readonly options: any;
      readonly _tsType?: T; // Phantom type, does not exist at runtime
    }


    /** The definition for a table relationship, created by `konro.one()` or
    `konro.many()`. */

    export interface BaseRelationDefinition {
      readonly _type: 'relation';
      readonly targetTable: string;
      readonly on: string;
      readonly references: string;
      readonly onDelete?: 'CASCADE' | 'SET NULL';
    }


    export interface OneRelationDefinition extends BaseRelationDefinition {
      readonly relationType: 'one';
    }


    export interface ManyRelationDefinition extends BaseRelationDefinition {
      readonly relationType: 'many';
    }


    export type RelationDefinition = OneRelationDefinition |
    ManyRelationDefinition;


    /** The definition for a data aggregation, created by `konro.count()`,
    `konro.sum()`, etc. */

    export interface AggregationDefinition {
      readonly _type: 'aggregation';
      readonly aggType: 'count' | 'sum' | 'avg' | 'min' | 'max';
      readonly column?: string;
    }


    /** Infers the underlying TypeScript type from a `ColumnDefinition`. e.g.,
    `ColumnDefinition<string>` => `string`. */

    type InferColumnType<C> = C extends ColumnDefinition<infer T> ? T : never;


    /** A mapping of table names to their base model types (columns only, no
    relations). */

    export type BaseModels<TTables extends Record<string, any>> = {
      [TableName in keyof TTables]: {
        [ColumnName in keyof TTables[TableName]]: InferColumnType<TTables[TableName][ColumnName]>;
      };
    };


    /** A mapping of table names to their full model types, including relations.
    */

    type Models<
      TTables extends Record<string, any>,
      TRelations extends Record<string, any>,
      TBaseModels extends Record<keyof TTables, any>
    > = {
      [TableName in keyof TTables]: TBaseModels[TableName] &
        (TableName extends keyof TRelations
          ? {
              [RelationName in keyof TRelations[TableName]]?: TRelations[TableName][RelationName] extends OneRelationDefinition
                ? Models<TTables, TRelations, TBaseModels>[TRelations[TableName][RelationName]['targetTable']] | null
                : TRelations[TableName][RelationName] extends ManyRelationDefinition
                ? Models<TTables, TRelations, TBaseModels>[TRelations[TableName][RelationName]['targetTable']][]
                : never;
            }
          : {});
    };


    /** Finds all column names in a table definition that are optional for
    insertion (i.e., `id` or has a `default`). */

    type OptionalCreateKeys<TTableDef> = {
      [K in keyof TTableDef]: TTableDef[K] extends { dataType: 'id' }
        ? K
        : TTableDef[K] extends { options: { default: unknown } }
        ? K
        : never;
    }[keyof TTableDef];


    /** A mapping of table names to their "create" types, used for `db.insert`.
    */

    type CreateModels<
      TTables extends Record<string, any>,
      TBaseModels extends Record<keyof TTables, any>
    > = {
      [TableName in keyof TTables]: Omit<
        {
          // Required fields
          [K in Exclude<keyof TBaseModels[TableName], OptionalCreateKeys<TTables[TableName]>>]: TBaseModels[TableName][K];
        } & {
          // Optional fields
          [K in OptionalCreateKeys<TTables[TableName]>]?: TBaseModels[TableName][K];
        },
        // 'id' is always omitted from create types
        'id'
      >;
    };


    /** The publicly exposed structure of a fully-processed Konro schema. */

    export interface KonroSchema<
      TTables extends Record<string, any>,
      TRelations extends Record<string, any>
    > {
      tables: TTables;
      relations: TRelations;
      /** The full, relational types for each table model. */
      types: Models<TTables, TRelations, BaseModels<TTables>>;
      /** The base types for each table model, without any relations. */
      base: BaseModels<TTables>;
      /** The types for creating new records, with defaults and `id` made optional. */
      create: CreateModels<TTables, BaseModels<TTables>>;
    }



    // --- Generic & Core Types ---


    /** A generic representation of a single record within a table. It uses
    `unknown` for values to enforce type-safe access. */

    export type KRecord = Record<string, unknown>;


    /** Represents the state of a single table, including its records and
    metadata. */

    export type TableState<T extends KRecord = KRecord> = {
      records: T[];
      meta: {
        lastId: number;
      };
    };


    /** The in-memory representation of the entire database. It is a plain,
    immutable object. */

    export type DatabaseState<S extends KonroSchema<any, any> | unknown =
    unknown> = S extends KonroSchema<any, any>
      ? {
          [TableName in keyof S['tables']]: TableState<BaseModels<S['tables']>[TableName]>;
        }
      : {
          [tableName: string]: TableState;
        };


    // --- FS Provider Types (from fs.ts) ---

    export interface FsProvider {
      readFile(filepath: string): Promise<string | null>;
      writeFile(filepath: string, content: string, encoding: 'utf-8'): Promise<void>;
      rename(oldPath: string, newPath: string): Promise<void>;
      mkdir(dir: string, options: { recursive: true }): Promise<string | undefined>;
      readdir(dir: string): Promise<string[]>;
      unlink(filepath: string): Promise<void>;
    }



    // --- Serializer Types (from utils/serializer.util.ts) ---

    export type Serializer = {
      parse: <T>(data: string, tableSchema?: Record<string, ColumnDefinition<any>>) => T;
      stringify: (obj: any) => string;
    };



    // --- Storage Adapter Types (from adapter.ts) ---


    export interface StorageAdapter {
      read<S extends KonroSchema<any, any>>(schema: S): Promise<DatabaseState<S>>;
      write(state: DatabaseState<any>, schema: KonroSchema<any, any>): Promise<void>;
      readonly mode: 'in-memory' | 'on-demand';
    }


    export interface FileStorageAdapter extends StorageAdapter {
      readonly options: FileAdapterOptions;
      readonly fs: FsProvider;
      readonly serializer: Serializer;
      readonly fileExtension: string;
    }


    type SingleFileStrategy = { single: { filepath: string }; multi?: never;
    perRecord?: never };

    type MultiFileStrategy = { multi: { dir: string }; single?: never;
    perRecord?: never };

    type PerRecordStrategy = { perRecord: { dir: string }; single?: never;
    multi?: never };


    export type FileAdapterOptions = {
      format: 'json' | 'yaml' | 'csv' | 'xlsx';
      fs?: FsProvider;
      /**
       * Defines the data access strategy.
       * - `in-memory`: (Default) Loads the entire database into memory on init. Fast for small/medium datasets.
       * - `on-demand`: Reads from the file system for each query. Slower but supports larger datasets. Requires 'multi-file' or 'per-record' strategy.
       */
      mode?: 'in-memory' | 'on-demand';
    } & (SingleFileStrategy | MultiFileStrategy | PerRecordStrategy);



    // --- Operation Descriptor Types (from operations.ts) ---


    export type WithClause = Record<string, boolean | {
      where?: (record: KRecord) => boolean;
      select?: Record<string, ColumnDefinition<unknown>>;
      with?: WithClause;
    }>;


    export interface QueryDescriptor {
      tableName: string;
      select?: Record<string, ColumnDefinition<unknown> | RelationDefinition>;
      where?: (record: KRecord) => boolean;
      with?: WithClause;
      limit?: number;
      offset?: number;
      withDeleted?: boolean;
    }


    export interface AggregationDescriptor extends QueryDescriptor {
      aggregations: Record<string, AggregationDefinition>;
    }



    // --- DB Context & Fluent API Types (from db.ts) ---


    type RelatedModel<T> = T extends (infer R)[] ? R : T extends (infer R |
    null) ? R : T;


    export type WithArgument<TAll> = {
      [K in keyof TAll as NonNullable<TAll[K]> extends any[] | object ? K : never]?: boolean | ({
        where?: (record: RelatedModel<NonNullable<TAll[K]>>) => boolean;
      } & (
        | { select: Record<string, ColumnDefinition<unknown>>; with?: never }
        | { select?: never; with?: WithArgument<RelatedModel<NonNullable<TAll[K]>>> }
      ));
    };


    export type ResolveWith<
      S extends KonroSchema<any, any>,
      TName extends keyof S['tables'],
      TWith extends WithArgument<S['types'][TName]>
    > = {
        [K in keyof TWith & keyof S['relations'][TName]]:
            S['relations'][TName][K] extends { relationType: 'many' }
                ? (
                    TWith[K] extends { select: infer TSelect }
                        ? ({ [P in keyof TSelect]: InferColumnType<TSelect[P]> })[]
                        : TWith[K] extends { with: infer TNestedWith }
                            ? (S['base'][S['relations'][TName][K]['targetTable']] & ResolveWith<S, S['relations'][TName][K]['targetTable'], TNestedWith & WithArgument<S['types'][S['relations'][TName][K]['targetTable']]>>)[]
                            : S['base'][S['relations'][TName][K]['targetTable']][]
                  )
                : S['relations'][TName][K] extends { relationType: 'one' }
                    ? (
                        TWith[K] extends { select: infer TSelect }
                            ? ({ [P in keyof TSelect]: InferColumnType<TSelect[P]> }) | null
                            : TWith[K] extends { with: infer TNestedWith }
                                ? (S['base'][S['relations'][TName][K]['targetTable']] & ResolveWith<S, S['relations'][TName][K]['targetTable'], TNestedWith & WithArgument<S['types'][S['relations'][TName][K]['targetTable']]>>) | null
                                : S['base'][S['relations'][TName][K]['targetTable']] | null
                      )
                    : never
    };


    interface ChainedQueryBuilder<S extends KonroSchema<any, any>, TName extends
    keyof S['tables'], TReturn> {
      select(fields: Record<string, ColumnDefinition<unknown> | RelationDefinition>): this;
      where(predicate: Partial<S['base'][TName]> | ((record: S['base'][TName]) => boolean)): this;
      withDeleted(): this;
      with<W extends WithArgument<S['types'][TName]>>(relations: W): ChainedQueryBuilder<S, TName, TReturn & ResolveWith<S, TName, W>>;
      limit(count: number): this;
      offset(count: number): this;
      all(): TReturn[];
      first(): TReturn | null;
      aggregate<TAggs extends Record<string, AggregationDefinition>>(
        aggregations: TAggs
      ): { [K in keyof TAggs]: number | null };
    }


    interface QueryBuilder<S extends KonroSchema<any, any>> {
      from<T extends keyof S['tables']>(tableName: T): ChainedQueryBuilder<S, T, S['base'][T]>;
    }


    interface UpdateBuilder<S extends KonroSchema<any, any>, TBase, TCreate> {
      set(data: Partial<TCreate>): {
        where(predicate: Partial<TBase> | ((record: TBase) => boolean)): [DatabaseState<S>, TBase[]];
      };
    }


    interface DeleteBuilder<S extends KonroSchema<any, any>, TBase> {
      where(predicate: Partial<TBase> | ((record: TBase) => boolean)): [DatabaseState<S>, TBase[]];
    }


    export interface InMemoryDbContext<S extends KonroSchema<any, any>> {
      schema: S;
      adapter: StorageAdapter;
      read(): Promise<DatabaseState<S>>;
      write(state: DatabaseState<S>): Promise<void>;
      createEmptyState(): DatabaseState<S>;

      query(state: DatabaseState<S>): QueryBuilder<S>;
      insert<T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T, values: S['create'][T]): [DatabaseState<S>, S['base'][T]];
      insert<T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T, values: Readonly<S['create'][T]>[]): [DatabaseState<S>, S['base'][T][]];
      update<T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T): UpdateBuilder<S, S['base'][T], S['create'][T]>;
      delete<T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T): DeleteBuilder<S, S['base'][T]>;
    }


    interface OnDemandChainedQueryBuilder<S extends KonroSchema<any, any>, TName
    extends keyof S['tables'], TReturn> {
      select(fields: Record<string, ColumnDefinition<unknown> | RelationDefinition>): this;
      where(predicate: Partial<S['base'][TName]> | ((record: S['base'][TName]) => boolean)): this;
      withDeleted(): this;
      with<W extends WithArgument<S['types'][TName]>>(relations: W): OnDemandChainedQueryBuilder<S, TName, TReturn & ResolveWith<S, TName, W>>;
      limit(count: number): this;
      offset(count: number): this;
      all(): Promise<TReturn[]>;
      first(): Promise<TReturn | null>;
      aggregate<TAggs extends Record<string, AggregationDefinition>>(
        aggregations: TAggs
      ): Promise<{ [K in keyof TAggs]: number | null }>;
    }


    interface OnDemandQueryBuilder<S extends KonroSchema<any, any>> {
      from<T extends keyof S['tables']>(tableName: T): OnDemandChainedQueryBuilder<S, T, S['base'][T]>;
    }


    interface OnDemandUpdateBuilder<TBase, TCreate> {
      set(data: Partial<TCreate>): {
        where(predicate: Partial<TBase> | ((record: TBase) => boolean)): Promise<TBase[]>;
      };
    }


    interface OnDemandDeleteBuilder<TBase> {
      where(predicate: Partial<TBase> | ((record: TBase) => boolean)): Promise<TBase[]>;
    }


    export interface OnDemandDbContext<S extends KonroSchema<any, any>> {
      schema: S;
      adapter: StorageAdapter;
      read(): Promise<never>;
      write(): Promise<never>;
      createEmptyState(): DatabaseState<S>;

      query(): OnDemandQueryBuilder<S>;
      insert<T extends keyof S['tables']>(tableName: T, values: S['create'][T]): Promise<S['base'][T]>;
      insert<T extends keyof S['tables']>(tableName: T, values: Readonly<S['create'][T]>[]): Promise<S['base'][T][]>;
      update<T extends keyof S['tables']>(tableName: T): OnDemandUpdateBuilder<S['base'][T], S['create'][T]>;
      delete<T extends keyof S['tables']>(tableName: T): OnDemandDeleteBuilder<S['base'][T]>;
    }


    export type DbContext<S extends KonroSchema<any, any>> =
    InMemoryDbContext<S> | OnDemandDbContext<S>;
  src/schema.ts: >-
    //

    // Konro: The Type-Safe, Functional ORM for JSON/YAML

    //

    // ## Pillar I: The Recipe (Schema Definition)

    //

    // This file contains the core logic for defining a database schema. It is
    designed to be

    // both the runtime source of truth for validation and the static source of
    truth for

    // TypeScript types. By using phantom types and inference, we can create a
    fully-typed

    // `db` object from a single schema definition object, eliminating the need
    for manual

    // type declarations (`interface User { ... }`) and ensuring they never get
    out of sync.

    //


    import type {
      KonroSchema,
      ColumnDefinition,
      BaseRelationDefinition,
      OneRelationDefinition,
      ManyRelationDefinition,
      AggregationDefinition
    } from './types';


    // --- SCHEMA BUILDER FUNCTION ---


    /**
     * Defines the structure, types, and relations of your database.
     * This is the single source of truth for both runtime validation and static types.
     *
     * @param schemaDef The schema definition object.
     * @returns A processed schema object with inferred types attached.
     */
    export const createSchema = <
      const TDef extends {
        tables: Record<string, Record<string, ColumnDefinition<any>>>;
        relations?: (tables: TDef['tables']) => Record<string, Record<string, OneRelationDefinition | ManyRelationDefinition>>;
      }
    >(
      schemaDef: TDef
    ): KonroSchema<TDef['tables'], TDef['relations'] extends (...args: any) =>
    any ? ReturnType<TDef['relations']> : {}> => { // eslint-disable-line
      const relations = schemaDef.relations ? schemaDef.relations(schemaDef.tables) : {};
      return {
        tables: schemaDef.tables,
        relations: relations as any, // Cast to bypass complex conditional type issue
        // Types are applied via the return type annotation, these are just placeholders at runtime.
        types: null as any,
        base: {} as any,
        create: {} as any,
      };
    };



    // --- COLUMN DEFINITION HELPERS ---


    const createColumn = <T>(dataType: ColumnDefinition<T>['dataType'], options:
    object | undefined, tsType: T): ColumnDefinition<T> => ({
      _type: 'column',
      dataType,
      options,
      _tsType: tsType,
    });


    /** A managed, auto-incrementing integer primary key. This is the default
    strategy. */

    export const id = () => createColumn<number>('id', { unique: true,
    _pk_strategy: 'auto-increment' }, 0);

    /** A managed, universally unique identifier (UUID) primary key. Stored as a
    string. */

    export const uuid = () => createColumn<string>('id', { unique: true,
    _pk_strategy: 'uuid' }, '');

    /** A string column with optional validation. */

    export const string = (options?: { unique?: boolean; default?: string | (()
    => string); min?: number; max?: number; format?: 'email' | 'uuid' | 'url' })
    => createColumn<string>('string', options, '');

    /** A number column with optional validation. */

    export const number = (options?: { unique?: boolean; default?: number | (()
    => number); min?: number; max?: number; type?: 'integer' }) =>
    createColumn<number>('number', options, 0);

    /** A boolean column. */

    export const boolean = (options?: { default?: boolean | (() => boolean) })
    => createColumn<boolean>('boolean', options, false);

    /** A generic date column. Consider using `createdAt` or `updatedAt` for
    managed timestamps. */

    export const date = (options?: { default?: Date | (() => Date) }) =>
    createColumn<Date>('date', options, new Date());

    /** A managed timestamp set when a record is created. */

    export const createdAt = (): ColumnDefinition<Date> =>
    createColumn<Date>('date', { _konro_sub_type: 'createdAt', default: () =>
    new Date() }, new Date());

    /** A managed timestamp set when a record is created and updated. */

    export const updatedAt = (): ColumnDefinition<Date> =>
    createColumn<Date>('date', { _konro_sub_type: 'updatedAt', default: () =>
    new Date() }, new Date());

    /** A managed, nullable timestamp for soft-deleting records. */

    export const deletedAt = (): ColumnDefinition<Date | null> =>
    createColumn<Date | null>('date', { _konro_sub_type: 'deletedAt', default:
    null }, null);

    /** A column for storing arbitrary JSON objects, with a generic for type
    safety. */

    export const object = <T extends Record<string, unknown>>(options?: {
    default?: T | (() => T) }): ColumnDefinition<T> => ({ _type: 'column',
    dataType: 'object', options });



    // --- RELATIONSHIP DEFINITION HELPERS ---


    /** Defines a `one-to-one` or `many-to-one` relationship. */

    export const one = <T extends string>(targetTable: T, options: { on: string;
    references: string; onDelete?: 'CASCADE' | 'SET NULL' }):
    OneRelationDefinition & { targetTable: T } => ({
      _type: 'relation',
      relationType: 'one',
      targetTable,
      ...options,
    });


    /** Defines a `one-to-many` relationship. */

    export const many = <T extends string>(targetTable: T, options: { on:
    string; references: string; onDelete?: 'CASCADE' | 'SET NULL' }):
    ManyRelationDefinition & { targetTable: T } => ({
      _type: 'relation',
      relationType: 'many',
      targetTable,
      ...options,
    });



    // --- AGGREGATION DEFINITION HELPERS ---


    /** Aggregation to count records. */

    export const count = (): AggregationDefinition => ({ _type: 'aggregation',
    aggType: 'count' });

    /** Aggregation to sum a numeric column. */

    export const sum = (column: string): AggregationDefinition => ({ _type:
    'aggregation', aggType: 'sum', column });

    /** Aggregation to average a numeric column. */

    export const avg = (column: string): AggregationDefinition => ({ _type:
    'aggregation', aggType: 'avg', column });

    /** Aggregation to find the minimum value in a numeric column. */

    export const min = (column: string): AggregationDefinition => ({ _type:
    'aggregation', aggType: 'min', column });

    /** Aggregation to find the maximum value in a numeric column. */

    export const max = (column: string): AggregationDefinition => ({ _type:
    'aggregation', aggType: 'max', column });
  src/adapter.ts: >-
    import path from 'path';

    import type {
      DatabaseState,
      KRecord,
      TableState,
      StorageAdapter,
      FileStorageAdapter,
      FileAdapterOptions,
      ColumnDefinition,
      KonroSchema,
      Serializer,
      FsProvider,
    } from './types';

    import { createEmptyState } from './operations';

    import { getSerializer } from './utils/serializer.util';

    import { defaultFsProvider, writeAtomic } from './fs';

    import { KonroError, KonroStorageError } from './utils/error.util';

    import { TEMP_FILE_SUFFIX } from './utils/constants';


    export function createFileAdapter(options: FileAdapterOptions & { mode:
    'on-demand' }): FileStorageAdapter & { mode: 'on-demand' };

    export function createFileAdapter(options: FileAdapterOptions & { mode?:
    'in-memory' | undefined }): FileStorageAdapter & { mode: 'in-memory' };

    export function createFileAdapter(options: FileAdapterOptions):
    FileStorageAdapter;

    export function createFileAdapter(options: FileAdapterOptions):
    FileStorageAdapter {
      const serializer = getSerializer(options.format);
      const fileExtension = `.${options.format}`;
      const fs = options.fs ?? defaultFsProvider;
      const mode = options.mode ?? 'in-memory';

      if (options.perRecord && options.format !== 'json' && options.format !== 'yaml') {
        throw KonroError({ code: 'E105' });
      }

      const isTabular = options.format === 'csv' || options.format === 'xlsx';
      if (isTabular && (mode !== 'on-demand' || !options.multi)) {
        throw KonroError({ code: 'E106', format: options.format });
      }

      if (mode === 'on-demand' && options.single) {
        throw KonroError({ code: 'E104' });
      }

      const strategy = createStrategy(options, { fs, serializer, fileExtension, mode });

      return {
        options,
        fs,
        serializer,
        fileExtension,
        mode,
        ...strategy,
      } as FileStorageAdapter;
    }


    type FileStrategy = Pick<StorageAdapter, 'read' | 'write'>;

    type StrategyContext = {
      fs: FsProvider;
      serializer: Serializer;
      fileExtension: string;
      mode: 'in-memory' | 'on-demand';
    };


    /** Chooses and creates the appropriate file strategy based on adapter
    options. */

    function createStrategy(options: FileAdapterOptions, context:
    StrategyContext): FileStrategy {
      if (options.single) {
        return createSingleFileStrategy(options.single, context);
      }
      if (options.multi) {
        return createMultiFileStrategy(options.multi, context);
      }
      if (options.perRecord) {
        return createPerRecordStrategy(options.perRecord, context);
      }
      // This case should be prevented by the types, but as a safeguard:
      throw KonroError({ code: 'E107' });
    }


    /** Creates the strategy for reading/writing the entire database to a single
    file. */

    function createSingleFileStrategy(options: SingleFileStrategy['single'],
    context: StrategyContext): FileStrategy {
      const { fs, serializer } = context;

      const parseFile = async <T>(filepath: string, schema?: Record<string, ColumnDefinition<unknown>>): Promise<T | undefined> => {
        const data = await fs.readFile(filepath);
        if (!data) return undefined;
        try {
          return serializer.parse<T>(data, schema);
        } catch (e) {
          const message = e instanceof Error ? e.message : String(e);
          throw KonroStorageError({ code: 'E103', filepath, format: context.fileExtension.slice(1), details: message });
        }
      };

      return {
        read: async <S extends KonroSchema<any, any>>(schema: S) => {
          // We parse into a generic DatabaseState because the exact type is only known by the caller.
          const state = await parseFile<DatabaseState>(options.filepath);
          return (state ?? createEmptyState(schema)) as DatabaseState<S>;
        },
        write: (state: DatabaseState<any>) => writeAtomic(options.filepath, serializer.stringify(state), fs),
      };
    }


    /** Creates the strategy for reading/writing each table to its own file in a
    directory. */

    function createMultiFileStrategy(options: MultiFileStrategy['multi'],
    context: StrategyContext): FileStrategy {
      const { fs, serializer, fileExtension } = context;
      const parseFile = async <T>(filepath: string, schema?: Record<string, ColumnDefinition<unknown>>): Promise<T | undefined> => {
        const data = await fs.readFile(filepath);
        if (!data) return undefined;
        try {
          return serializer.parse<T>(data, schema);
        } catch (e) {
          const message = e instanceof Error ? e.message : String(e);
          throw KonroStorageError({ code: 'E103', filepath, format: fileExtension.slice(1), details: message });
        }
      };

      return {
        read: async <S extends KonroSchema<any, any>>(schema: S) => {
          await context.fs.mkdir(options.dir, { recursive: true });
          const state = createEmptyState(schema);
          await Promise.all(
            Object.keys(schema.tables).map(async (tableName) => {
              const filepath = path.join(options.dir, `${tableName}${context.fileExtension}`);
              const tableState = await parseFile<TableState>(filepath, schema.tables[tableName]);
              if (tableState) (state as any)[tableName] = tableState;
            })
          );
          return state;
        },
        write: async (state: DatabaseState<any>) => {
          await context.fs.mkdir(options.dir, { recursive: true });
          const writes = Object.entries(state).map(([tableName, tableState]) => {
            const filepath = path.join(options.dir, `${tableName}${context.fileExtension}`);
            return writeAtomic(filepath, context.serializer.stringify(tableState), context.fs);
          });
          await Promise.all(writes);
        },
      };
    }


    /** Creates the strategy for reading/writing each record to its own file. */

    function createPerRecordStrategy(options: PerRecordStrategy['perRecord'],
    context: StrategyContext): FileStrategy {
      const { fs, serializer, fileExtension } = context;

      const parseFile = async <T>(filepath: string): Promise<T | undefined> => {
        const data = await fs.readFile(filepath);
        if (!data) return undefined;
        try {
          return serializer.parse<T>(data);
        } catch (e) {
          const message = e instanceof Error ? e.message : String(e);
          throw KonroStorageError({ code: 'E103', filepath, format: context.fileExtension.slice(1), details: message });
        }
      };

      return {
        read: async <S extends KonroSchema<any, any>>(schema: S) => {
          await fs.mkdir(options.dir, { recursive: true });
          const state = createEmptyState(schema);
          await Promise.all(
            Object.keys(schema.tables).map(async (tableName) => {
              const tableDir = path.join(options.dir, tableName);
              const currentTableState = state[tableName as keyof typeof state];
              if (!currentTableState) return;

              await fs.mkdir(tableDir, { recursive: true });

              const metaContent = await fs.readFile(path.join(tableDir, '_meta.json')).catch(() => null);
              if (metaContent) currentTableState.meta = JSON.parse(metaContent);

              const files = await fs.readdir(tableDir);
              const recordFiles = files.filter((f) => !f.startsWith('_meta'));
              const records = (await Promise.all(recordFiles.map((file) => parseFile<KRecord>(path.join(tableDir, file))))).filter((r): r is KRecord => r != null);
              currentTableState.records = records as any;

              if (currentTableState.meta.lastId === 0) {
                const idColumn = Object.keys(schema.tables[tableName]).find((k) => schema.tables[tableName][k]?.options?._pk_strategy === 'auto-increment');
                if (idColumn) {
                  currentTableState.meta.lastId = records.reduce((maxId: number, record: KRecord) => {
                    const id = record[idColumn];
                    return typeof id === 'number' && id > maxId ? id : maxId;
                  }, 0);
                }
              }
            })
          );
          return state;
        },
        write: async (state: DatabaseState<any>, schema: KonroSchema<any, any>) => {
          await fs.mkdir(options.dir, { recursive: true });
          await Promise.all(Object.entries(state).map(async ([tableName, tableState]) => {
            const tableDir = path.join(options.dir, tableName as string);
            await fs.mkdir(tableDir, { recursive: true });
            await writeAtomic(path.join(tableDir, '_meta.json'), JSON.stringify(tableState.meta, null, 2), fs);

            const idColumn = Object.keys(schema.tables[tableName]).find((k) => schema.tables[tableName][k]?.dataType === 'id');
            if (!idColumn) throw KonroError({ code: 'E202', tableName });

            const currentFiles = new Set(tableState.records.map((r: KRecord) => `${r[idColumn]}${fileExtension}`));
            const existingFiles = (await fs.readdir(tableDir)).filter(f => !f.startsWith('_meta') && !f.endsWith(TEMP_FILE_SUFFIX));

            const recordWrites = tableState.records.map((r) => writeAtomic(path.join(tableDir, `${r[idColumn]}${fileExtension}`), serializer.stringify(r), fs));
            const recordDeletes = existingFiles.filter(f => !currentFiles.has(f)).map(f => fs.unlink(path.join(tableDir, f as string)));
            await Promise.all([...recordWrites, ...recordDeletes]);
          }));
        }
      };
    }
  src/db.ts: >-
    import path from 'path';

    import type {
      AggregationDefinition,
      ColumnDefinition,
      KonroSchema,
      RelationDefinition,
      StorageAdapter,
      FileStorageAdapter,
      DatabaseState,
      KRecord,
      TableState,
      QueryDescriptor,
      AggregationDescriptor,
      WithArgument,
      ResolveWith,
      ChainedQueryBuilder,
      QueryBuilder,
      UpdateBuilder,
      DeleteBuilder,
      InMemoryDbContext,
      OnDemandChainedQueryBuilder,
      OnDemandQueryBuilder,
      OnDemandUpdateBuilder,
      OnDemandDeleteBuilder,
      OnDemandDbContext,
      DbContext,
    } from './types';

    import {
      _queryImpl,
      _insertImpl,
      _updateImpl,
      _deleteImpl,
      createEmptyState as createEmptyStateImpl,
      _aggregateImpl,
    } from './operations';

    import { createPredicateFromPartial } from './utils/predicate.util';

    import { KonroError, KonroStorageError } from './utils/error.util';

    import { writeAtomic } from './fs';


    // --- CORE LOGIC (STATELESS & PURE) ---


    /**
     * Creates the core, stateless database operations.
     * These operations are pure functions that take a database state and return a new state,
     * forming the foundation for both in-memory and on-demand modes.
     */
    function createCoreDbContext<S extends KonroSchema<any, any>>(schema: S) {
      // A helper to normalize a predicate argument
      const normalizePredicate = <T extends KRecord>(
        predicate: Partial<T> | ((record: T) => boolean)
      ): ((record: KRecord) => boolean) =>
        // The cast is necessary due to function argument contravariance.
        // The internal operations work on the wider `KRecord`, while the fluent API provides the specific `T`.
        (typeof predicate === 'function' ? predicate : createPredicateFromPartial(predicate)) as (record: KRecord) => boolean;

      const query = (state: DatabaseState<S>): QueryBuilder<S> => ({
        from: <TName extends keyof S['tables']>(tableName: TName): ChainedQueryBuilder<S, TName, S['base'][TName]> => {
          const createBuilder = <TReturn>(currentDescriptor: QueryDescriptor): ChainedQueryBuilder<S, TName, TReturn> => ({
            select(fields) { return createBuilder<TReturn>({ ...currentDescriptor, select: fields }); },
            where(predicate) { return createBuilder<TReturn>({ ...currentDescriptor, where: normalizePredicate(predicate as Parameters<typeof normalizePredicate>[0]) }); },
            withDeleted() { return createBuilder<TReturn>({ ...currentDescriptor, withDeleted: true }); },
            with<W extends WithArgument<S['types'][TName]>>(relations: W) {
              const newWith = { ...currentDescriptor.with, ...(relations as QueryDescriptor['with']) };
              return createBuilder<TReturn & ResolveWith<S, TName, W>>({ ...currentDescriptor, with: newWith });
            },
            limit(count) { return createBuilder<TReturn>({ ...currentDescriptor, limit: count }); },
            offset(count) { return createBuilder<TReturn>({ ...currentDescriptor, offset: count }); },
            all: (): TReturn[] => _queryImpl(state as DatabaseState, schema, currentDescriptor) as TReturn[],
            first: (): TReturn | null => (_queryImpl(state as DatabaseState, schema, { ...currentDescriptor, limit: 1 })[0] ?? null) as TReturn | null,
            aggregate: <TAggs extends Record<string, AggregationDefinition>>(aggregations: TAggs) => {
              const aggDescriptor: AggregationDescriptor = { ...currentDescriptor, aggregations };
              return _aggregateImpl(state as DatabaseState, schema, aggDescriptor) as { [K in keyof TAggs]: number | null };
            },
          });
          return createBuilder<S['base'][TName]>({ tableName: tableName as string });
        },
      });

      const insert = <T extends keyof S['tables']>(
        state: DatabaseState<S>, tableName: T, values: S['create'][T] | Readonly<S['create'][T]>[]
      ): [DatabaseState<S>, S['base'][T] | S['base'][T][]] => {
        const valsArray = Array.isArray(values) ? values : [values];
        const [newState, inserted] = _insertImpl(state as DatabaseState, schema, tableName as string, valsArray as KRecord[]);
        const result = Array.isArray(values) ? inserted : inserted[0];
        return [newState as DatabaseState<S>, result] as [DatabaseState<S>, S['base'][T] | S['base'][T][]];
      };

      const update = <T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T): UpdateBuilder<S, S['base'][T], S['create'][T]> => ({
        set: (data) => ({
          where: (predicate) => {
            const [newState, updatedRecords] = _updateImpl(state as DatabaseState, schema, tableName as string, data as Partial<KRecord>, normalizePredicate(predicate as Parameters<typeof normalizePredicate>[0]));
            return [newState as DatabaseState<S>, updatedRecords as S['base'][T][]];
          },
        }),
      });

      const del = <T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T): DeleteBuilder<S, S['base'][T]> => ({
        where: (predicate) => {
          const [newState, deletedRecords] = _deleteImpl(state as DatabaseState, schema, tableName as string, normalizePredicate(predicate as Parameters<typeof normalizePredicate>[0]));
          return [newState as DatabaseState<S>, deletedRecords as S['base'][T][]];
        },
      });

      return { query, insert, update, delete: del };
    }


    // --- ON-DEMAND CONTEXT (STATEFUL WRAPPER) ---


    type CoreDbContext<S extends KonroSchema<any, any>> = ReturnType<typeof
    createCoreDbContext<S>>;


    /** Defines the contract for file I/O operations in on-demand mode. */

    interface OnDemandIO<S extends KonroSchema<any, any>> {
      getFullState(): Promise<DatabaseState<S>>;
      insert(core: CoreDbContext<S>, tableName: string, values: any): Promise<any>;
      update(core: CoreDbContext<S>, tableName: string, data: Partial<unknown>, predicate: (record: KRecord) => boolean): Promise<KRecord[]>;
      delete(core: CoreDbContext<S>, tableName: string, predicate: (record: KRecord) => boolean): Promise<KRecord[]>;
    }


    /**
     * Creates a generic, unified `OnDemandDbContext` from an I/O strategy.
     * This function is the key to removing duplication between 'multi-file' and 'per-record' modes.
     */
    function createOnDemandDbContext<S extends KonroSchema<any, any>>(
      schema: S,
      adapter: StorageAdapter,
      core: CoreDbContext<S>,
      io: OnDemandIO<S>
    ): OnDemandDbContext<S> {
      const query = (): OnDemandQueryBuilder<S> => ({
        from: <TName extends keyof S['tables']>(tableName: TName): OnDemandChainedQueryBuilder<S, TName, S['base'][TName]> => {
          const createBuilder = <TReturn>(currentDescriptor: QueryDescriptor): OnDemandChainedQueryBuilder<S, TName, TReturn> => ({
            select(fields) { return createBuilder<TReturn>({ ...currentDescriptor, select: fields }); },
            where(predicate) { return createBuilder<TReturn>({ ...currentDescriptor, where: normalizePredicate(predicate as Parameters<typeof normalizePredicate>[0]) }); },
            withDeleted() { return createBuilder<TReturn>({ ...currentDescriptor, withDeleted: true }); },
            with<W extends WithArgument<S['types'][TName]>>(relations: W) {
              const newWith = { ...currentDescriptor.with, ...(relations as QueryDescriptor['with']) };
              return createBuilder<TReturn & ResolveWith<S, TName, W>>({ ...currentDescriptor, with: newWith });
            },
            limit(count) { return createBuilder<TReturn>({ ...currentDescriptor, limit: count }); },
            offset(count) { return createBuilder<TReturn>({ ...currentDescriptor, offset: count }); },
            all: async (): Promise<TReturn[]> => {
              const state = await io.getFullState();
              return _queryImpl(state, schema, currentDescriptor) as TReturn[];
            },
            first: async (): Promise<TReturn | null> => {
              const state = await io.getFullState();
              return (_queryImpl(state, schema, { ...currentDescriptor, limit: 1 })[0] ?? null) as TReturn | null;
            },
            aggregate: async <TAggs extends Record<string, AggregationDefinition>>(aggregations: TAggs) => {
              const state = await io.getFullState();
              const aggDescriptor: AggregationDescriptor = { ...currentDescriptor, aggregations };
              return _aggregateImpl(state, schema, aggDescriptor) as { [K in keyof TAggs]: number | null };
            },
          });
          return createBuilder<S['base'][TName]>({ tableName: tableName as string });
        },
      });

      const insert = <T extends keyof S['tables']>(tableName: T, values: S['create'][T] | Readonly<S['create'][T]>[]): Promise<any> =>
        io.insert(core, tableName as string, values);

      const update = <T extends keyof S['tables']>(tableName: T): OnDemandUpdateBuilder<S['base'][T], S['create'][T]> => ({
        set: (data) => ({
          where: (predicate) => io.update(core, tableName as string, data, normalizePredicate(predicate as Parameters<typeof normalizePredicate>[0])) as Promise<S['base'][T][]>,
        }),
      });

      const del = <T extends keyof S['tables']>(tableName: T): OnDemandDeleteBuilder<S['base'][T]> => ({
        where: (predicate) => io.delete(core, tableName as string, normalizePredicate(predicate as Parameters<typeof normalizePredicate>[0])) as Promise<S['base'][T][]>,
      });

      const notSupported = (methodName: string) => () => Promise.reject(KonroError({ code: 'E400', methodName }));

      return {
        schema,
        adapter,
        createEmptyState: () => createEmptyStateImpl(schema),
        read: notSupported('read'),
        write: notSupported('write'),
        query,
        insert,
        update,
        delete: del
      };
    }



    // --- DATABASE FACTORY ---


    export function createDatabase<
      S extends KonroSchema<any, any>,
      TAdapter extends StorageAdapter,
    >(
      options: { schema: S; adapter: TAdapter }
    ): TAdapter['mode'] extends 'on-demand' ? OnDemandDbContext<S> :
    InMemoryDbContext<S>;

    export function createDatabase<S extends KonroSchema<any, any>>(
      options: { schema: S; adapter: StorageAdapter }
    ): DbContext<S> {
      const { schema, adapter } = options;
      const core = createCoreDbContext(schema);

      // --- In-Memory Mode ---
      if (adapter.mode === 'in-memory') {
        return {
          ...core,
          schema, adapter,
          read: () => adapter.read(schema),
          write: (state) => adapter.write(state, schema),
          createEmptyState: () => createEmptyStateImpl(schema),
        } as InMemoryDbContext<S>;
      }

      // --- On-Demand Mode ---
      const fileAdapter = adapter as FileStorageAdapter; // We can be sure it's a FileStorageAdapter due to checks
      const { fs, serializer, fileExtension } = fileAdapter;

      // The `read` method from the adapter provides the canonical way to get the full state.
      const getFullState = (): Promise<DatabaseState<S>> => adapter.read(schema);
      
      // --- I/O Strategy for Multi-File ---
      const createMultiFileIO = (): OnDemandIO<S> => {
        const { dir } = fileAdapter.options.multi!;
        const getTablePath = (tableName: string) => path.join(dir, `${tableName}${fileExtension}`);

        const readTableState = async (tableName: string): Promise<TableState> => {
          const data = await fs.readFile(getTablePath(tableName));
          if (!data) return { records: [], meta: { lastId: 0 } };
          try {
            return serializer.parse(data, schema.tables[tableName]);
          } catch (e: any) {
            throw KonroStorageError({ code: 'E103', filepath: getTablePath(tableName), format: fileExtension.slice(1), details: e.message });
          }
        };

        const writeTableState = async (tableName: string, tableState: TableState): Promise<void> => {
          await fs.mkdir(dir, { recursive: true });
          await writeAtomic(getTablePath(tableName), serializer.stringify(tableState), fs);
        };

        return {
          getFullState,
          insert: async (core, tableName, values) => {
            const state = createEmptyStateImpl(schema);
            (state as any)[tableName] = await readTableState(tableName);
            const [newState, result] = core.insert(state, tableName as keyof S['tables'], values as any);
            await writeTableState(tableName, newState[tableName]!);
            return result;
          },
          update: async (core, tableName, data, predicate) => {
            const state = createEmptyStateImpl(schema);
            (state as any)[tableName] = await readTableState(tableName);
            const [newState, result] = core.update(state, tableName as keyof S["tables"]).set(data as any).where(predicate);
            if (result.length > 0) await writeTableState(tableName, newState[tableName]!);
            return result as any;
          },
          delete: async (core, tableName, predicate) => {
            const state = await getFullState(); // Cascades require full state
            const [newState, deletedRecords] = core.delete(state, tableName as keyof S["tables"]).where(predicate);
            const changedTables = Object.keys(newState).filter(k => newState[k as keyof typeof newState] !== state[k as keyof typeof state]);
            await Promise.all(changedTables.map(t => writeTableState(t, newState[t as keyof typeof newState]!)));
            return deletedRecords as any;
          },
        };
      };

      // --- I/O Strategy for Per-Record ---
      const createPerRecordIO = (): OnDemandIO<S> => {
        const { dir } = fileAdapter.options.perRecord!;
        const getTableDir = (tableName: string) => path.join(dir, tableName);
        const getRecordPath = (tableName: string, id: any) => path.join(getTableDir(tableName), `${id}${fileExtension}`);
        const getMetaPath = (tableName: string) => path.join(getTableDir(tableName), '_meta.json');
        const getIdColumn = (tableName: string) => {
          const col = Object.keys(schema.tables[tableName]).find(k => schema.tables[tableName][k]?.dataType === 'id');
          if (!col) throw KonroError({ code: 'E202', tableName });
          return col;
        };

        return {
          getFullState,
          insert: async (core, tableName, values) => {
            const metaContent = await fs.readFile(getMetaPath(tableName)).catch(() => null);
            const meta = metaContent ? JSON.parse(metaContent) : { lastId: 0 };
            const idCol = getIdColumn(tableName);

            // Perform insert without existing records for performance
            const [newState, inserted] = core.insert({ [tableName]: { records: [], meta } } as any, tableName as keyof S['tables'], values as any);
            const insertedArr = Array.isArray(inserted) ? inserted : (inserted ? [inserted] : []);
            if (insertedArr.length === 0) return inserted;

            // Write new records and update meta if it changed
            await fs.mkdir(getTableDir(tableName), { recursive: true });
            const newMeta = newState[tableName]?.meta;
            const promises = insertedArr.map((r) => writeAtomic(getRecordPath(tableName, r[idCol]), serializer.stringify(r), fs));
            if (newMeta && newMeta.lastId !== meta.lastId) {
              promises.push(writeAtomic(getMetaPath(tableName), JSON.stringify(newMeta, null, 2), fs));
            }
            await Promise.all(promises);
            return inserted;
          },
          update: async (core, tableName, data, predicate) => {
            const state = await getFullState(); // Update needs full table state for predicate
            const [newState, updated] = core.update(state, tableName as keyof S["tables"]).set(data as any).where(predicate);
            if (updated.length === 0) return updated as any;

            const idCol = getIdColumn(tableName);
            await Promise.all(updated.map((r: any) => writeAtomic(getRecordPath(tableName, r[idCol]), serializer.stringify(r), fs)));
            
            const newMeta = newState[tableName]?.meta;
            const oldMeta = state[tableName as keyof typeof state]?.meta;
            if (newMeta && JSON.stringify(newMeta) !== JSON.stringify(oldMeta)) {
                await writeAtomic(getMetaPath(tableName), JSON.stringify(newMeta, null, 2), fs);
            }
            return updated as any;
          },
          delete: async (core, tableName, predicate) => {
            const oldState = await getFullState();
            const [newState, deletedRecords] = core.delete(oldState, tableName as keyof S["tables"]).where(predicate);
            if (deletedRecords.length === 0) return deletedRecords as any;

            const changes = Object.keys(schema.tables).map(async tName => {
              const oldTState = oldState[tName as keyof typeof oldState]!;
              const newTState = newState[tName as keyof typeof newState]!;
              if (oldTState === newTState) return;

              const idCol = getIdColumn(tName);
              const oldMap = new Map(oldTState.records.map((r: any) => [r[idCol], r]));
              const newMap = new Map(newTState.records.map((r: any) => [r[idCol], r]));
              
              const promises: Promise<void>[] = [];
              if (JSON.stringify(oldTState.meta) !== JSON.stringify(newTState.meta)) {
                promises.push(fs.mkdir(getTableDir(tName), { recursive: true }).then(() =>
                  writeAtomic(getMetaPath(tName), JSON.stringify(newTState.meta, null, 2), fs))
                );
              }
              newMap.forEach((rec, id) => {
                if (oldMap.get(id) !== rec) promises.push(writeAtomic(getRecordPath(tName, id), serializer.stringify(rec), fs));
              });
              oldMap.forEach((_rec, id) => {
                if (!newMap.has(id)) promises.push(fs.unlink(getRecordPath(tName, id)));
              });
              await Promise.all(promises);
            });

            await Promise.all(changes);
            return deletedRecords as any;
          },
        };
      };

      const io = fileAdapter.options.multi ? createMultiFileIO() : fileAdapter.options.perRecord ? createPerRecordIO() : null;
      if (!io) {
        throw KonroError({ code: 'E104' });
      }
      
      return createOnDemandDbContext(schema, adapter, core, io);
    }
approved: true

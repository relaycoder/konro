uuid: 44e3776a-eb2b-42c2-84b2-a4f66a1a45bd
projectId: konro
createdAt: '2025-07-09T06:27:26.486Z'
linesAdded: 318
linesRemoved: 89
gitCommitMsg: 'feat: implement managed timestamps and cascading deletes'
promptSummary: >-
  Implement createdAt, updatedAt, deletedAt timestamps and cascading soft/hard
  deletes.
reasoning:
  - >-
    Here are the modifications to implement `createdAt`, `updatedAt`, and
    `deletedAt` timestamps, along with cascading soft/hard deletes.
  - '### Step-by-step reasoning:'
  - 1.  **Schema Enhancements (`src/schema.ts` & `src/index.ts`):**
  - >-
    *   I've introduced three new column helpers: `createdAt()`, `updatedAt()`,
    and `deletedAt()`. These are specialized date columns identifiable by an
    internal `_konro_sub_type` option. `deletedAt` is nullable to distinguish
    between active and soft-deleted records.
  - >-
    *   To support cascading deletes, I've added an optional `onDelete` property
    (`'CASCADE'` or `'SET NULL'`) to the `one()` and `many()` relation helpers.
    The underlying `BaseRelationDefinition` type is updated to reflect this.
  - >-
    *   These new helpers are exported from the main `konro` object in
    `src/index.ts` for public use.
  - 2.  **Core Operations Logic (`src/operations.ts`):**
  - >-
    *   **`_updateImpl`:** Now automatically sets the `updatedAt` timestamp on
    any record being modified if an `updatedAt` column exists in the schema.
  - >-
    *   **`QueryDescriptor` & `_queryImpl`:** I've added a `withDeleted` flag to
    the query descriptor. By default, `_queryImpl` now automatically filters out
    any records where `deletedAt` is set (i.e., soft-deleted records). This
    behavior can be overridden on a per-query basis.
  - >-
    *   **`_deleteImpl` & Cascades:** This function has been significantly
    reworked.
  - >-
    *   Its signature now requires the `schema` to inspect column and relation
    definitions.
  - >-
    *   It checks for a `deletedAt` column. If present, it performs a **soft
    delete** by setting the timestamp. Otherwise, it performs a **hard delete**
    by removing the record.
  - >-
    *   A new helper function, `applyCascades`, is introduced. After a record is
    deleted (softly or otherwise), this function inspects its relationships. If
    an `onDelete` policy is defined on a `many` relation, it recursively calls
    `_deleteImpl` (for `CASCADE`) or `_updateImpl` (for `SET NULL`) on the
    related records, ensuring the entire operation is atomic with respect to the
    database state.
  - 3.  **Database Context (`src/db.ts`):**
  - >-
    *   The `delete` operations now correctly pass the `schema` to
    `_deleteImpl`.
  - >-
    *   The fluent query builders (`ChainedQueryBuilder` and
    `OnDemandChainedQueryBuilder`) now have a `withDeleted()` method to include
    soft-deleted records in query results.
  - >-
    *   The `delete` implementation for **on-demand mode** has been updated.
    Since cascades can affect multiple tables, the `delete` operation must now
    fetch the full database state, apply the changes, and then intelligently
    write back only the modified tables/records. This is a necessary trade-off
    to ensure data integrity.
  - 4.  **Testing (`test/unit/Core/Delete.test.ts`):**
  - >-
    *   The existing delete tests are updated to match the new `_deleteImpl`
    signature, using a mock schema.
  - >-
    *   I've added new test cases to verify the correctness of soft deletes and
    cascading deletes, ensuring the new functionality is working as expected.
  - >-
    These changes introduce powerful, automatic data management features while
    maintaining the library's core principles of type safety and immutability.
  - '---'
operations:
  - type: write
    path: src/schema.ts
    content: >-
      --- src/schema.ts

      +++ src/schema.ts

      @@ -102,9 +102,10 @@
         readonly targetTable: string;
         readonly on: string;
         readonly references: string;
      +  readonly onDelete?: 'CASCADE' | 'SET NULL';
       }
       
       export interface OneRelationDefinition extends BaseRelationDefinition {
         readonly relationType: 'one';
       }
       
      @@ -176,14 +177,16 @@
       export const number = (options?: { unique?: boolean; default?: number | (() => number); min?: number; max?: number; type?: 'integer' }) => createColumn<number>('number', options, 0);
       /** A boolean column. */
       export const boolean = (options?: { default?: boolean | (() => boolean) }) => createColumn<boolean>('boolean', options, false);
      -/** A date column, stored as an ISO string but hydrated as a Date object.
      */

      +/** A generic date column. Consider using `createdAt` or `updatedAt` for
      managed timestamps. */
       export const date = (options?: { default?: Date | (() => Date) }) => createColumn<Date>('date', options, new Date());
      +/** A managed timestamp set when a record is created. */

      +export const createdAt = (): ColumnDefinition<Date> =>
      createColumn<Date>('date', { _konro_sub_type: 'createdAt', default: () =>
      new Date() }, new Date());

      +/** A managed timestamp set when a record is created and updated. */

      +export const updatedAt = (): ColumnDefinition<Date> =>
      createColumn<Date>('date', { _konro_sub_type: 'updatedAt', default: () =>
      new Date() }, new Date());

      +/** A managed, nullable timestamp for soft-deleting records. */

      +export const deletedAt = (): ColumnDefinition<Date | null> =>
      createColumn<Date | null>('date', { _konro_sub_type: 'deletedAt', default:
      null }, null);
       /** A column for storing arbitrary JSON objects, with a generic for type safety. */
       export const object = <T extends Record<string, any>>(options?: { default?: T | (() => T) }): ColumnDefinition<T> => ({ _type: 'column', dataType: 'object', options });
       
       
      @@ -191,14 +194,14 @@
       // --- RELATIONSHIP DEFINITION HELPERS ---
       
       /** Defines a `one-to-one` or `many-to-one` relationship. */
      -export const one = <T extends string>(targetTable: T, options: { on:
      string; references: string }): OneRelationDefinition & { targetTable: T }
      => ({

      +export const one = <T extends string>(targetTable: T, options: { on:
      string; references: string; onDelete?: 'CASCADE' | 'SET NULL' }):
      OneRelationDefinition & { targetTable: T } => ({
         _type: 'relation',
         relationType: 'one',
         targetTable,
         ...options,
       });
       
       /** Defines a `one-to-many` relationship. */
      -export const many = <T extends string>(targetTable: T, options: { on:
      string; references: string }): ManyRelationDefinition & { targetTable: T }
      => ({

      +export const many = <T extends string>(targetTable: T, options: { on:
      string; references: string; onDelete?: 'CASCADE' | 'SET NULL' }):
      ManyRelationDefinition & { targetTable: T } => ({
         _type: 'relation',
         relationType: 'many',
         targetTable,
    patchStrategy: new-unified
  - type: write
    path: src/index.ts
    content: >-
      --- src/index.ts

      +++ src/index.ts

      @@ -1,5 +1,5 @@
       import { createDatabase } from './db';
       import { createFileAdapter } from './adapter';
      -import { createSchema, id, uuid, string, number, boolean, date, object,
      one, many, count, sum, avg, min, max } from './schema';

      +import { createSchema, id, uuid, string, number, boolean, date,
      createdAt, updatedAt, deletedAt, object, one, many, count, sum, avg, min,
      max } from './schema';
       
       /**
        * The main Konro object, providing access to all core functionalities
      @@ -27,6 +27,9 @@
         number,
         boolean,
         date,
      +  createdAt,

      +  updatedAt,

      +  deletedAt,
         object,
         // --- Relationship Definition Helpers ---
         one,
    patchStrategy: new-unified
  - type: write
    path: src/operations.ts
    content: >-
      --- src/operations.ts

      +++ src/operations.ts

      @@ -22,6 +22,7 @@
         where?: (record: KRecord) => boolean;
         with?: WithClause;
         limit?: number;
         offset?: number;
      +  withDeleted?: boolean;
       }
       
       export interface AggregationDescriptor extends QueryDescriptor {
      @@ -113,10 +114,23 @@
         const tableState = state[descriptor.tableName];
         if (!tableState) return [];
       
      -  // 1. Filter

      -  let results = descriptor.where ?
      tableState.records.filter(descriptor.where) : [...tableState.records];

      -

      -  // 2. Eager load relations (`with`)

      +  const tableSchema = schema.tables[descriptor.tableName];

      +  if (!tableSchema) throw KonroError(`Schema for table
      "${descriptor.tableName}" not found.`);

      +  const deletedAtColumn = Object.keys(tableSchema).find(key =>
      tableSchema[key]?.options?._konro_sub_type === 'deletedAt');

      +

      +  // 1. Filter

      +  let results: KRecord[];

      +

      +  // Auto-filter soft-deleted records unless opted-out

      +  if (deletedAtColumn && !descriptor.withDeleted) {

      +    results = tableState.records.filter(r => r[deletedAtColumn] === null
      || r[deletedAtColumn] === undefined);

      +  } else {

      +    results = [...tableState.records];

      +  }

      +  

      +  results = descriptor.where ? results.filter(descriptor.where) :
      results;

      +

      +  // 2. Eager load relations (`with`) - must happen after filtering
         if (descriptor.with) {
           results = 
       _processWith(results, descriptor.tableName, descriptor.with, schema, state);
      @@ -128,8 +142,6 @@
       
         // 4. Select Fields
         if (descriptor.select) {
      -    const tableSchema = schema.tables[descriptor.tableName];
           const relationsSchema = schema.relations[descriptor.tableName] ?? {};
      -    if (!tableSchema) throw KonroError(`Schema for table
      "${descriptor.tableName}" not found.`);
       
           paginatedResults = paginatedResults.map(rec => {
             const newRec: KRecord = {};
      @@ -262,6 +274,13 @@
       
         const updatedRecords: KRecord[] = [];
       
      +  // Auto-update 'updatedAt' timestamp

      +  for (const colName of Object.keys(tableSchema)) {

      +      if (tableSchema[colName]?.options?._konro_sub_type === 'updatedAt')
      {

      +          (data as KRecord)[colName] = new Date();

      +      }

      +  }

      +
         const updateData = { ...data };
         // Find the ID column from the schema and prevent it from being updated.
         const idColumn = Object.entries(tableSchema).find(([, colDef]) => {
      @@ -298,28 +317,91 @@
       
       // --- DELETE ---
       
      -export const _deleteImpl = (state: DatabaseState, tableName: string,
      predicate: (record: KRecord) => boolean): [DatabaseState, KRecord[]] => {

      +function applyCascades<S extends KonroSchema<any, any>>(

      +  state: DatabaseState<S>,

      +  schema: S,

      +  tableName: string,

      +  deletedRecords: KRecord[]

      +): DatabaseState<S> {

      +  if (deletedRecords.length === 0) {

      +    return state;

      +  }

      +

      +  let nextState = state;

      +  const relations = schema.relations[tableName] ?? {};

      +

      +  for (const relationName in relations) {

      +    const relationDef = relations[relationName];

      +    // We only cascade from the "one" side of a one-to-many relationship,
      which is a 'many' type in Konro.

      +    if (!relationDef || relationDef.relationType !== 'many' ||
      !relationDef.onDelete) {

      +      continue;

      +    }

      +

      +    const sourceKey = relationDef.on;

      +    const targetTable = relationDef.targetTable;

      +    const targetKey = relationDef.references;

      +

      +    const sourceKeyValues = deletedRecords.map(r =>
      r[sourceKey]).filter(v => v !== undefined);

      +    if (sourceKeyValues.length === 0) continue;

      +

      +    const sourceKeySet = new Set(sourceKeyValues);

      +    const predicate = (record: KRecord) =>
      sourceKeySet.has(record[targetKey]);

      +

      +    if (relationDef.onDelete === 'CASCADE') {

      +      // Recursively delete

      +      const [newState, ] = _deleteImpl(nextState, schema, targetTable,
      predicate);

      +      nextState = newState;

      +    } else if (relationDef.onDelete === 'SET NULL') {

      +      // Update FK to null

      +      const [newState, ] = _updateImpl(nextState, schema, targetTable, {
      [targetKey]: null }, predicate);

      +      nextState = newState;

      +    }

      +  }

      +

      +  return nextState;

      +}

      +

      +export const _deleteImpl = (state: DatabaseState, schema:
      KonroSchema<any, any>, tableName: string, predicate: (record: KRecord) =>
      boolean): [DatabaseState, KRecord[]] => {
         const oldTableState = state[tableName];
         if (!oldTableState) throw KonroError(`Table "${tableName}" does not exist in the database state.`);
      -  const deletedRecords: KRecord[] = [];

      -

      -  const keptRecords = oldTableState.records.filter(record => {

      -    if (predicate(record)) {

      -      deletedRecords.push(record);

      -      return false;

      -    }

      -    return true;

      -  });

      -

      -  if (deletedRecords.length === 0) {

      -    return [state, []];

      -  }

      -

      -  const tableState = { ...oldTableState, records: keptRecords };

      -  const newState = { ...state, [tableName]: tableState };

      -  return [newState, deletedRecords];

      +  const tableSchema = schema.tables[tableName];

      +  if (!tableSchema) throw KonroError(`Schema for table "${tableName}" not
      found.`);

      +

      +  const deletedAtColumn = Object.keys(tableSchema).find(key =>
      tableSchema[key]?.options?._konro_sub_type === 'deletedAt');

      +

      +  // Soft delete path

      +  if (deletedAtColumn) {

      +    const recordsToUpdate: KRecord[] = [];

      +    const now = new Date();

      +

      +    const newRecords = oldTableState.records.map(record => {

      +      if (!record[deletedAtColumn] && predicate(record)) { // Not already
      soft-deleted and matches predicate

      +        const updatedRecord = { ...record, [deletedAtColumn]: now };

      +        recordsToUpdate.push(updatedRecord);

      +        return updatedRecord;

      +      }

      +      return record;

      +    });

      +

      +    if (recordsToUpdate.length === 0) return [state, []];

      +

      +    const baseState = { ...state, [tableName]: { ...oldTableState,
      records: newRecords } };

      +    const finalState = applyCascades(baseState, schema, tableName,
      recordsToUpdate);

      +    

      +    // The returned records are the ones that were just soft-deleted from
      this table.

      +    return [finalState, recordsToUpdate];

      +  } 

      +  

      +  // Hard delete path

      +  const recordsToDelete: KRecord[] = [];

      +  const keptRecords = oldTableState.records.filter(r => predicate(r) ?
      (recordsToDelete.push(r), false) : true);

      +

      +  if (recordsToDelete.length === 0) return [state, []];

      +

      +  const baseState = { ...state, [tableName]: { ...oldTableState, records:
      keptRecords } };

      +  const finalState = applyCascades(baseState, schema, tableName,
      recordsToDelete);

      +

      +  return [finalState, recordsToDelete];
       };
       
       // --- VALIDATION ---
    patchStrategy: new-unified
  - type: write
    path: test/unit/Core/Delete.test.ts
    content: |-
      import { describe, it, expect, beforeEach } from 'bun:test';
      import { _deleteImpl } from '../../../src/operations';
      import { DatabaseState, KRecord } from '../../../src/types';
      import { KonroSchema } from '../../../src/schema';

      describe('Unit > Core > Delete', () => {
          let testState: DatabaseState;
          const mockSchema: KonroSchema<any, any> = {
              tables: {
                  users: { 
                      id: { dataType: 'id' } as any, 
                      name: {} as any, 
                      email: {} as any, 
                      age: {} as any, 
                      deletedAt: { options: { _konro_sub_type: 'deletedAt' } } as any 
                  },
                  posts: { 
                      id: { dataType: 'id' } as any, 
                      title: {} as any, 
                      userId: {} as any 
                  },
                  profiles: { records: [], meta: { lastId: 0 } },
                  tags: { records: [], meta: { lastId: 0 } },
                  posts_tags: { records: [], meta: { lastId: 0 } },
              },
              relations: {
                  users: {
                      posts: { 
                          _type: 'relation', 
                          relationType: 'many', 
                          targetTable: 'posts', 
                          on: 'id', 
                          references: 'userId', 
                          onDelete: 'CASCADE' 
                      }
                  }
              },
              types: {} as any,
              base: {} as any,
              create: {} as any,
          };
          
          const hardDeleteSchema: KonroSchema<any, any> = {
              ...mockSchema,
              tables: {
                  ...mockSchema.tables,
                  users: { id: { dataType: 'id' } as any, name: {} as any, email: {} as any, age: {} as any },
              }
          };

          beforeEach(() => {
              testState = {
                  users: {
                      records: [
                          { id: 1, name: 'Alice', email: 'a@a.com', age: 30, deletedAt: null },
                          { id: 2, name: 'Bob', email: 'b@b.com', age: 25, deletedAt: null },
                          { id: 3, name: 'Charlie', email: 'c@c.com', age: 42, deletedAt: null },
                      ],
                      meta: { lastId: 3 },
                  },
                  posts: { 
                      records: [
                          { id: 101, title: 'Post A', userId: 1 },
                          { id: 102, title: 'Post B', userId: 2 },
                          { id: 103, title: 'Post C', userId: 1 },
                      ], 
                      meta: { lastId: 103 } 
                  },
                  profiles: { records: [], meta: { lastId: 0 } },
                  tags: { records: [], meta: { lastId: 0 } },
                  posts_tags: { records: [], meta: { lastId: 0 } },
              };
          });

          it('should return a new state object, not mutate the original state, on hard delete', () => {
              const originalState = structuredClone(testState);
              const [newState] = _deleteImpl(testState, hardDeleteSchema, 'users', (r) => r.id === 1);
              
              expect(newState).not.toBe(originalState);
              expect(originalState.users!.records.length).toBe(3);
              expect(newState.users!.records.length).toBe(2);
          });

          it('should only hard delete records that match the predicate function', () => {
              const [newState, deleted] = _deleteImpl(testState, hardDeleteSchema, 'users', (r) => typeof r.age === 'number' && r.age > 35);
              
              expect(deleted.length).toBe(1);
              expect(deleted[0]!.id).toBe(3);
              expect(newState.users!.records.length).toBe(2);
              expect(newState.users!.records.find(u => u.id === 3)).toBeUndefined();
          });

          it('should return both the new state and an array of the full, hard-deleted records in the result tuple', () => {
              const [newState, deleted] = _deleteImpl(testState, hardDeleteSchema, 'users', (r) => r.id === 2);

              expect(newState).toBeDefined();
              expect(deleted).toBeInstanceOf(Array);
              expect(deleted.length).toBe(1);
              expect(deleted[0]!).toEqual({ id: 2, name: 'Bob', email: 'b@b.com', age: 25, deletedAt: null });
          });

          it('should not modify the table meta lastId on delete', () => {
              const [newState] = _deleteImpl(testState, hardDeleteSchema, 'users', (r) => r.id === 3);
              expect(newState.users!.meta.lastId).toBe(3);
          });

          it('should soft delete a record by setting deletedAt if the column exists in schema', () => {
              const [newState, deleted] = _deleteImpl(testState, mockSchema, 'users', (r) => r.id === 2);

              expect(newState.users!.records.length).toBe(3); // Record is not removed
              const deletedUser = newState.users!.records.find(u => u.id === 2);
              expect(deletedUser?.deletedAt).toBeInstanceOf(Date);
              
              expect(deleted.length).toBe(1);
              expect(deleted[0]!.id).toBe(2);
              expect(deleted[0]!.deletedAt).toEqual(deletedUser?.deletedAt);
          });

          it('should not soft delete an already soft-deleted record', () => {
              (testState.users!.records[1] as KRecord).deletedAt = new Date('2024-01-01');
              const [newState, deleted] = _deleteImpl(testState, mockSchema, 'users', (r) => r.id === 2);

              expect(newState).toBe(testState); // Should return original state as nothing changed
              expect(deleted.length).toBe(0);
              expect((newState.users!.records[1] as KRecord).deletedAt).toEqual(new Date('2024-01-01'));
          });

          it('should perform a cascading delete on related records', () => {
              const [newState, deletedUsers] = _deleteImpl(testState, mockSchema, 'users', (r) => r.id === 1);
              
              expect(deletedUsers.length).toBe(1);
              expect(newState.users!.records.find(u => u.id === 1)?.deletedAt).toBeInstanceOf(Date);
              
              // Check that posts by user 1 are also gone (hard delete, as posts have no deletedAt)
              const postsForUser1 = newState.posts!.records.filter(p => p.userId === 1);
              expect(postsForUser1.length).toBe(0);

              // Check that other posts are unaffected
              expect(newState.posts!.records.length).toBe(1);
              expect(newState.posts!.records[0]!.id).toBe(102);
          });
      });
    patchStrategy: replace
  - type: write
    path: src/db.ts
    content: >-
      --- src/db.ts

      +++ src/db.ts

      @@ -28,6 +28,7 @@
       interface ChainedQueryBuilder<S extends KonroSchema<any, any>, TName extends keyof S['tables'], TReturn> {
         select(fields: Record<string, ColumnDefinition<unknown> | RelationDefinition>): this;
         where(predicate: Partial<S['base'][TName]> | ((record: S['base'][TName]) => boolean)): this;
      +  withDeleted(): this;
         with<W extends WithArgument<S['types'][TName]>>(relations: W): ChainedQueryBuilder<S, TName, TReturn & ResolveWith<S, TName, W>>;
         limit(count: number): this;
         offset(count: number): this;
      @@ -69,6 +70,7 @@
       interface OnDemandChainedQueryBuilder<S extends KonroSchema<any, any>, TName extends keyof S['tables'], TReturn> {
         select(fields: Record<string, ColumnDefinition<unknown> | RelationDefinition>): this;
         where(predicate: Partial<S['base'][TName]> | ((record: S['base'][TName]) => boolean)): this;
      +  withDeleted(): this;
         with<W extends WithArgument<S['types'][TName]>>(relations: W): OnDemandChainedQueryBuilder<S, TName, TReturn & ResolveWith<S, TName, W>>;
         limit(count: number): this;
         offset(count: number): this;
      @@ -118,6 +120,7 @@
             const createBuilder = <TReturn>(currentDescriptor: QueryDescriptor): ChainedQueryBuilder<S, TName, TReturn> => ({
               select(fields) { return createBuilder<TReturn>({ ...currentDescriptor, select: fields }); },
               where(predicate) { return createBuilder<TReturn>({ ...currentDescriptor, where: normalizePredicate(predicate as any) }); },
      +        withDeleted() { return createBuilder<TReturn>({
      ...currentDescriptor, withDeleted: true }); },
               with<W extends WithArgument<S['types'][TName]>>(relations: W) {
                 const newWith = { ...currentDescriptor.with, ...(relations as QueryDescriptor['with']) };
                 return createBuilder<TReturn & ResolveWith<S, TName, W>>({ ...currentDescriptor, with: newWith });
      @@ -147,7 +150,7 @@
       
         const del = <T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T): DeleteBuilder<S, S['base'][T]> => ({
           where: (predicate) => {
      -      const [newState, deletedRecords] = _deleteImpl(state as
      DatabaseState, tableName as string, normalizePredicate(predicate as any));

      +      const [newState, deletedRecords] = _deleteImpl(state as
      DatabaseState, schema, tableName as string, normalizePredicate(predicate
      as any));
             return [newState as DatabaseState<S>, deletedRecords as S['base'][T][]];
           },
         });
      @@ -216,6 +219,7 @@
             const createBuilder = <TReturn>(currentDescriptor: QueryDescriptor): OnDemandChainedQueryBuilder<S, TName, TReturn> => ({
               select(fields) { return createBuilder<TReturn>({ ...currentDescriptor, select: fields }); },
               where(predicate) { return createBuilder<TReturn>({ ...currentDescriptor, where: normalizePredicate(predicate as any) }); },
      +        withDeleted() { return createBuilder<TReturn>({
      ...currentDescriptor, withDeleted: true }); },
               with<W extends WithArgument<S['types'][TName]>>(relations: W) {
                 const newWith = { ...currentDescriptor.with, ...(relations as QueryDescriptor['with']) };
                 return createBuilder<TReturn & ResolveWith<S, TName, W>>({ ...currentDescriptor, with: newWith });
      @@ -248,7 +252,20 @@
         });
       
         const del = <T extends keyof S['tables']>(tableName: T): OnDemandDeleteBuilder<S['base'][T]> => ({
      -    where: (predicate) => performCud(tableName as string, (state) =>
      core.delete(state, tableName).where(predicate as any)) as
      Promise<S['base'][T][]>,

      +    where: async (predicate) => {

      +      // Cascading deletes require the full state.

      +      const state = await getFullState();

      +      const [newState, deletedRecords] = core.delete(state,
      tableName).where(predicate as any);

      +

      +      // Find changed tables and write them back

      +      const changedTableNames = Object.keys(newState).filter(key =>
      newState[key as keyof typeof newState] !== state[key as keyof typeof
      state]);

      +      

      +      await Promise.all(

      +        changedTableNames.map(name => writeTableState(name, newState[name
      as keyof typeof newState]))

      +      );

      +

      +      return deletedRecords as S['base'][T][];

      +    },
         });
       
         const notSupported = () => Promise.reject(KonroError("This method is not supported in 'on-demand' mode."));
      @@ -348,6 +365,7 @@
             const createBuilder = <TReturn>(currentDescriptor: QueryDescriptor): OnDemandChainedQueryBuilder<S, TName, TReturn> => ({
               select(fields) { return createBuilder<TReturn>({ ...currentDescriptor, select: fields }); },
               where(predicate) { return createBuilder<TReturn>({ ...currentDescriptor, where: normalizePredicate(predicate as any) }); },
      +        withDeleted() { return createBuilder<TReturn>({
      ...currentDescriptor, withDeleted: true }); },
               with<W extends WithArgument<S['types'][TName]>>(relations: W) {
                 const newWith = { ...currentDescriptor.with, ...(relations as QueryDescriptor['with']) };
                 return createBuilder<TReturn & ResolveWith<S, TName, W>>({ ...currentDescriptor, with: newWith });
      @@ -414,15 +432,46 @@
       
         const del = <T extends keyof S['tables']>(tableName: T): OnDemandDeleteBuilder<S['base'][T]> => ({
           where: async (predicate) => {
      -      const tableNameStr = tableName as string;

      -      const tableState = await readTableState(tableNameStr);

      -      const idColumn = getIdColumn(tableNameStr);

      -      const [, deletedRecords] = core.delete({ [tableNameStr]: tableState
      } as any, tableName).where(predicate as any);

      -

      -      if (deletedRecords.length > 0) {

      -        await Promise.all((deletedRecords as KRecord[]).map((rec) =>
      fs.unlink(getRecordPath(tableNameStr, rec[idColumn] as any))));

      -      }

      -      return deletedRecords as S['base'][T][];

      +      const state = await getFullState();

      +      const [newState, deletedRecords] = core.delete(state,
      tableName).where(predicate as any);

      +

      +      const changePromises: Promise<any>[] = [];

      +

      +      for (const tName of Object.keys(schema.tables)) {

      +        const oldTableState = state[tName as keyof typeof state]!;

      +        const newTableState = newState[tName as keyof typeof newState]!;

      +

      +        if (oldTableState === newTableState) continue;

      +

      +        const tableDir = getTableDir(tName);

      +        changePromises.push(fs.mkdir(tableDir, { recursive: true }));

      +

      +        if (JSON.stringify(oldTableState.meta) !==
      JSON.stringify(newTableState.meta)) {

      +          changePromises.push(writeMeta(tName, newTableState.meta));

      +        }

      +

      +        const tIdColumn = getIdColumn(tName);

      +        const oldRecordsMap = new Map(oldTableState.records.map(r =>
      [r[tIdColumn], r]));

      +        const newRecordsMap = new Map(newTableState.records.map(r =>
      [r[tIdColumn], r]));

      +        

      +        for (const [id, record] of newRecordsMap.entries()) {

      +            const oldRecord = oldRecordsMap.get(id);

      +            // Write if new or record object identity has changed

      +            if (!oldRecord || oldRecord !== record) {

      +                changePromises.push(writeAtomic(getRecordPath(tName, id
      as any), serializer.stringify(record), fs));

      +            }

      +        }

      +        

      +        for (const id of oldRecordsMap.keys()) {

      +            if (!newRecordsMap.has(id)) { // Deleted record

      +                changePromises.push(fs.unlink(getRecordPath(tName, id as
      any)));

      +            }

      +        }

      +      }

      +

      +      await Promise.all(changePromises);

      +

      +      return deletedRecords as S['base'][T][];
           },
         });
    patchStrategy: new-unified
snapshot:
  src/operations.ts: "import { randomUUID } from 'crypto';\r\nimport { DatabaseState, KRecord } from './types';\r\nimport { KonroSchema, RelationDefinition, ColumnDefinition, AggregationDefinition } from './schema';\r\nimport { KonroError, KonroValidationError } from './utils/error.util';\r\n\r\n// --- HELPERS ---\r\n\r\n\r\n/** Creates a pristine, empty database state from a schema. */\r\nexport const createEmptyState = <S extends KonroSchema<any, any>>(schema: S): DatabaseState<S> => {\r\n  const state = {} as DatabaseState<S>;\r\n  for (const tableName in schema.tables) {\r\n    // This is a controlled cast, safe because we are iterating over the schema's tables.\r\n    (state as any)[tableName] = { records: [], meta: { lastId: 0 } };\r\n  }\r\n  return state;\r\n};\r\n\r\n// --- QUERY ---\r\n\r\ninterface WithOptions {\r\n  select?: Record<string, ColumnDefinition<unknown>>;\r\n  where?: (record: KRecord) => boolean;\r\n  with?: WithClause;\r\n}\r\ntype WithClause = Record<string, boolean | WithOptions>;\r\n\r\nexport interface QueryDescriptor {\r\n  tableName: string;\r\n  select?: Record<string, ColumnDefinition<unknown> | RelationDefinition>;\r\n  where?: (record: KRecord) => boolean;\r\n  with?: WithClause;\r\n  limit?: number;\r\n  offset?: number;\r\n}\r\n\r\nexport interface AggregationDescriptor extends QueryDescriptor {\r\n  aggregations: Record<string, AggregationDefinition>;\r\n}\r\n\r\nconst _processWith = <S extends KonroSchema<any, any>>(\r\n  recordsToProcess: KRecord[],\r\n  currentTableName: string,\r\n  withClause: WithClause,\r\n  schema: S,\r\n  state: DatabaseState\r\n): KRecord[] => {\r\n  // structuredClone is important to avoid mutating the records from the previous recursion level or the main state.\r\n  const resultsWithRelations = structuredClone(recordsToProcess);\r\n\r\n  for (const record of resultsWithRelations) {\r\n    for (const relationName in withClause) {\r\n      const relationDef = schema.relations[currentTableName]?.[relationName];\r\n      if (!relationDef) continue;\r\n\r\n      const withOpts = withClause[relationName];\r\n      // Skip if the value is `false` or something not truthy (though types should prevent this)\r\n      if (!withOpts) continue;\r\n\r\n      const relatedRecords = findRelatedRecords(state, record, relationDef);\r\n\r\n      const nestedWhere = typeof withOpts === 'object' ? withOpts.where : undefined;\r\n      const nestedSelect = typeof withOpts === 'object' ? withOpts.select : undefined;\r\n      const nestedWith = typeof withOpts === 'object' ? withOpts.with : undefined;\r\n\r\n      let processedRelatedRecords = nestedWhere ? relatedRecords.filter(nestedWhere) : [...relatedRecords];\r\n\r\n      // Recursively process deeper relations first\r\n      if (nestedWith && processedRelatedRecords.length > 0) {\r\n        processedRelatedRecords = _processWith(\r\n          processedRelatedRecords,\r\n          relationDef.targetTable,\r\n          nestedWith,\r\n          schema,\r\n          state\r\n        );\r\n      }\r\n\r\n      // Then, apply select on the (potentially already processed) related records\r\n      if (nestedSelect) {\r\n        const targetTableSchema = schema.tables[relationDef.targetTable];\r\n        if (!targetTableSchema) throw KonroError(`Schema for table \"${relationDef.targetTable}\" not found.`);\r\n\r\n        processedRelatedRecords = processedRelatedRecords.map(rec => {\r\n          const newRec: KRecord = {};\r\n          for (const outputKey in nestedSelect) {\r\n            const def = nestedSelect[outputKey];\r\n            if (!def) continue;\r\n            // nested with() does not support selecting relations, only columns, as per spec.\r\n            if (def._type === 'column') {\r\n              const colName = Object.keys(targetTableSchema).find(key => targetTableSchema[key] === def);\r\n              if (colName && rec.hasOwnProperty(colName)) {\r\n                newRec[outputKey] = rec[colName];\r\n              }\r\n            }\r\n          }\r\n          return newRec;\r\n        });\r\n      }\r\n\r\n      // Finally, attach the results to the parent record\r\n      if (relationDef.relationType === 'one') {\r\n        record[relationName] = processedRelatedRecords[0] ?? null;\r\n      } else {\r\n        record[relationName] = processedRelatedRecords;\r\n      }\r\n    }\r\n  }\r\n\r\n  return resultsWithRelations;\r\n};\r\n\r\nexport const _queryImpl = <S extends KonroSchema<any, any>>(state: DatabaseState, schema: S, descriptor: QueryDescriptor): KRecord[] => {\r\n  const tableState = state[descriptor.tableName];\r\n  if (!tableState) return [];\r\n\r\n  // 1. Filter\r\n  let results = descriptor.where ? tableState.records.filter(descriptor.where) : [...tableState.records];\r\n\r\n  // 2. Eager load relations (`with`)\r\n  if (descriptor.with) {\r\n    results = \r_processWith(results, descriptor.tableName, descriptor.with, schema, state);\r\n  }\r\n\r\n  // 3. Paginate\r\n  const offset = descriptor.offset ?? 0;\r\n  const limit = descriptor.limit ?? results.length;\r\n  let paginatedResults = results.slice(offset, offset + limit);\r\n\r\n  // 4. Select Fields\r\n  if (descriptor.select) {\r\n    const tableSchema = schema.tables[descriptor.tableName];\r\n    const relationsSchema = schema.relations[descriptor.tableName] ?? {};\r\n    if (!tableSchema) throw KonroError(`Schema for table \"${descriptor.tableName}\" not found.`);\r\n\r\n    paginatedResults = paginatedResults.map(rec => {\r\n      const newRec: KRecord = {};\r\n      for (const outputKey in descriptor.select!) {\r\n        const def = descriptor.select![outputKey];\r\n        if (!def) continue;\r\n        if (def._type === 'column') {\r\n          const colName = Object.keys(tableSchema).find(key => tableSchema[key] === def);\r\n          if (colName && rec.hasOwnProperty(colName)) {\r\n            newRec[outputKey] = rec[colName];\r\n          }\r\n        } else if (def._type === 'relation') {\r\n          const relName = Object.keys(relationsSchema).find(key => relationsSchema[key] === def);\r\n          if (relName && rec.hasOwnProperty(relName)) {\r\n            newRec[outputKey] = rec[relName];\r\n          }\r\n        }\r\n      }\r\n      return newRec;\r\n    });\r\n  }\r\n\r\n  return paginatedResults;\r\n};\r\n\r\nconst findRelatedRecords = (state: DatabaseState, record: KRecord, relationDef: RelationDefinition) => {\r\n  const foreignKey = record[relationDef.on];\r\n  const targetTable = state[relationDef.targetTable];\r\n\r\n  if (foreignKey === undefined || !targetTable) return [];\r\n\r\n  // one-to-many: 'on' is PK on current table, 'references' is FK on target\r\n  if (relationDef.relationType === 'many') {\r\n    return targetTable.records.filter(r => r[relationDef.references] === foreignKey);\r\n  }\r\n\r\n  // many-to-one: 'on' is FK on current table, 'references' is PK on target\r\n  if (relationDef.relationType === 'one') {\r\n    return targetTable.records.filter(r => r[relationDef.references] === foreignKey);\r\n  }\r\n\r\n  return [];\r\n};\r\n\r\n// --- AGGREGATION ---\r\n\r\nexport const _aggregateImpl = <S extends KonroSchema<any, any>>(\r\n  state: DatabaseState,\r\n  _schema: S, // Not used but keep for API consistency\r\n  descriptor: AggregationDescriptor\r\n): Record<string, number | null> => {\r\n  const tableState = state[descriptor.tableName];\r\n  if (!tableState) return {};\r\n\r\n  const filteredRecords = descriptor.where ? tableState.records.filter(descriptor.where) : [...tableState.records];\r\n  const results: Record<string, number | null> = {};\r\n\r\n  for (const resultKey in descriptor.aggregations) {\r\n    const aggDef = descriptor.aggregations[resultKey];\r\n    if (!aggDef) continue;\r\n\r\n    if (aggDef.aggType === 'count') {\r\n      results[resultKey] = filteredRecords.length;\r\n      continue;\r\n    }\r\n\r\n    if (!aggDef.column) {\r\n      throw KonroError(`Aggregation '${aggDef.aggType}' requires a column.`);\r\n    }\r\n    const column = aggDef.column;\r\n\r\n    const values = filteredRecords.map(r => r[column]).filter(v => typeof v === 'number') as number[];\r\n\r\n    if (values.length === 0) {\r\n      if (aggDef.aggType === 'sum') {\r\n        results[resultKey] = 0; // sum of empty set is 0\r\n      } else {\r\n        results[resultKey] = null; // avg, min, max of empty set is null\r\n      }\r\n      continue;\r\n    }\r\n\r\n    switch (aggDef.aggType) {\r\n      case 'sum':\r\n        results[resultKey] = values.reduce((sum, val) => sum + val, 0);\r\n        break;\r\n      case 'avg':\r\n        results[resultKey] = values.reduce((sum, val) => sum + val, 0) / values.length;\r\n        break;\r\n      case 'min':\r\n        results[resultKey] = Math.min(...values);\r\n        break;\r\n      case 'max':\r\n        results[resultKey] = Math.max(...values);\r\n        break;\r\n    }\r\n  }\r\n  return results;\r\n};\r\n\r\n// --- INSERT ---\r\n\r\nexport const _insertImpl = <S extends KonroSchema<any, any>>(state: DatabaseState, schema: S, tableName: string, values: KRecord[]): [DatabaseState, KRecord[]] => {\r\n  const oldTableState = state[tableName];\r\n  if (!oldTableState) throw KonroError(`Table \"${tableName}\" does not exist in the database state.`);\r\n\r\n  // To maintain immutability, we deep-clone only the table being modified.\r\n  const tableState = structuredClone(oldTableState);\r\n  const tableSchema = schema.tables[tableName];\r\n  if (!tableSchema) throw KonroError(`Schema for table \"${tableName}\" not found.`);\r\n  const insertedRecords: KRecord[] = [];\r\n\r\n  for (const value of values) {\r\n    const newRecord: KRecord = { ...value };\r\n    // Handle IDs and defaults\r\n    for (const colName in tableSchema) {\r\n      const colDef = tableSchema[colName];\r\n      if (colDef.dataType === 'id') {\r\n        if (newRecord[colName] === undefined) {\r\n          // Generate new PK if not provided\r\n          if (colDef.options?._pk_strategy === 'uuid') {\r\n            newRecord[colName] = randomUUID();\r\n          } else { // 'auto-increment' or legacy undefined strategy\r\n            tableState.meta.lastId++;\r\n            newRecord[colName] = tableState.meta.lastId;\r\n          }\r\n        } else {\r\n          // If user provided an ID for an auto-increment table, update lastId to avoid future collisions.\r\n          if (colDef.options?._pk_strategy !== 'uuid' && typeof newRecord[colName] === 'number') {\r\n            tableState.meta.lastId = Math.max(tableState.meta.lastId, newRecord[colName] as number);\r\n          }\r\n        }\r\n      }\r\n      if (newRecord[colName] === undefined && colDef.options?.default !== undefined) {\r\n        newRecord[colName] = typeof colDef.options.default === 'function' ? colDef.options.default() : colDef.options.default;\r\n      }\r\n    }\r\n\r\n    // Validate the record before inserting\r\n    validateRecord(newRecord, tableSchema, tableState.records);\r\n\r\n    tableState.records.push(newRecord);\r\n    insertedRecords.push(newRecord);\r\n  }\r\n\r\n  const newState = { ...state, [tableName]: tableState };\r\n  return [newState, insertedRecords];\r\n};\r\n\r\n// --- UPDATE ---\r\n\r\nexport const _updateImpl = <S extends KonroSchema<any, any>>(state: DatabaseState, schema: S, tableName: string, data: Partial<KRecord>, predicate: (record: KRecord) => boolean): [DatabaseState, KRecord[]] => {\r\n  const oldTableState = state[tableName];\r\n  if (!oldTableState) throw KonroError(`Table \"${tableName}\" does not exist in the database state.`);\r\n\r\n  const tableSchema = schema.tables[tableName];\r\n  if (!tableSchema) {\r\n    throw KonroError(`Schema for table \"${tableName}\" not found.`);\r\n  }\r\n\r\n  const updatedRecords: KRecord[] = [];\r\n\r\n  const updateData = { ...data };\r\n  // Find the ID column from the schema and prevent it from being updated.\r\n  const idColumn = Object.entries(tableSchema).find(([, colDef]) => {\r\n    return colDef && typeof colDef === 'object' && '_type' in colDef && colDef._type === 'column' && 'dataType' in colDef && colDef.dataType === 'id';\r\n  })?.[0];\r\n  if (idColumn && updateData[idColumn] !== undefined) {\r\n    delete updateData[idColumn];\r\n  }\r\n\r\n  const newRecords = oldTableState.records.map(record => {\r\n    if (predicate(record)) {\r\n      const updatedRecord = { ...record, ...updateData };\r\n\r\n      // Validate the updated record, excluding current record from unique checks\r\n      const otherRecords = oldTableState.records.filter(r => r !== record);\r\n      validateRecord(updatedRecord, tableSchema, otherRecords);\r\n\r\n      updatedRecords.push(updatedRecord);\r\n      return updatedRecord;\r\n    }\r\n    return record;\r\n  });\r\n\r\n  if (updatedRecords.length === 0) {\r\n    return [state, []];\r\n  }\r\n\r\n  const tableState = { ...oldTableState, records: newRecords };\r\n  const newState = { ...state, [tableName]: tableState };\r\n\r\n  return [newState, updatedRecords];\r\n};\r\n\r\n\r\n// --- DELETE ---\r\n\r\nexport const _deleteImpl = (state: DatabaseState, tableName: string, predicate: (record: KRecord) => boolean): [DatabaseState, KRecord[]] => {\r\n  const oldTableState = state[tableName];\r\n  if (!oldTableState) throw KonroError(`Table \"${tableName}\" does not exist in the database state.`);\r\n  const deletedRecords: KRecord[] = [];\r\n\r\n  const keptRecords = oldTableState.records.filter(record => {\r\n    if (predicate(record)) {\r\n      deletedRecords.push(record);\r\n      return false;\r\n    }\r\n    return true;\r\n  });\r\n\r\n  if (deletedRecords.length === 0) {\r\n    return [state, []];\r\n  }\r\n\r\n  const tableState = { ...oldTableState, records: keptRecords };\r\n  const newState = { ...state, [tableName]: tableState };\r\n  return [newState, deletedRecords];\r\n};\r\n\r\n// --- VALIDATION ---\r\n\r\nconst validateRecord = (record: KRecord, tableSchema: Record<string, any>, existingRecords: KRecord[]): void => {\r\n  for (const [columnName, colDef] of Object.entries(tableSchema)) {\r\n    if (!colDef || typeof colDef !== 'object' || !('dataType' in colDef)) continue;\r\n\r\n    const value = record[columnName];\r\n    const options = colDef.options || {};\r\n\r\n    // Skip validation for undefined values (they should have defaults applied already)\r\n    if (value === undefined) continue;\r\n\r\n    // Validate unique constraint\r\n    if (options.unique && existingRecords.some(r => r[columnName] === value)) {\r\n      throw KonroValidationError(`Value '${String(value)}' for column '${columnName}' must be unique`);\r\n    }\r\n\r\n    // Validate string constraints\r\n    if (colDef.dataType === 'string' && typeof value === 'string') {\r\n      // Min length\r\n      if (options.min !== undefined && value.length < options.min) {\r\n        throw KonroValidationError(`String '${value}' for column '${columnName}' is too short (min: ${options.min})`);\r\n      }\r\n\r\n      // Max length\r\n      if (options.max !== undefined && value.length > options.max) {\r\n        throw KonroValidationError(`String '${value}' for column '${columnName}' is too long (max: ${options.max})`);\r\n      }\r\n\r\n      // Format validation\r\n      if (options.format === 'email' && !isValidEmail(value)) {\r\n        throw KonroValidationError(`Value '${value}' for column '${columnName}' is not a valid email`);\r\n      }\r\n    }\r\n\r\n    // Validate number constraints\r\n    if (colDef.dataType === 'number' && typeof value === 'number') {\r\n      // Min value\r\n      if (options.min !== undefined && value < options.min) {\r\n        throw KonroValidationError(`Number ${value} for column '${columnName}' is too small (min: ${options.min})`);\r\n      }\r\n\r\n      // Max value\r\n      if (options.max !== undefined && value > options.max) {\r\n        throw KonroValidationError(`Number ${value} for column '${columnName}' is too large (max: ${options.max})`);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nconst isValidEmail = (email: string): boolean => {\r\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n  return emailRegex.test(email);\r\n};\r\n"
  src/schema.ts: >-
    //

    // Konro: The Type-Safe, Functional ORM for JSON/YAML

    //

    // ## Pillar I: The Recipe (Schema Definition)

    //

    // This file contains the core logic for defining a database schema. It is
    designed to be

    // both the runtime source of truth for validation and the static source of
    truth for

    // TypeScript types. By using phantom types and inference, we can create a
    fully-typed

    // `db` object from a single schema definition object, eliminating the need
    for manual

    // type declarations (`interface User { ... }`) and ensuring they never get
    out of sync.

    //


    // --- TYPE INFERENCE HELPERS ---


    /** Infers the underlying TypeScript type from a `ColumnDefinition`. e.g.,
    `ColumnDefinition<string>` => `string`. */

    type InferColumnType<C> = C extends ColumnDefinition<infer T> ? T : never;


    /** A mapping of table names to their base model types (columns only, no
    relations). */

    export type BaseModels<TTables extends Record<string, any>> = {
      [TableName in keyof TTables]: {
        [ColumnName in keyof TTables[TableName]]: InferColumnType<TTables[TableName][ColumnName]>;
      };
    };


    /**
     * A mapping of table names to their full model types, including relations.
     * This is a recursive type that resolves relationships to other full models.
     */
    type Models<
      TTables extends Record<string, any>,
      TRelations extends Record<string, any>,
      TBaseModels extends Record<keyof TTables, any>
    > = {
      [TableName in keyof TTables]: TBaseModels[TableName] &
        (TableName extends keyof TRelations
          ? {
              [RelationName in keyof TRelations[TableName]]?: TRelations[TableName][RelationName] extends OneRelationDefinition
                ? // `targetTable` is a string literal, so we can use it to index `Models`
                  Models<TTables, TRelations, TBaseModels>[TRelations[TableName][RelationName]['targetTable']] | null
                : TRelations[TableName][RelationName] extends ManyRelationDefinition
                ? Models<TTables, TRelations, TBaseModels>[TRelations[TableName][RelationName]['targetTable']][]
                : never;
            }
          : {});
    };


    /** Finds all column names in a table definition that are optional for
    insertion (i.e., `id` or has a `default`). */

    /** Finds all column names in a table definition that are optional for
    insertion (i.e., `id` or has a `default`). */

    type OptionalCreateKeys<TTableDef> = {
      [K in keyof TTableDef]: TTableDef[K] extends { dataType: 'id' }
        ? K
        : TTableDef[K] extends { options: { default: any } }
        ? K
        : never;
    }[keyof TTableDef];


    /**
     * A mapping of table names to their "create" types, used for `db.insert`.
     * It takes the base model, makes keys with defaults optional, and removes the `id` field.
     */
    type CreateModels<
      TTables extends Record<string, any>,
      TBaseModels extends Record<keyof TTables, any>
    > = {
      [TableName in keyof TTables]: Omit<
        {
          // Required fields
          [K in Exclude<keyof TBaseModels[TableName], OptionalCreateKeys<TTables[TableName]>>]: TBaseModels[TableName][K];
        } & {
          // Optional fields
          [K in OptionalCreateKeys<TTables[TableName]>]?: TBaseModels[TableName][K];
        },
        // 'id' is always omitted from create types
        'id'
      >;
    };



    // --- PUBLIC API TYPES ---


    /** The publicly exposed structure of a fully-processed Konro schema. */

    export interface KonroSchema<
      TTables extends Record<string, any>,
      TRelations extends Record<string, any>
    > {
      tables: TTables;
      relations: TRelations;
      /** The full, relational types for each table model. */
      types: Models<TTables, TRelations, BaseModels<TTables>>;
      /** The base types for each table model, without any relations. */
      base: BaseModels<TTables>;
      /** The types for creating new records, with defaults and `id` made optional. */
      create: CreateModels<TTables, BaseModels<TTables>>;
    }


    /** The definition for a database column, created by helpers like
    `konro.string()`. */

    export interface ColumnDefinition<T> {
      readonly _type: 'column';
      readonly dataType: 'id' | 'string' | 'number' | 'boolean' | 'date' | 'object';
      readonly options: any;
      readonly _tsType?: T; // Phantom type, does not exist at runtime
    }


    /** The definition for a table relationship, created by `konro.one()` or
    `konro.many()`. */

    export interface BaseRelationDefinition {
      readonly _type: 'relation';
      readonly targetTable: string;
      readonly on: string;
      readonly references: string;
    }


    export interface OneRelationDefinition extends BaseRelationDefinition {
      readonly relationType: 'one';
    }


    export interface ManyRelationDefinition extends BaseRelationDefinition {
      readonly relationType: 'many';
    }


    export type RelationDefinition = OneRelationDefinition |
    ManyRelationDefinition;


    /** The definition for a data aggregation, created by `konro.count()`,
    `konro.sum()`, etc. */

    export interface AggregationDefinition {
      readonly _type: 'aggregation';
      readonly aggType: 'count' | 'sum' | 'avg' | 'min' | 'max';
      readonly column?: string;
    }



    // --- SCHEMA BUILDER FUNCTION ---


    /**
     * Defines the structure, types, and relations of your database.
     * This is the single source of truth for both runtime validation and static types.
     *
     * @param schemaDef The schema definition object.
     * @returns A processed schema object with inferred types attached.
     */
    export const createSchema = <
      const TDef extends {
        tables: Record<string, Record<string, ColumnDefinition<any>>>;
        relations?: (tables: TDef['tables']) => Record<string, Record<string, BaseRelationDefinition>>;
      }
    >(
      schemaDef: TDef
    ): KonroSchema<TDef['tables'], TDef['relations'] extends (...args: any) =>
    any ? ReturnType<TDef['relations']> : {}> => { // eslint-disable-line
      const relations = schemaDef.relations ? schemaDef.relations(schemaDef.tables) : {};
      return {
        tables: schemaDef.tables,
        relations: relations as any, // Cast to bypass complex conditional type issue
        // Types are applied via the return type annotation, these are just placeholders at runtime.
        types: null as any,
        base: {} as any,
        create: {} as any,
      };
    };



    // --- COLUMN DEFINITION HELPERS ---


    const createColumn = <T>(dataType: ColumnDefinition<T>['dataType'], options:
    object | undefined, tsType: T): ColumnDefinition<T> => ({
      _type: 'column',
      dataType,
      options,
      _tsType: tsType,
    });


    /** A managed, auto-incrementing integer primary key. This is the default
    strategy. */

    export const id = () => createColumn<number>('id', { unique: true,
    _pk_strategy: 'auto-increment' }, 0);

    /** A managed, universally unique identifier (UUID) primary key. Stored as a
    string. */

    export const uuid = () => createColumn<string>('id', { unique: true,
    _pk_strategy: 'uuid' }, '');

    /** A string column with optional validation. */

    export const string = (options?: { unique?: boolean; default?: string | (()
    => string); min?: number; max?: number; format?: 'email' | 'uuid' | 'url' })
    => createColumn<string>('string', options, '');

    /** A number column with optional validation. */

    export const number = (options?: { unique?: boolean; default?: number | (()
    => number); min?: number; max?: number; type?: 'integer' }) =>
    createColumn<number>('number', options, 0);

    /** A boolean column. */

    export const boolean = (options?: { default?: boolean | (() => boolean) })
    => createColumn<boolean>('boolean', options, false);

    /** A date column, stored as an ISO string but hydrated as a Date object. */

    export const date = (options?: { default?: Date | (() => Date) }) =>
    createColumn<Date>('date', options, new Date());

    /** A column for storing arbitrary JSON objects, with a generic for type
    safety. */

    export const object = <T extends Record<string, any>>(options?: { default?:
    T | (() => T) }): ColumnDefinition<T> => ({ _type: 'column', dataType:
    'object', options });



    // --- RELATIONSHIP DEFINITION HELPERS ---


    /** Defines a `one-to-one` or `many-to-one` relationship. */

    export const one = <T extends string>(targetTable: T, options: { on: string;
    references: string }): OneRelationDefinition & { targetTable: T } => ({
      _type: 'relation',
      relationType: 'one',
      targetTable,
      ...options,
    });


    /** Defines a `one-to-many` relationship. */

    export const many = <T extends string>(targetTable: T, options: { on:
    string; references: string }): ManyRelationDefinition & { targetTable: T }
    => ({
      _type: 'relation',
      relationType: 'many',
      targetTable,
      ...options,
    });



    // --- AGGREGATION DEFINITION HELPERS ---


    /** Aggregation to count records. */

    export const count = (): AggregationDefinition => ({ _type: 'aggregation',
    aggType: 'count' });

    /** Aggregation to sum a numeric column. */

    export const sum = (column: string): AggregationDefinition => ({ _type:
    'aggregation', aggType: 'sum', column });

    /** Aggregation to average a numeric column. */

    export const avg = (column: string): AggregationDefinition => ({ _type:
    'aggregation', aggType: 'avg', column });

    /** Aggregation to find the minimum value in a numeric column. */

    export const min = (column: string): AggregationDefinition => ({ _type:
    'aggregation', aggType: 'min', column });

    /** Aggregation to find the maximum value in a numeric column. */

    export const max = (column: string): AggregationDefinition => ({ _type:
    'aggregation', aggType: 'max', column });
  test/unit/Core/Delete.test.ts: "import { describe, it, expect, beforeEach } from 'bun:test';\r\nimport { _deleteImpl } from '../../../src/operations';\r\nimport { DatabaseState } from '../../../src/types';\r\n\r\ndescribe('Unit > Core > Delete', () => {\r\n    let testState: DatabaseState;\r\n\r\n    beforeEach(() => {\r\n        testState = {\r\n            users: {\r\n                records: [\r\n                    { id: 1, name: 'Alice', email: 'a@a.com', age: 30 },\r\n                    { id: 2, name: 'Bob', email: 'b@b.com', age: 25 },\r\n                    { id: 3, name: 'Charlie', email: 'c@c.com', age: 42 },\r\n                ],\r\n                meta: { lastId: 3 },\r\n            },\r\n            posts: { records: [], meta: { lastId: 0 } },\r\n            profiles: { records: [], meta: { lastId: 0 } },\r\n            tags: { records: [], meta: { lastId: 0 } },\r\n            posts_tags: { records: [], meta: { lastId: 0 } },\r\n        };\r\n    });\r\n\r\n    it('should return a new state object, not mutate the original state, on delete', () => {\r\n        const originalState = structuredClone(testState);\r\n        const [newState] = _deleteImpl(testState, 'users', (r) => r.id === 1);\r\n        \r\n        expect(newState).not.toBe(originalState);\r\n        expect(originalState.users!.records.length).toBe(3);\r\n        expect(newState.users!.records.length).toBe(2);\r\n    });\r\n\r\n    it('should only delete records that match the predicate function', () => {\r\n        const [newState, deleted] = _deleteImpl(testState, 'users', (r) => typeof r.age === 'number' && r.age > 35);\r\n        \r\n        expect(deleted.length).toBe(1);\r\n        expect(deleted[0]!.id).toBe(3);\r\n        expect(newState.users!.records.length).toBe(2);\r\n        expect(newState.users!.records.find(u => u.id === 3)).toBeUndefined();\r\n    });\r\n\r\n    it('should return both the new state and an array of the full, deleted records in the result tuple', () => {\r\n        const [newState, deleted] = _deleteImpl(testState, 'users', (r) => r.id === 2);\r\n\r\n        expect(newState).toBeDefined();\r\n        expect(deleted).toBeInstanceOf(Array);\r\n        expect(deleted.length).toBe(1);\r\n        expect(deleted[0]!).toEqual({ id: 2, name: 'Bob', email: 'b@b.com', age: 25 });\r\n    });\r\n\r\n    it('should not modify the table meta lastId on delete', () => {\r\n        const [newState] = _deleteImpl(testState, 'users', (r) => r.id === 3);\r\n        expect(newState.users!.meta.lastId).toBe(3);\r\n    });\r\n});"
  src/index.ts: "import { createDatabase } from './db';\r\nimport { createFileAdapter } from './adapter';\r\nimport { createSchema, id, uuid, string, number, boolean, date, object, one, many, count, sum, avg, min, max } from './schema';\r\n\r\n/**\r\n * The main Konro object, providing access to all core functionalities\r\n * for schema definition, database creation, and adapter configuration.\r\n */\r\nexport const konro = {\r\n  /**\r\n   * Defines the structure, types, and relations of your database.\r\n   * This is the single source of truth for both runtime validation and static types.\r\n   */\r\n  createSchema,\r\n  /**\r\n   * Creates the main `db` context, which is the primary interface for all\r\n   * database operations (read, write, query, etc.).\r\n   */\r\n  createDatabase,\r\n  /**\r\n   * Creates a file-based storage adapter for persisting the database state\r\n   * to a JSON or YAML file.\r\n   */\r\n  createFileAdapter,\r\n  // --- Column Definition Helpers ---\r\n  id,\r\n  uuid,\r\n  string,\r\n  number,\r\n  boolean,\r\n  date,\r\n  object,\r\n  // --- Relationship Definition Helpers ---\r\n  one,\r\n  many,\r\n  // --- Aggregation Definition Helpers ---\r\n  count,\r\n  sum,\r\n  avg,\r\n  min,\r\n  max,\r\n};\r\n"
  src/db.ts: >-
    import path from 'path';

    import { AggregationDefinition, ColumnDefinition, KonroSchema,
    RelationDefinition } from './schema';

    import { StorageAdapter, FileStorageAdapter } from './adapter';

    import { DatabaseState, KRecord, TableState } from './types';

    import { _queryImpl, _insertImpl, _updateImpl, _deleteImpl, createEmptyState
    as createEmptyStateImpl, QueryDescriptor, _aggregateImpl,
    AggregationDescriptor } from './operations';

    import { createPredicateFromPartial } from './utils/predicate.util';

    import { KonroError, KonroStorageError } from './utils/error.util';

    import { writeAtomic } from './fs';


    // A helper to normalize a predicate argument

    const normalizePredicate = <T extends KRecord>(
      predicate: Partial<T> | ((record: T) => boolean)
    ): ((record: KRecord) => boolean) =>
      // The cast is necessary due to function argument contravariance.
      // The internal operations work on the wider `KRecord`, while the fluent API provides the specific `T`.
      (typeof predicate === 'function' ? predicate : createPredicateFromPartial(predicate)) as (record: KRecord) => boolean;

    // --- TYPE HELPERS for Fluent API ---


    type RelatedModel<T> = T extends (infer R)[] ? R : T extends (infer R |
    null) ? R : T;


    // TAll is the full relational model type, e.g. schema.types.users

    type WithArgument<TAll> = { // e.g. TAll = S['types']['users']
      [K in keyof TAll as NonNullable<TAll[K]> extends any[] | object ? K : never]?: boolean | ({
        where?: (record: RelatedModel<NonNullable<TAll[K]>>) => boolean;
      } & (
        | { select: Record<string, ColumnDefinition<unknown>>; with?: never }
        | { select?: never; with?: WithArgument<RelatedModel<NonNullable<TAll[K]>>> }
      ));
    };


    type ResolveWith<
      S extends KonroSchema<any, any>,
      TName extends keyof S['tables'],
      TWith extends WithArgument<S['types'][TName]>
    > = { // TName='users', TWith={posts: {with: {author: true}}}
        [K in keyof TWith & keyof S['relations'][TName]]:
            S['relations'][TName][K] extends { relationType: 'many' }
                ? ( // 'many' relation -> array result. K = 'posts'
                    TWith[K] extends { select: infer TSelect }
                        ? ({ [P in keyof TSelect]: InferColumnType<TSelect[P]> })[]
                        : TWith[K] extends { with: infer TNestedWith }
                            // S['relations']['users']['posts']['targetTable'] = 'posts'
                            ? (S['base'][S['relations'][TName][K]['targetTable']] & ResolveWith<S, S['relations'][TName][K]['targetTable'], TNestedWith & WithArgument<S['types'][S['relations'][TName][K]['targetTable']]>>)[]
                            // posts: true.
                            : S['base'][S['relations'][TName][K]['targetTable']][]
                  )
                : S['relations'][TName][K] extends { relationType: 'one' }
                    ? ( // 'one' relation -> nullable object result
                        TWith[K] extends { select: infer TSelect }
                            ? ({ [P in keyof TSelect]: InferColumnType<TSelect[P]> }) | null
                            : TWith[K] extends { with: infer TNestedWith }
                                ? (S['base'][S['relations'][TName][K]['targetTable']] & ResolveWith<S, S['relations'][TName][K]['targetTable'], TNestedWith & WithArgument<S['types'][S['relations'][TName][K]['targetTable']]>>) | null
                                : S['base'][S['relations'][TName][K]['targetTable']] | null
                      )
                    : never
    };


    // InferColumnType is not exported from schema, so we need it here too.

    type InferColumnType<C> = C extends ColumnDefinition<infer T> ? T : never;


    // --- IN-MEMORY API TYPES (STATEFUL) ---


    interface ChainedQueryBuilder<S extends KonroSchema<any, any>, TName extends
    keyof S['tables'], TReturn> {
      select(fields: Record<string, ColumnDefinition<unknown> | RelationDefinition>): this;
      where(predicate: Partial<S['base'][TName]> | ((record: S['base'][TName]) => boolean)): this;
      with<W extends WithArgument<S['types'][TName]>>(relations: W): ChainedQueryBuilder<S, TName, TReturn & ResolveWith<S, TName, W>>;
      limit(count: number): this;
      offset(count: number): this;
      all(): TReturn[];
      first(): TReturn | null;
      aggregate<TAggs extends Record<string, AggregationDefinition>>(
        aggregations: TAggs
      ): { [K in keyof TAggs]: number | null };
    }


    interface QueryBuilder<S extends KonroSchema<any, any>> {
      from<T extends keyof S['tables']>(tableName: T): ChainedQueryBuilder<S, T, S['base'][T]>;
    }


    interface UpdateBuilder<S extends KonroSchema<any, any>, TBase, TCreate> {
      set(data: Partial<TCreate>): {
        where(predicate: Partial<TBase> | ((record: TBase) => boolean)): [DatabaseState<S>, TBase[]];
      };
    }


    interface DeleteBuilder<S extends KonroSchema<any, any>, TBase> {
      where(predicate: Partial<TBase> | ((record: TBase) => boolean)): [DatabaseState<S>, TBase[]];
    }


    export interface InMemoryDbContext<S extends KonroSchema<any, any>> {
      schema: S;
      adapter: StorageAdapter;
      read(): Promise<DatabaseState<S>>;
      write(state: DatabaseState<S>): Promise<void>;
      createEmptyState(): DatabaseState<S>;

      query(state: DatabaseState<S>): QueryBuilder<S>;
      insert<T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T, values: S['create'][T]): [DatabaseState<S>, S['base'][T]];
      insert<T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T, values: Readonly<S['create'][T]>[]): [DatabaseState<S>, S['base'][T][]];
      update<T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T): UpdateBuilder<S, S['base'][T], S['create'][T]>;
      delete<T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T): DeleteBuilder<S, S['base'][T]>;
    }



    // --- ON-DEMAND API TYPES (STATELESS & ASYNC) ---


    interface OnDemandChainedQueryBuilder<S extends KonroSchema<any, any>, TName
    extends keyof S['tables'], TReturn> {
      select(fields: Record<string, ColumnDefinition<unknown> | RelationDefinition>): this;
      where(predicate: Partial<S['base'][TName]> | ((record: S['base'][TName]) => boolean)): this;
      with<W extends WithArgument<S['types'][TName]>>(relations: W): OnDemandChainedQueryBuilder<S, TName, TReturn & ResolveWith<S, TName, W>>;
      limit(count: number): this;
      offset(count: number): this;
      all(): Promise<TReturn[]>;
      first(): Promise<TReturn | null>;
      aggregate<TAggs extends Record<string, AggregationDefinition>>(
        aggregations: TAggs
      ): Promise<{ [K in keyof TAggs]: number | null }>;
    }


    interface OnDemandQueryBuilder<S extends KonroSchema<any, any>> {
      from<T extends keyof S['tables']>(tableName: T): OnDemandChainedQueryBuilder<S, T, S['base'][T]>;
    }


    interface OnDemandUpdateBuilder<TBase, TCreate> {
      set(data: Partial<TCreate>): {
        where(predicate: Partial<TBase> | ((record: TBase) => boolean)): Promise<TBase[]>;
      };
    }


    interface OnDemandDeleteBuilder<TBase> {
      where(predicate: Partial<TBase> | ((record: TBase) => boolean)): Promise<TBase[]>;
    }


    export interface OnDemandDbContext<S extends KonroSchema<any, any>> {
      schema: S;
      adapter: StorageAdapter;
      read(): Promise<never>; // Not supported in on-demand mode
      write(): Promise<never>; // Not supported in on-demand mode
      createEmptyState(): DatabaseState<S>;

      query(): OnDemandQueryBuilder<S>;
      insert<T extends keyof S['tables']>(tableName: T, values: S['create'][T]): Promise<S['base'][T]>;
      insert<T extends keyof S['tables']>(tableName: T, values: Readonly<S['create'][T]>[]): Promise<S['base'][T][]>;
      update<T extends keyof S['tables']>(tableName: T): OnDemandUpdateBuilder<S['base'][T], S['create'][T]>;
      delete<T extends keyof S['tables']>(tableName: T): OnDemandDeleteBuilder<S['base'][T]>;
    }


    // --- DbContext Union Type ---

    export type DbContext<S extends KonroSchema<any, any>> =
    InMemoryDbContext<S> | OnDemandDbContext<S>;


    // --- CORE LOGIC (STATELESS & PURE) ---


    /**
     * Creates the core, stateless database operations.
     * These operations are pure functions that take a database state and return a new state,
     * forming the foundation for both in-memory and on-demand modes.
     */
    function createCoreDbContext<S extends KonroSchema<any, any>>(schema: S) {
      const query = (state: DatabaseState<S>): QueryBuilder<S> => ({
        from: <TName extends keyof S['tables']>(tableName: TName): ChainedQueryBuilder<S, TName, S['base'][TName]> => {
          const createBuilder = <TReturn>(currentDescriptor: QueryDescriptor): ChainedQueryBuilder<S, TName, TReturn> => ({
            select(fields) { return createBuilder<TReturn>({ ...currentDescriptor, select: fields }); },
            where(predicate) { return createBuilder<TReturn>({ ...currentDescriptor, where: normalizePredicate(predicate as any) }); },
            with<W extends WithArgument<S['types'][TName]>>(relations: W) {
              const newWith = { ...currentDescriptor.with, ...(relations as QueryDescriptor['with']) };
              return createBuilder<TReturn & ResolveWith<S, TName, W>>({ ...currentDescriptor, with: newWith });
            },
            limit(count) { return createBuilder<TReturn>({ ...currentDescriptor, limit: count }); },
            offset(count) { return createBuilder<TReturn>({ ...currentDescriptor, offset: count }); },
            all: (): TReturn[] => _queryImpl(state as DatabaseState, schema, currentDescriptor) as any,
            first: (): TReturn | null => (_queryImpl(state as DatabaseState, schema, { ...currentDescriptor, limit: 1 })[0] ?? null) as any,
            aggregate: (aggregations) => {
              const aggDescriptor: AggregationDescriptor = { ...currentDescriptor, aggregations };
              return _aggregateImpl(state as DatabaseState, schema, aggDescriptor) as any;
            },
          });
          return createBuilder<S['base'][TName]>({ tableName: tableName as string });
        },
      });

      const insert = <T extends keyof S['tables']>(
        state: DatabaseState<S>, tableName: T, values: S['create'][T] | Readonly<S['create'][T]>[]
      ): [DatabaseState<S>, S['base'][T] | S['base'][T][]] => {
        const valsArray = Array.isArray(values) ? values : [values];
        const [newState, inserted] = _insertImpl(state as DatabaseState, schema, tableName as string, valsArray as KRecord[]);
        const result = Array.isArray(values) ? inserted : inserted[0];
        return [newState as DatabaseState<S>, result] as [DatabaseState<S>, S['base'][T] | S['base'][T][]];
      };

      const update = <T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T): UpdateBuilder<S, S['base'][T], S['create'][T]> => ({
        set: (data) => ({
          where: (predicate) => {
            const [newState, updatedRecords] = _updateImpl(state as DatabaseState, schema, tableName as string, data as Partial<KRecord>, normalizePredicate(predicate as any));
            return [newState as DatabaseState<S>, updatedRecords as S['base'][T][]];
          },
        }),
      });

      const del = <T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T): DeleteBuilder<S, S['base'][T]> => ({
        where: (predicate) => {
          const [newState, deletedRecords] = _deleteImpl(state as DatabaseState, tableName as string, normalizePredicate(predicate as any));
          return [newState as DatabaseState<S>, deletedRecords as S['base'][T][]];
        },
      });

      return { query, insert, update, delete: del };
    }


    // --- ON-DEMAND CONTEXT (STATEFUL WRAPPER) ---


    function createMultiFileOnDemandDbContext<S extends KonroSchema<any, any>>(
      schema: S,
      adapter: FileStorageAdapter,
      core: ReturnType<typeof createCoreDbContext<S>>
    ): OnDemandDbContext<S> {
      const { dir } = adapter.options.multi!;

      const readTableState = async (tableName: string): Promise<TableState> => {
        const filepath = path.join(dir, `${tableName}${adapter.fileExtension}`);
        const data = await adapter.fs.readFile(filepath);
        if (!data) return { records: [], meta: { lastId: 0 } };
        try {
          return adapter.serializer.parse(data, schema.tables[tableName]);
        } catch (e: any) {
          throw KonroStorageError(`Failed to parse file at "${filepath}". It may be corrupt or not a valid ${adapter.options.format} file. Original error: ${e.message}`);
        }
      };

      const writeTableState = async (tableName: string, tableState: TableState): Promise<void> => {
        await adapter.fs.mkdir(dir, { recursive: true });
        const filepath = path.join(dir, `${tableName}${adapter.fileExtension}`);
        const content = adapter.serializer.stringify(tableState);
        await writeAtomic(filepath, content, adapter.fs);
      };
      
      // For queries with relations, we need the full state.
      const getFullState = async (): Promise<DatabaseState<S>> => {
        const state = createEmptyStateImpl(schema);
        await Promise.all(Object.keys(schema.tables).map(async (tableName) => {
          (state as any)[tableName] = await readTableState(tableName);
        }));
        return state;
      }

      // A generic handler for CUD operations that reads one table, performs an action, and writes it back.
      const performCud = async <TResult>(tableName: string, action: (state: DatabaseState<S>) => [DatabaseState<S>, TResult]): Promise<TResult> => {
        const state = createEmptyStateImpl(schema);
        (state as any)[tableName] = await readTableState(tableName);
        const [newState, result] = action(state as DatabaseState<S>);
        
        // Check if the operation produced a result (e.g., an array of inserted/updated/deleted records)
        const hasChanges = Array.isArray(result) ? result.length > 0 : result !== null;
        if (hasChanges) {
          const newTableState = newState[tableName as string];
          // This check satisfies the `noUncheckedIndexedAccess` compiler option.
          // Our CUD logic ensures this state will always exist after a change.
          if (newTableState) {
            await writeTableState(tableName, newTableState);
          }
        }
        return result;
      };

      const query = (): OnDemandQueryBuilder<S> => ({
        from: <TName extends keyof S['tables']>(tableName: TName): OnDemandChainedQueryBuilder<S, TName, S['base'][TName]> => {
          // The query builder for on-demand must be separate because its terminal methods are async.
          const createBuilder = <TReturn>(currentDescriptor: QueryDescriptor): OnDemandChainedQueryBuilder<S, TName, TReturn> => ({
            select(fields) { return createBuilder<TReturn>({ ...currentDescriptor, select: fields }); },
            where(predicate) { return createBuilder<TReturn>({ ...currentDescriptor, where: normalizePredicate(predicate as any) }); },
            with<W extends WithArgument<S['types'][TName]>>(relations: W) {
              const newWith = { ...currentDescriptor.with, ...(relations as QueryDescriptor['with']) };
              return createBuilder<TReturn & ResolveWith<S, TName, W>>({ ...currentDescriptor, with: newWith });
            },
            limit(count) { return createBuilder<TReturn>({ ...currentDescriptor, limit: count }); },
            offset(count) { return createBuilder<TReturn>({ ...currentDescriptor, offset: count }); },
            all: async (): Promise<TReturn[]> => {
              const state = await getFullState();
              return _queryImpl(state, schema, currentDescriptor) as any;
            },
            first: async (): Promise<TReturn | null> => {
              const state = await getFullState();
              return (_queryImpl(state, schema, { ...currentDescriptor, limit: 1 })[0] ?? null) as any;
            },
            aggregate: async (aggregations) => {
              const state = await getFullState();
              const aggDescriptor: AggregationDescriptor = { ...currentDescriptor, aggregations };
              return _aggregateImpl(state, schema, aggDescriptor) as any;
            },
          });
          return createBuilder<S['base'][TName]>({ tableName: tableName as string });
        },
      });

      const insert = <T extends keyof S['tables']>(tableName: T, values: S['create'][T] | Readonly<S['create'][T]>[]): Promise<any> => 
        performCud(tableName as string, (state) => core.insert(state, tableName, values as any));

      const update = <T extends keyof S['tables']>(tableName: T): OnDemandUpdateBuilder<S['base'][T], S['create'][T]> => ({
        set: (data) => ({
          where: (predicate) => performCud(tableName as string, (state) => core.update(state, tableName).set(data).where(predicate as any)) as Promise<S['base'][T][]>,
        }),
      });

      const del = <T extends keyof S['tables']>(tableName: T): OnDemandDeleteBuilder<S['base'][T]> => ({
        where: (predicate) => performCud(tableName as string, (state) => core.delete(state, tableName).where(predicate as any)) as Promise<S['base'][T][]>,
      });

      const notSupported = () => Promise.reject(KonroError("This method is not supported in 'on-demand' mode."));

      return {
        schema,
        adapter,
        read: notSupported,
        write: notSupported,
        createEmptyState: () => createEmptyStateImpl(schema),
        query,
        insert,
        update,
        delete: del,
      };
    }


    function createPerRecordOnDemandDbContext<S extends KonroSchema<any, any>>(
      schema: S,
      adapter: FileStorageAdapter,
      core: ReturnType<typeof createCoreDbContext<S>>
    ): OnDemandDbContext<S> {
      const { dir } = adapter.options.perRecord!;
      const { fs, serializer, fileExtension } = adapter;

      const getTableDir = (tableName: string) => path.join(dir, tableName);
      const getRecordPath = (tableName: string, recordId: string | number) => path.join(getTableDir(tableName), `${recordId}${fileExtension}`);
      const getMetaPath = (tableName: string) => path.join(getTableDir(tableName), '_meta.json');

      const getIdColumn = (tableName: string) => {
        const tableSchema = schema.tables[tableName];
        const idColumn = Object.keys(tableSchema).find((key) => tableSchema[key]?.dataType === 'id');
        if (!idColumn) {
          throw KonroError(`Table "${tableName}" must have an 'id' column to be used with 'per-record' storage.`);
        }
        return idColumn;
      };

      const readMeta = async (tableName: string): Promise<{ lastId: number }> => {
        const metaContent = await fs.readFile(getMetaPath(tableName));
        return metaContent ? JSON.parse(metaContent) : { lastId: 0 };
      };

      const writeMeta = async (tableName: string, meta: { lastId: number }): Promise<void> => {
        await fs.mkdir(getTableDir(tableName), { recursive: true });
        await writeAtomic(getMetaPath(tableName), JSON.stringify(meta, null, 2), fs);
      };

      const readTableState = async (tableName: string): Promise<TableState> => {
        const tableDir = getTableDir(tableName);
        await fs.mkdir(tableDir, { recursive: true });

        const meta = await readMeta(tableName);
        const files = await fs.readdir(tableDir);
        const recordFiles = files.filter((f) => !f.startsWith('_meta'));

        const records = (
          await Promise.all(
            recordFiles.map(async (file) => {
              const content = await fs.readFile(path.join(tableDir, file));
              return content ? serializer.parse<KRecord>(content) : null;
            })
          )
        ).filter((r): r is KRecord => r !== null);

        return { records, meta };
      };

      const getFullState = async (): Promise<DatabaseState<S>> => {
        const state = createEmptyStateImpl(schema);
        await Promise.all(
          Object.keys(schema.tables).map(async (tableName) => {
            (state as any)[tableName] = await readTableState(tableName);
          })
        );
        return state;
      };

      const query = (): OnDemandQueryBuilder<S> => ({
        from: <TName extends keyof S['tables']>(tableName: TName): OnDemandChainedQueryBuilder<S, TName, S['base'][TName]> => {
          const createBuilder = <TReturn>(currentDescriptor: QueryDescriptor): OnDemandChainedQueryBuilder<S, TName, TReturn> => ({
            select(fields) { return createBuilder<TReturn>({ ...currentDescriptor, select: fields }); },
            where(predicate) { return createBuilder<TReturn>({ ...currentDescriptor, where: normalizePredicate(predicate as any) }); },
            with<W extends WithArgument<S['types'][TName]>>(relations: W) {
              const newWith = { ...currentDescriptor.with, ...(relations as QueryDescriptor['with']) };
              return createBuilder<TReturn & ResolveWith<S, TName, W>>({ ...currentDescriptor, with: newWith });
            },
            limit(count) { return createBuilder<TReturn>({ ...currentDescriptor, limit: count }); },
            offset(count) { return createBuilder<TReturn>({ ...currentDescriptor, offset: count }); },
            all: async (): Promise<TReturn[]> => {
              const state = await getFullState();
              return _queryImpl(state, schema, currentDescriptor) as any;
            },
            first: async (): Promise<TReturn | null> => {
              const state = await getFullState();
              return (_queryImpl(state, schema, { ...currentDescriptor, limit: 1 })[0] ?? null) as any;
            },
            aggregate: async (aggregations) => {
              const state = await getFullState();
              const aggDescriptor: AggregationDescriptor = { ...currentDescriptor, aggregations };
              return _aggregateImpl(state, schema, aggDescriptor) as any;
            },
          });
          return createBuilder<S['base'][TName]>({ tableName: tableName as string });
        },
      });

      const insert = async <T extends keyof S['tables']>(tableName: T, values: S['create'][T] | Readonly<S['create'][T]>[]): Promise<any> => {
        const tableNameStr = tableName as string;
        const meta = await readMeta(tableNameStr);
        const idColumn = getIdColumn(tableNameStr);

        // We only need a shallow table state for insert, no records needed for validation context.
        const tempState: DatabaseState = { [tableNameStr]: { records: [], meta } };
        const [newState, insertedResult] = core.insert(tempState as any, tableName, values as any);

        const insertedAsArray = Array.isArray(insertedResult) ? insertedResult : insertedResult ? [insertedResult] : [];

        if (insertedAsArray.length === 0) {
          return insertedResult; // Return original empty array or null
        }

        await Promise.all(
          (insertedAsArray as KRecord[]).map((rec) => {
            const recordPath = getRecordPath(tableNameStr, rec[idColumn] as any);
            return writeAtomic(recordPath, serializer.stringify(rec), fs);
          })
        );

        const newMeta = (newState as DatabaseState)[tableNameStr]?.meta;
        if (newMeta && newMeta.lastId !== meta.lastId) {
          await writeMeta(tableNameStr, newMeta);
        }

        return insertedResult;
      };

      const update = <T extends keyof S['tables']>(tableName: T): OnDemandUpdateBuilder<S['base'][T], S['create'][T]> => ({
        set: (data) => ({
          where: async (predicate) => {
            const tableNameStr = tableName as string;
            const tableState = await readTableState(tableNameStr);
            const idColumn = getIdColumn(tableNameStr);
            const [, updatedRecords] = core.update({ [tableNameStr]: tableState } as any, tableName).set(data).where(predicate as any);

            if (updatedRecords.length > 0) {
              await Promise.all(
                (updatedRecords as KRecord[]).map((rec) => writeAtomic(getRecordPath(tableNameStr, rec[idColumn] as any), serializer.stringify(rec), fs))
              );
            }
            return updatedRecords as S['base'][T][];
          },
        }),
      });

      const del = <T extends keyof S['tables']>(tableName: T): OnDemandDeleteBuilder<S['base'][T]> => ({
        where: async (predicate) => {
          const tableNameStr = tableName as string;
          const tableState = await readTableState(tableNameStr);
          const idColumn = getIdColumn(tableNameStr);
          const [, deletedRecords] = core.delete({ [tableNameStr]: tableState } as any, tableName).where(predicate as any);

          if (deletedRecords.length > 0) {
            await Promise.all((deletedRecords as KRecord[]).map((rec) => fs.unlink(getRecordPath(tableNameStr, rec[idColumn] as any))));
          }
          return deletedRecords as S['base'][T][];
        },
      });

      const notSupported = () => Promise.reject(KonroError("This method is not supported in 'on-demand' mode."));

      return { schema, adapter, createEmptyState: () => createEmptyStateImpl(schema), read: notSupported, write: notSupported, query, insert, update, delete: del };
    }



    // --- DATABASE FACTORY ---


    export function createDatabase<
      S extends KonroSchema<any, any>,
      TAdapter extends StorageAdapter,
    >(
      options: { schema: S; adapter: TAdapter }
    ): TAdapter['mode'] extends 'on-demand' ? OnDemandDbContext<S> :
    InMemoryDbContext<S>;

    export function createDatabase<S extends KonroSchema<any, any>>(
      options: { schema: S; adapter: StorageAdapter }
    ): DbContext<S> {
      const { schema, adapter } = options;
      const core = createCoreDbContext(schema);

      if (adapter.mode === 'on-demand') {
        const fileAdapter = adapter as FileStorageAdapter; // We can be sure it's a FileStorageAdapter due to checks
        if (fileAdapter.options.multi) {
          return createMultiFileOnDemandDbContext(schema, fileAdapter, core);
        }
        if (fileAdapter.options.perRecord) {
          return createPerRecordOnDemandDbContext(schema, fileAdapter, core);
        }
        throw KonroError("The 'on-demand' mode requires a 'multi-file' or 'per-record' storage strategy.");
      }

      // For in-memory, just combine the core logic with the adapter and I/O methods.
      return {
        ...core,
        schema, adapter,
        read: () => adapter.read(schema),
        write: (state) => adapter.write(state, schema),
        createEmptyState: () => createEmptyStateImpl(schema),
      } as InMemoryDbContext<S>;
    }
approved: true

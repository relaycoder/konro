uuid: d8929e07-3a18-4e50-98df-8d19ef796bd4
projectId: konro
createdAt: '2025-07-07T05:45:48.339Z'
gitCommitMsg: 'feat: Implement unit tests and add query select feature'
promptSummary: >-
  Execute the provided test plan, create unit tests for core functionality, and
  fix any uncovered issues. The tests should be isolated, thorough, and use
  bun:test. This includes creating a test utility file, implementing tests for
  schema helpers, core operations (insert, update, delete, query), and creating
  failing tests for validation constraints to highlight missing features.
reasoning:
  - >-
    I will now execute the provided test plan, starting with the unit tests. I
    will create the necessary test files and a utility file for shared test
    logic. As I write the tests, I will identify and fix core issues in the main
    program, adhering to the provided rules.
  - >-
    First, I'll create a utility file for tests. This will define a common
    schema, test data, and helper functions for setting up and tearing down
    tests.
  - >-
    While writing the update test, I discovered that the `id` of a record could
    be changed, which is undesirable. I will patch `operations.ts` to prevent
    this by adding the schema to the `_updateImpl` signature and removing the ID
    field from the update payload. I'll also update `db.ts` to pass the schema.
  - >-
    The test plan requires a `.select()` method for queries, which is not in the
    current implementation. I'll add this feature to `operations.ts` and `db.ts`
    before writing the query tests.
  - Now, I'll add the unit test files as specified in the test plan.
operations:
  - type: write
    path: test/util.ts
    content: |-
      --- /dev/null
      +++ test/util.ts
      @@ -0,0 +1,78 @@
      +import { konro } from '../src/index';
      +import { promises as fs } from 'fs';
      +import path from 'path';
      +
      +export const TEST_DIR = path.join(__dirname, 'test_run_data');
      +
      +// --- Schema Definition ---
      +
      +export const schemaDef = {
      +  tables: {
      +    users: {
      +      id: konro.id(),
      +      name: konro.string({ min: 2 }),
      +      email: konro.string({ unique: true, format: 'email' }),
      +      age: konro.number({ min: 18, type: 'integer' }),
      +      isActive: konro.boolean({ default: true }),
      +    },
      +    posts: {
      +      id: konro.id(),
      +      title: konro.string(),
      +      content: konro.string(),
      +      authorId: konro.number(),
      +      publishedAt: konro.date({ default: () => new Date() }),
      +    },
      +    profiles: {
      +      id: konro.id(),
      +      bio: konro.string(),
      +      userId: konro.number({ unique: true }),
      +    },
      +    tags: {
      +      id: konro.id(),
      +      name: konro.string({ unique: true }),
      +    },
      +    posts_tags: {
      +      id: konro.id(),
      +      postId: konro.number(),
      +      tagId: konro.number(),
      +    },
      +  },
      +  relations: (tables: any) => ({
      +    users: {
      +      posts: konro.many('posts', { on: 'id', references: 'authorId' }),
      +      profile: konro.one('profiles', { on: 'id', references: 'userId' }),
      +    },
      +    posts: {
      +      author: konro.one('users', { on: 'authorId', references: 'id' }),
      +      tags: konro.many('posts_tags', { on: 'id', references: 'postId' }),
      +    },
      +    profiles: {
      +      user: konro.one('users', { on: 'userId', references: 'id' }),
      +    },
      +    posts_tags: {
      +        post: konro.one('posts', { on: 'postId', references: 'id' }),
      +        tag: konro.one('tags', { on: 'tagId', references: 'id' }),
      +    }
      +  }),
      +};
      +
      +export const testSchema = konro.createSchema(schemaDef);
      +
      +// --- Test Utilities ---
      +
      +export const cleanup = async () => {
      +    try {
      +        await fs.rm(TEST_DIR, { recursive: true, force: true });
      +    } catch (error: any) {
      +        if (error.code !== 'ENOENT') {
      +            console.error('Error during cleanup:', error);
      +        }
      +    }
      +};
      +
      +export const ensureTestDir = async () => {
      +    await fs.mkdir(TEST_DIR, { recursive: true });
      +}
    patchStrategy: new-unified
  - type: write
    path: src/db.ts
    content: |-
      <<<<<<< SEARCH
          update: <T extends keyof S['tables']>(state: DatabaseState, tableName: T): UpdateBuilder<S['types'][T]> => ({
            set: (data) => ({
              where: (predicate) => {
                const [newState, updatedRecords] = _updateImpl(state, tableName as string, data as Partial<KRecord>, normalizePredicate(predicate));
                return [newState, updatedRecords as S['types'][T][]];
              },
            }),
          }),
      =======
          update: <T extends keyof S['tables']>(state: DatabaseState, tableName: T): UpdateBuilder<S['types'][T]> => ({
            set: (data) => ({
              where: (predicate) => {
                const [newState, updatedRecords] = _updateImpl(state, schema, tableName as string, data as Partial<KRecord>, normalizePredicate(predicate));
                return [newState, updatedRecords as S['types'][T][]];
              },
            }),
          }),
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/operations.ts
    content: >-
      <<<<<<< SEARCH

      export const _updateImpl = (state: DatabaseState, tableName: string, data:
      Partial<KRecord>, predicate: (record: KRecord) => boolean):
      [DatabaseState, KRecord[]] => {
        const newState = structuredClone(state);
        const tableState = newState[tableName];
        if (!tableState) throw KonroError(`Table "${tableName}" does not exist in the database state.`);
        const updatedRecords: KRecord[] = [];

        tableState.records = tableState.records.map(record => {
          if (predicate(record)) {
            const updatedRecord = { ...record, ...data };
            updatedRecords.push(updatedRecord);
            return updatedRecord;
          }
          return record;
        });

        return [newState, updatedRecords];
      };

      =======

      export const _updateImpl = (state: DatabaseState, schema: KonroSchema<any,
      any>, tableName: string, data: Partial<KRecord>, predicate: (record:
      KRecord) => boolean): [DatabaseState, KRecord[]] => {
        const newState = structuredClone(state);
        const tableState = newState[tableName];
        if (!tableState) throw KonroError(`Table "${tableName}" does not exist in the database state.`);
        const updatedRecords: KRecord[] = [];

        const updateData = { ...data };
        // Find the ID column from the schema and prevent it from being updated.
        const idColumn = Object.entries(schema.tables[tableName] ?? {}).find(([, colDef]) => colDef.dataType === 'id')?.[0];
        if (idColumn && updateData[idColumn] !== undefined) {
          delete updateData[idColumn];
        }


        tableState.records = tableState.records.map(record => {
          if (predicate(record)) {
            const updatedRecord = { ...record, ...updateData };
            updatedRecords.push(updatedRecord);
            return updatedRecord;
          }
          return record;
        });

        return [newState, updatedRecords];
      };

      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/db.ts
    content: |-
      <<<<<<< SEARCH
      interface ChainedQueryBuilder<T> {
        where(predicate: Partial<T> | ((record: T) => boolean)): this;
        with(relations: QueryDescriptor['with']): this;
        limit(count: number): this;
        offset(count: number): this;
        all(): Promise<T[]>;
        first(): Promise<T | null>;
      }
      =======
      interface ChainedQueryBuilder<T> {
        select(fields: (keyof T)[]): this;
        where(predicate: Partial<T> | ((record: T) => boolean)): this;
        with(relations: QueryDescriptor['with']): this;
        limit(count: number): this;
        offset(count: number): this;
        all(): Promise<T[]>;
        first(): Promise<T | null>;
      }
      >>>>>>> REPLACE
      <<<<<<< SEARCH
              const descriptor: QueryDescriptor = { tableName: tableName as string };

              const builder: ChainedQueryBuilder<S['types'][T]> = {
                where: (predicate) => {
                  descriptor.where = normalizePredicate(predicate);
                  return builder;
                },
      =======
              const descriptor: QueryDescriptor = { tableName: tableName as string };

              const builder: ChainedQueryBuilder<S['types'][T]> = {
                select: (fields) => {
                  descriptor.select = fields as string[];
                  return builder;
                },
                where: (predicate) => {
                  descriptor.where = normalizePredicate(predicate);
                  return builder;
                },
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/operations.ts
    content: |-
      <<<<<<< SEARCH
      export interface QueryDescriptor {
        tableName: string;
        where?: (record: KRecord) => boolean;
        with?: Record<string, boolean | { where?: (record: KRecord) => boolean }>;
        limit?: number;
        offset?: number;
      }
      =======
      export interface QueryDescriptor {
        tableName: string;
        select?: (keyof KRecord)[];
        where?: (record: KRecord) => boolean;
        with?: Record<string, boolean | { where?: (record: KRecord) => boolean }>;
        limit?: number;
        offset?: number;
      }
      >>>>>>> REPLACE
      <<<<<<< SEARCH
        // 3. Paginate
        const offset = descriptor.offset ?? 0;
        const limit = descriptor.limit ?? results.length;
        return results.slice(offset, offset + limit);
      };
      =======
        // 3. Paginate
        const offset = descriptor.offset ?? 0;
        const limit = descriptor.limit ?? results.length;
        let paginatedResults = results.slice(offset, offset + limit);

        // 4. Select Fields
        if (descriptor.select) {
          paginatedResults = paginatedResults.map(rec => {
            const newRec: KRecord = {};
            for (const key of descriptor.select!) {
              // This includes keys from `with` if the user explicitly adds them to select.
              if (rec.hasOwnProperty(key)) {
                newRec[key] = rec[key];
              }
            }
            return newRec;
          });
        }

        return paginatedResults;
      };
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/unit/Schema/ColumnHelpers.test.ts
    content: >-
      --- /dev/null

      +++ test/unit/Schema/ColumnHelpers.test.ts

      @@ -0,0 +1,71 @@

      +import { describe, it, expect } from 'bun:test';

      +import { konro } from '../../../src/index';

      +

      +describe('Unit > Schema > ColumnHelpers', () => {

      +  it('should create a valid ID column definition object when calling
      konro.id()', () => {

      +    const idCol = konro.id();

      +    expect(idCol).toEqual({

      +      _type: 'column',

      +      dataType: 'id',

      +      options: { unique: true },

      +      _tsType: 0,

      +    });

      +  });

      +

      +  it('should create a valid string column definition with all specified
      options', () => {

      +    const defaultFn = () => 'default';

      +    const stringCol = konro.string({

      +      unique: true,

      +      default: defaultFn,

      +      min: 5,

      +      max: 100,

      +      format: 'email',

      +    });

      +    expect(stringCol).toEqual({

      +      _type: 'column',

      +      dataType: 'string',

      +      options: {

      +        unique: true,

      +        default: defaultFn,

      +        min: 5,

      +        max: 100,

      +        format: 'email',

      +      },

      +      _tsType: '',

      +    });

      +  });

      +

      +  it('should create a valid number column definition with all specified
      options', () => {

      +    const numberCol = konro.number({

      +      unique: false,

      +      default: 0,

      +      min: 0,

      +      max: 1000,

      +      type: 'integer',

      +    });

      +    expect(numberCol).toEqual({

      +      _type: 'column',

      +      dataType: 'number',

      +      options: {

      +        unique: false,

      +        default: 0,

      +        min: 0,

      +        max: 1000,

      +        type: 'integer',

      +      },

      +      _tsType: 0,

      +    });

      +  });

      +

      +  it('should create a valid boolean column definition with a default
      value', () => {

      +    const boolCol = konro.boolean({ default: false });

      +    expect(boolCol).toEqual({

      +      _type: 'column',

      +      dataType: 'boolean',

      +      options: { default: false },

      +      _tsType: false,

      +    });

      +  });

      +

      +  it('should create a valid date column definition with a default
      function', () => {

      +    const defaultDateFn = () => new Date();

      +    const dateCol = konro.date({ default: defaultDateFn });

      +    expect(dateCol).toEqual({

      +      _type: 'column',

      +      dataType: 'date',

      +      options: { default: defaultDateFn },

      +      _tsType: expect.any(Date),

      +    });

      +    expect(dateCol.options?.default).toBe(defaultDateFn);

      +  });

      +

      +  it('should create a valid object column definition', () => {

      +    const objCol = konro.object<{ meta: string }>();

      +    expect(objCol).toEqual({

      +      _type: 'column',

      +      dataType: 'object',

      +      options: undefined,

      +      _tsType: {},

      +    });

      +  });

      +});
    patchStrategy: new-unified
  - type: write
    path: test/unit/Schema/RelationHelpers.test.ts
    content: >-
      --- /dev/null

      +++ test/unit/Schema/RelationHelpers.test.ts

      @@ -0,0 +1,25 @@

      +import { describe, it, expect } from 'bun:test';

      +import { konro } from '../../../src/index';

      +

      +describe('Unit > Schema > RelationHelpers', () => {

      +  it('should create a valid one-to-many relationship definition object
      when calling konro.many()', () => {

      +    const manyRel = konro.many('posts', { on: 'id', references:
      'authorId' });

      +    expect(manyRel).toEqual({

      +      _type: 'relation',

      +      relationType: 'many',

      +      targetTable: 'posts',

      +      on: 'id',

      +      references: 'authorId',

      +    });

      +  });

      +

      +  it('should create a valid one-to-one/many-to-one relationship
      definition object when calling konro.one()', () => {

      +    const oneRel = konro.one('users', { on: 'authorId', references: 'id'
      });

      +    expect(oneRel).toEqual({

      +      _type: 'relation',

      +      relationType: 'one',

      +      targetTable: 'users',

      +      on: 'authorId',

      +      references: 'id',

      +    });

      +  });

      +});
    patchStrategy: new-unified
  - type: write
    path: test/unit/Schema/CreateSchema.test.ts
    content: >-
      --- /dev/null

      +++ test/unit/Schema/CreateSchema.test.ts

      @@ -0,0 +1,50 @@

      +import { describe, it, expect } from 'bun:test';

      +import { konro } from '../../../src/index';

      +

      +describe('Unit > Schema > CreateSchema', () => {

      +  it('should correctly assemble a full schema object from tables and
      relations definitions', () => {

      +    const tableDefs = {

      +      users: {

      +        id: konro.id(),

      +        name: konro.string(),

      +      },

      +      posts: {

      +        id: konro.id(),

      +        title: konro.string(),

      +        authorId: konro.number(),

      +      },

      +    };

      +

      +    const schema = konro.createSchema({

      +      tables: tableDefs,

      +      relations: () => ({

      +        users: {

      +          posts: konro.many('posts', { on: 'id', references: 'authorId'
      }),

      +        },

      +        posts: {

      +          author: konro.one('users', { on: 'authorId', references: 'id'
      }),

      +        },

      +      }),

      +    });

      +

      +    expect(schema.tables).toBe(tableDefs);

      +    expect(schema.relations).toBeDefined();

      +    expect(schema.relations.users.posts).toBeDefined();

      +    expect(schema.relations.posts.author).toBeDefined();

      +    expect(schema.types).toBeNull(); // Runtime placeholder

      +  });

      +

      +  it('should handle schemas with no relations defined', () => {

      +    const tableDefs = {

      +      logs: {

      +        id: konro.id(),

      +        message: konro.string(),

      +      },

      +    };

      +

      +    const schema = konro.createSchema({

      +      tables: tableDefs,

      +    });

      +

      +    expect(schema.tables).toBe(tableDefs);

      +    expect(schema.relations).toEqual({});

      +  });

      +});
    patchStrategy: new-unified
  - type: write
    path: test/unit/Core/Insert.test.ts
    content: >-
      --- /dev/null

      +++ test/unit/Core/Insert.test.ts

      @@ -0,0 +1,87 @@

      +import { describe, it, expect, beforeEach } from 'bun:test';

      +import { testSchema } from '../../util';

      +import { _insertImpl } from '../../../src/operations';

      +import { DatabaseState } from '../../../src/types';

      +

      +describe('Unit > Core > Insert', () => {

      +    let emptyState: DatabaseState;

      +

      +    beforeEach(() => {

      +        emptyState = {

      +            users: { records: [], meta: { lastId: 0 } },

      +            posts: { records: [], meta: { lastId: 10 } },

      +            profiles: { records: [], meta: { lastId: 0 } },

      +            tags: { records: [], meta: { lastId: 0 } },

      +            posts_tags: { records: [], meta: { lastId: 0 } },

      +        };

      +    });

      +

      +    it('should return a new state object, not mutate the original state,
      on insert', () => {

      +        const originalState = structuredClone(emptyState);

      +        const [newState] = _insertImpl(emptyState, testSchema, 'users',
      [{ name: 'Test', email: 'test@test.com', age: 25 }]);

      +        

      +        expect(newState).not.toBe(originalState);

      +        expect(originalState.users.records.length).toBe(0);

      +        expect(newState.users.records.length).toBe(1);

      +    });

      +

      +    it('should correctly increment the lastId in the table meta', () => {

      +        const [newState] = _insertImpl(emptyState, testSchema, 'users',
      [{ name: 'Test', email: 'test@test.com', age: 25 }]);

      +        expect(newState.users.meta.lastId).toBe(1);

      +

      +        const [finalState] = _insertImpl(newState, testSchema, 'users',
      [{ name: 'Test2', email: 'test2@test.com', age: 30 }]);

      +        expect(finalState.users.meta.lastId).toBe(2);

      +    });

      +

      +    it('should assign the new id to the inserted record', () => {

      +        const [newState, inserted] = _insertImpl(emptyState, testSchema,
      'posts', [{ title: 'My Post', content: '...', authorId: 1 }]);

      +        expect(newState.posts.meta.lastId).toBe(11);

      +        expect(inserted[0].id).toBe(11);

      +        expect(newState.posts.records[0].id).toBe(11);

      +    });

      +

      +    it('should apply default values for fields that are not provided', ()
      => {

      +        const [newState, inserted] = _insertImpl(emptyState, testSchema,
      'users', [{ name: 'Default User', email: 'default@test.com', age: 30 }]);

      +        expect(inserted[0].isActive).toBe(true);

      +        expect(newState.users.records[0].isActive).toBe(true);

      +    });

      +

      +    it('should apply default values from a function call, like for
      dates', () => {

      +        const before = new Date();

      +        const [newState, inserted] = _insertImpl(emptyState, testSchema,
      'posts', [{ title: 'Dated Post', content: '...', authorId: 1 }]);

      +        const after = new Date();

      +

      +        const publishedAt = inserted[0].publishedAt as Date;

      +        expect(publishedAt).toBeInstanceOf(Date);

      +       
      expect(publishedAt.getTime()).toBeGreaterThanOrEqual(before.getTime());

      +       
      expect(publishedAt.getTime()).toBeLessThanOrEqual(after.getTime());

      +       
      expect(newState.posts.records[0].publishedAt).toEqual(publishedAt);

      +    });

      +

      +    it('should successfully insert multiple records in a single call', ()
      => {

      +        const usersToInsert = [

      +            { name: 'User A', email: 'a@test.com', age: 21 },

      +            { name: 'User B', email: 'b@test.com', age: 22 },

      +        ];

      +        const [newState, inserted] = _insertImpl(emptyState, testSchema,
      'users', usersToInsert);

      +

      +        expect(newState.users.records.length).toBe(2);

      +        expect(inserted.length).toBe(2);

      +        expect(newState.users.meta.lastId).toBe(2);

      +        expect(inserted[0].id).toBe(1);

      +        expect(inserted[1].id).toBe(2);

      +        expect(inserted[0].name).toBe('User A');

      +        expect(inserted[1].name).toBe('User B');

      +    });

      +

      +    it('should return both the new state and the newly created record(s)
      in the result tuple', () => {

      +        const userToInsert = { name: 'Single', email: 'single@test.com',
      age: 40 };

      +        const [newState, inserted] = _insertImpl(emptyState, testSchema,
      'users', [userToInsert]);

      +        

      +        expect(newState).toBeDefined();

      +        expect(inserted).toBeInstanceOf(Array);

      +        expect(inserted.length).toBe(1);

      +        expect(inserted[0].name).toBe('Single');

      +        expect(inserted[0].id).toBe(1);

      +    });

      +});
    patchStrategy: new-unified
  - type: write
    path: test/unit/Core/Update.test.ts
    content: >-
      --- /dev/null

      +++ test/unit/Core/Update.test.ts

      @@ -0,0 +1,114 @@

      +import { describe, it, expect, beforeEach } from 'bun:test';

      +import { testSchema } from '../../util';

      +import { _updateImpl } from '../../../src/operations';

      +import { DatabaseState, KRecord } from '../../../src/types';

      +

      +describe('Unit > Core > Update', () => {

      +    let testState: DatabaseState;

      +

      +    beforeEach(() => {

      +        testState = {

      +            users: {

      +                records: [

      +                    { id: 1, name: 'Alice', email: 'a@a.com', age: 30,
      isActive: true },

      +                    { id: 2, name: 'Bob', email: 'b@b.com', age: 25,
      isActive: true },

      +                    { id: 3, name: 'Charlie', email: 'c@c.com', age: 42,
      isActive: false },

      +                ],

      +                meta: { lastId: 3 },

      +            },

      +            posts: { records: [], meta: { lastId: 0 } },

      +            profiles: { records: [], meta: { lastId: 0 } },

      +            tags: { records: [], meta: { lastId: 0 } },

      +            posts_tags: { records: [], meta: { lastId: 0 } },

      +        };

      +    });

      +

      +    it('should return a new state object, not mutate the original state,
      on update', () => {

      +        const originalState = structuredClone(testState);

      +        const [newState] = _updateImpl(testState, testSchema, 'users', {
      age: 31 }, (r) => r.id === 1);

      +        

      +        expect(newState).not.toBe(originalState);

      +        expect(originalState.users.records[0].age).toBe(30);

      +        expect(newState.users.records.find(u => u.id ===
      1)?.age).toBe(31);

      +    });

      +

      +    it('should only update records that match the predicate function', ()
      => {

      +        const [newState, updated] = _updateImpl(testState, testSchema,
      'users', { isActive: true }, (r) => r.name === 'Charlie');

      +        

      +        expect(updated.length).toBe(1);

      +        expect(updated[0].id).toBe(3);

      +        expect(updated[0].isActive).toBe(true);

      +        expect(newState.users.records.find(u => u.id ===
      3)?.isActive).toBe(true);

      +        expect(newState.users.records.find(u => u.id ===
      1)?.isActive).toBe(true); // Unchanged

      +    });

      +

      +    it('should correctly modify the fields specified in the set payload',
      () => {

      +        const [newState, updated] = _updateImpl(testState, testSchema,
      'users', { age: 26, name: 'Robert' }, (r) => r.id === 2);

      +

      +        expect(updated.length).toBe(1);

      +        const updatedUser = newState.users.records.find(u => u.id === 2);

      +        expect(updatedUser?.name).toBe('Robert');

      +        expect(updatedUser?.age).toBe(26);

      +    });

      +

      +    it('should not allow changing the id of an updated record', () => {

      +        const payload = { id: 99, age: 50 };

      +        const [newState, updated] = _updateImpl(testState, testSchema,
      'users', payload, (r) => r.id === 1);

      +        

      +        expect(updated.length).toBe(1);

      +        expect(updated[0].id).toBe(1); // The id should remain 1

      +        expect(updated[0].age).toBe(50);

      +        

      +        const userInNewState = newState.users.records.find(u => u.age ===
      50);

      +        expect(userInNewState?.id).toBe(1);

      +

      +        const userWithOldId = newState.users.records.find(u => u.id ===
      1);

      +        expect(userWithOldId).toBeDefined();

      +        expect(userWithOldId?.age).toBe(50);

      +        

      +        const userWithNewId = newState.users.records.find(u => u.id ===
      99);

      +        expect(userWithNewId).toBeUndefined();

      +    });

      +

      +    it('should return an empty array of updated records if the predicate
      matches nothing', () => {

      +        const [newState, updated] = _updateImpl(testState, testSchema,
      'users', { age: 99 }, (r) => r.id === 999);

      +        expect(updated.length).toBe(0);

      +        expect(newState).toEqual(testState); // Should be a new object,
      but with identical content

      +        expect(newState).not.toBe(testState);

      +        expect(newState.users.records).toEqual(testState.users.records);

      +    });

      +

      +    it('should return both the new state and an array of the full,
      updated records in the result tuple', () => {

      +        const [newState, updated] = _updateImpl(testState, testSchema,
      'users', { isActive: false }, (r) => r.id === 1);

      +        expect(newState).toBeDefined();

      +        expect(updated).toBeInstanceOf(Array);

      +        expect(updated.length).toBe(1);

      +        expect(updated[0]).toEqual({

      +            id: 1,

      +            name: 'Alice',

      +            email: 'a@a.com',

      +            age: 30,

      +            isActive: false,

      +        });

      +    });

      +});
    patchStrategy: new-unified
  - type: write
    path: test/unit/Core/Delete.test.ts
    content: >-
      --- /dev/null

      +++ test/unit/Core/Delete.test.ts

      @@ -0,0 +1,52 @@

      +import { describe, it, expect, beforeEach } from 'bun:test';

      +import { _deleteImpl } from '../../../src/operations';

      +import { DatabaseState } from '../../../src/types';

      +

      +describe('Unit > Core > Delete', () => {

      +    let testState: DatabaseState;

      +

      +    beforeEach(() => {

      +        testState = {

      +            users: {

      +                records: [

      +                    { id: 1, name: 'Alice', email: 'a@a.com', age: 30 },

      +                    { id: 2, name: 'Bob', email: 'b@b.com', age: 25 },

      +                    { id: 3, name: 'Charlie', email: 'c@c.com', age: 42
      },

      +                ],

      +                meta: { lastId: 3 },

      +            },

      +            posts: { records: [], meta: { lastId: 0 } },

      +            profiles: { records: [], meta: { lastId: 0 } },

      +            tags: { records: [], meta: { lastId: 0 } },

      +            posts_tags: { records: [], meta: { lastId: 0 } },

      +        };

      +    });

      +

      +    it('should return a new state object, not mutate the original state,
      on delete', () => {

      +        const originalState = structuredClone(testState);

      +        const [newState] = _deleteImpl(testState, 'users', (r) => r.id
      === 1);

      +        

      +        expect(newState).not.toBe(originalState);

      +        expect(originalState.users.records.length).toBe(3);

      +        expect(newState.users.records.length).toBe(2);

      +    });

      +

      +    it('should only delete records that match the predicate function', ()
      => {

      +        const [newState, deleted] = _deleteImpl(testState, 'users', (r)
      => (r.age as number) > 35);

      +        

      +        expect(deleted.length).toBe(1);

      +        expect(deleted[0].id).toBe(3);

      +        expect(newState.users.records.length).toBe(2);

      +        expect(newState.users.records.find(u => u.id ===
      3)).toBeUndefined();

      +    });

      +

      +    it('should return both the new state and an array of the full,
      deleted records in the result tuple', () => {

      +        const [newState, deleted] = _deleteImpl(testState, 'users', (r)
      => r.id === 2);

      +

      +        expect(newState).toBeDefined();

      +        expect(deleted).toBeInstanceOf(Array);

      +        expect(deleted.length).toBe(1);

      +        expect(deleted[0]).toEqual({ id: 2, name: 'Bob', email:
      'b@b.com', age: 25 });

      +    });

      +

      +    it('should not modify the table meta lastId on delete', () => {

      +        const [newState] = _deleteImpl(testState, 'users', (r) => r.id
      === 3);

      +        expect(newState.users.meta.lastId).toBe(3);

      +    });

      +});
    patchStrategy: new-unified
  - type: write
    path: test/unit/Core/Query.test.ts
    content: >-
      --- /dev/null

      +++ test/unit/Core/Query.test.ts

      @@ -0,0 +1,93 @@

      +import { describe, it, expect, beforeEach } from 'bun:test';

      +import { testSchema } from '../../util';

      +import { _queryImpl } from '../../../src/operations';

      +import { DatabaseState } from '../../../src/types';

      +

      +describe('Unit > Core > Query', () => {

      +    let testState: DatabaseState;

      +

      +    beforeEach(() => {

      +        testState = {

      +            users: {

      +                records: [

      +                    { id: 1, name: 'Alice', age: 30, isActive: true },

      +                    { id: 2, name: 'Bob', age: 25, isActive: true },

      +                    { id: 3, name: 'Charlie', age: 42, isActive: false },

      +                    { id: 4, name: 'Denise', age: 30, isActive: true },

      +                ],

      +                meta: { lastId: 4 },

      +            },

      +            posts: { records: [], meta: { lastId: 0 } },

      +            profiles: { records: [], meta: { lastId: 0 } },

      +            tags: { records: [], meta: { lastId: 0 } },

      +            posts_tags: { records: [], meta: { lastId: 0 } },

      +        };

      +    });

      +

      +    it('should select all fields from a table when .select() is omitted',
      () => {

      +        const results = _queryImpl(testState, testSchema, { tableName:
      'users' });

      +        expect(results.length).toBe(4);

      +        expect(results[0]).toEqual({ id: 1, name: 'Alice', age: 30,
      isActive: true });

      +        expect(Object.keys(results[0]).length).toBe(4);

      +    });

      +

      +    it('should select only the specified fields when using .select()', ()
      => {

      +        const results = _queryImpl(testState, testSchema, { tableName:
      'users', select: ['name', 'age'] });

      +        expect(results.length).toBe(4);

      +        expect(results[0]).toEqual({ name: 'Alice', age: 30 });

      +        expect(Object.keys(results[0]).length).toBe(2);

      +    });

      +

      +    it('should filter records correctly using a where function', () => {

      +        const results = _queryImpl(testState, testSchema, { tableName:
      'users', where: (r) => (r.age as number) === 30 });

      +        expect(results.length).toBe(2);

      +        expect(results[0].name).toBe('Alice');

      +        expect(results[1].name).toBe('Denise');

      +    });

      +

      +    it('should limit the number of returned records correctly using
      .limit()', () => {

      +        const results = _queryImpl(testState, testSchema, { tableName:
      'users', limit: 2 });

      +        expect(results.length).toBe(2);

      +        expect(results[0].id).toBe(1);

      +        expect(results[1].id).toBe(2);

      +    });

      +

      +    it('should skip the correct number of records using .offset()', () =>
      {

      +        const results = _queryImpl(testState, testSchema, { tableName:
      'users', offset: 2 });

      +        expect(results.length).toBe(2);

      +        expect(results[0].id).toBe(3);

      +        expect(results[1].id).toBe(4);

      +    });

      +

      +    it('should correctly handle limit and offset together for
      pagination', () => {

      +        const results = _queryImpl(testState, testSchema, { tableName:
      'users', offset: 1, limit: 2 });

      +        expect(results.length).toBe(2);

      +        expect(results[0].id).toBe(2);

      +        expect(results[1].id).toBe(3);

      +    });

      +

      +    it('should return an array of all matching records when using
      .all()', () => {

      +        // This is implicit in _queryImpl, the test just verifies the
      base case

      +        const results = _queryImpl(testState, testSchema, { tableName:
      'users', where: r => r.isActive === true });

      +        expect(results).toBeInstanceOf(Array);

      +        expect(results.length).toBe(3);

      +    });

      +

      +    it('should return the first matching record when using .first()', ()
      => {

      +        // This is simulated by adding limit: 1

      +        const results = _queryImpl(testState, testSchema, { tableName:
      'users', where: r => (r.age as number) > 28, limit: 1 });

      +        expect(results.length).toBe(1);

      +        expect(results[0].id).toBe(1);

      +    });

      +

      +    it('should return null when .first() finds no matching record', () =>
      {

      +        // This is simulated by _queryImpl returning [] and the caller
      handling it

      +        const results = _queryImpl(testState, testSchema, { tableName:
      'users', where: r => (r.age as number) > 50, limit: 1 });

      +        expect(results.length).toBe(0);

      +    });

      +});
    patchStrategy: new-unified
  - type: write
    path: test/unit/Core/Query-With.test.ts
    content: >-
      --- /dev/null

      +++ test/unit/Core/Query-With.test.ts

      @@ -0,0 +1,108 @@

      +import { describe, it, expect, beforeEach } from 'bun:test';

      +import { testSchema } from '../../util';

      +import { _queryImpl } from '../../../src/operations';

      +import { DatabaseState } from '../../../src/types';

      +

      +describe('Unit > Core > Query-With', () => {

      +    let testState: DatabaseState;

      +

      +    beforeEach(() => {

      +        testState = {

      +            users: {

      +                records: [

      +                    { id: 1, name: 'Alice' },

      +                    { id: 2, name: 'Bob' },

      +                ],

      +                meta: { lastId: 2 },

      +            },

      +            posts: {

      +                records: [

      +                    { id: 10, title: 'Alice Post 1', authorId: 1 },

      +                    { id: 11, title: 'Bob Post 1', authorId: 2 },

      +                    { id: 12, title: 'Alice Post 2', authorId: 1 },

      +                ],

      +                meta: { lastId: 12 },

      +            },

      +            profiles: {

      +                records: [

      +                    { id: 100, bio: 'Bio for Alice', userId: 1 },

      +                ],

      +                meta: { lastId: 100 },

      +            },

      +            tags: { records: [], meta: { lastId: 0 } },

      +            posts_tags: { records: [], meta: { lastId: 0 } },

      +        };

      +    });

      +

      +    it('should resolve a `one` relationship and attach it to the parent
      record', () => {

      +        const results = _queryImpl(testState, testSchema, {

      +            tableName: 'posts',

      +            where: r => r.id === 10,

      +            with: { author: true }

      +        });

      +

      +        expect(results.length).toBe(1);

      +        const post = results[0];

      +        expect(post.author).toBeDefined();

      +        expect(post.author.id).toBe(1);

      +        expect(post.author.name).toBe('Alice');

      +    });

      +

      +    it('should resolve a `many` relationship and attach it as an array',
      () => {

      +        const results = _queryImpl(testState, testSchema, {

      +            tableName: 'users',

      +            where: r => r.id === 1,

      +            with: { posts: true }

      +        });

      +

      +        expect(results.length).toBe(1);

      +        const user = results[0];

      +        expect(user.posts).toBeDefined();

      +        expect(user.posts).toBeInstanceOf(Array);

      +        expect(user.posts.length).toBe(2);

      +        expect(user.posts[0].title).toBe('Alice Post 1');

      +        expect(user.posts[1].title).toBe('Alice Post 2');

      +    });

      +

      +    it('should filter nested records within a .with() clause', () => {

      +        const results = _queryImpl(testState, testSchema, {

      +            tableName: 'users',

      +            where: r => r.id === 1,

      +            with: {

      +                posts: {

      +                    where: (post) => (post.title as
      string).includes('Post 2')

      +                }

      +            }

      +        });

      +

      +        expect(results.length).toBe(1);

      +        const user = results[0];

      +        expect(user.posts).toBeDefined();

      +        expect(user.posts.length).toBe(1);

      +        expect(user.posts[0].id).toBe(12);

      +    });

      +

      +    it('should handle multiple relations at once', () => {

      +        const results = _queryImpl(testState, testSchema, {

      +            tableName: 'users',

      +            where: r => r.id === 1,

      +            with: {

      +                posts: true,

      +                profile: true

      +            }

      +        });

      +        

      +        expect(results.length).toBe(1);

      +        const user = results[0];

      +        expect(user.posts).toBeInstanceOf(Array);

      +        expect(user.posts.length).toBe(2);

      +        expect(user.profile).toBeDefined();

      +        expect(user.profile.bio).toBe('Bio for Alice');

      +    });

      +

      +    it('should return null for a `one` relation if no related record is
      found', () => {

      +        const results = _queryImpl(testState, testSchema, {

      +            tableName: 'users',

      +            where: r => r.id === 2, // Bob has no profile

      +            with: { profile: true }

      +        });

      +

      +        expect(results.length).toBe(1);

      +        const user = results[0];

      +        expect(user.profile).toBeNull();

      +    });

      +

      +    it('should return an empty array for a `many` relation if no related
      records are found', () => {

      +        // Add a user with no posts

      +        testState.users.records.push({ id: 3, name: 'Charlie' });

      +        const results = _queryImpl(testState, testSchema, {

      +            tableName: 'users',

      +            where: r => r.id === 3,

      +            with: { posts: true }

      +        });

      +

      +        expect(results.length).toBe(1);

      +        const user = results[0];

      +        expect(user.posts).toBeInstanceOf(Array);

      +        expect(user.posts.length).toBe(0);

      +    });

      +});
    patchStrategy: new-unified
  - type: write
    path: test/unit/Validation/Constraints.test.ts
    content: >-
      --- /dev/null

      +++ test/unit/Validation/Constraints.test.ts

      @@ -0,0 +1,65 @@

      +import { describe, it, expect, beforeEach } from 'bun:test';

      +import { testSchema } from '../../util';

      +import { _insertImpl, _updateImpl } from '../../../src/operations';

      +import { DatabaseState } from '../../../src/types';

      +import { KonroValidationError } from '../../../src/utils/error.util';

      +

      +describe('Unit > Validation > Constraints', () => {

      +    let testState: DatabaseState;

      +

      +    beforeEach(() => {

      +        testState = {

      +            users: {

      +                records: [{ id: 1, name: 'Alice', email:
      'alice@example.com', age: 30, isActive: true }],

      +                meta: { lastId: 1 },

      +            },

      +            posts: { records: [], meta: { lastId: 0 } },

      +            profiles: { records: [], meta: { lastId: 0 } },

      +            tags: { records: [], meta: { lastId: 0 } },

      +            posts_tags: { records: [], meta: { lastId: 0 } },

      +        };

      +    });

      +

      +    // NOTE: These tests are expected to fail until validation is
      implemented in core operations.

      +    // This is intentional to highlight the missing functionality as per
      the test plan.

      +    

      +    it('should throw a KonroValidationError when inserting a record with
      a non-unique value', () => {

      +        const user = { name: 'Bob', email: 'alice@example.com', age: 25
      };

      +        // This should throw because 'alice@example.com' is already used
      and `email` is unique.

      +        expect(() => _insertImpl(testState, testSchema, 'users',
      [user])).toThrow(KonroValidationError);

      +    });

      +

      +    it('should throw a KonroValidationError for a string that violates a
      format: email constraint', () => {

      +        const user = { name: 'Bob', email: 'bob@invalid', age: 25 };

      +        // This should throw because the email format is invalid.

      +        expect(() => _insertImpl(testState, testSchema, 'users',
      [user])).toThrow(KonroValidationError);

      +    });

      +

      +    it('should throw a KonroValidationError for a number smaller than the
      specified min', () => {

      +        const user = { name: 'Bob', email: 'bob@example.com', age: 17 };
      // age.min is 18

      +        // This should throw because age is below min.

      +        expect(() => _insertImpl(testState, testSchema, 'users',
      [user])).toThrow(KonroValidationError);

      +    });

      +

      +    it('should throw a KonroValidationError for a string shorter than the
      specified min', () => {

      +        const user = { name: 'B', email: 'bob@example.com', age: 25 }; //
      name.min is 2

      +        // This should throw because name is too short.

      +        expect(() => _insertImpl(testState, testSchema, 'users',
      [user])).toThrow(KonroValidationError);

      +    });

      +    

      +    it('should throw a KonroValidationError on update for a non-unique
      value', () => {

      +        // Add another user to create conflict

      +        testState.users.records.push({ id: 2, name: 'Charlie', email:
      'charlie@example.com', age: 40, isActive: true });

      +        testState.users.meta.lastId = 2;

      +

      +        const predicate = (r: any) => r.id === 2;

      +        const data = { email: 'alice@example.com' }; // Try to update
      charlie's email to alice's

      +

      +        expect(() => _updateImpl(testState, testSchema, 'users', data,
      predicate)).toThrow(KonroValidationError);

      +    });

      +});
    patchStrategy: new-unified
snapshot:
  test/util.ts: null
  test/unit/Schema/ColumnHelpers.test.ts: null
  test/unit/Schema/RelationHelpers.test.ts: null
  test/unit/Schema/CreateSchema.test.ts: null
  test/unit/Core/Insert.test.ts: null
  test/unit/Core/Update.test.ts: null
  test/unit/Core/Delete.test.ts: null
  test/unit/Core/Query.test.ts: null
  test/unit/Core/Query-With.test.ts: null
  test/unit/Validation/Constraints.test.ts: null
  src/db.ts: >-
    import { KonroSchema } from './schema';

    import { StorageAdapter } from './adapter';

    import { DatabaseState, KRecord } from './types';

    import { _queryImpl, _insertImpl, _updateImpl, _deleteImpl, createEmptyState
    as createEmptyStateImpl, QueryDescriptor } from './operations';

    import { createPredicateFromPartial } from './utils/predicate.util';


    // A helper to normalize a predicate argument

    const normalizePredicate = <T extends KRecord>(
      predicate: Partial<T> | ((record: T) => boolean)
    ): ((record: KRecord) => boolean) =>
      // The cast is necessary due to function argument contravariance.
      // The internal operations work on the wider `KRecord`, while the fluent API provides the specific `T`.
      (typeof predicate === 'function' ? predicate : createPredicateFromPartial(predicate)) as (record: KRecord) => boolean;

    // --- TYPE-SAFE FLUENT API BUILDERS ---


    interface ChainedQueryBuilder<T> {
      where(predicate: Partial<T> | ((record: T) => boolean)): this;
      with(relations: QueryDescriptor['with']): this;
      limit(count: number): this;
      offset(count: number): this;
      all(): Promise<T[]>;
      first(): Promise<T | null>;
    }


    interface QueryBuilder<S extends KonroSchema<any, any>> {
      from<T extends keyof S['tables']>(tableName: T): ChainedQueryBuilder<S['types'][T]>;
    }


    interface UpdateBuilder<T> {
      set(data: Partial<T>): {
        where(predicate: Partial<T> | ((record: T) => boolean)): [DatabaseState, T[]];
      };
    }


    interface DeleteBuilder<T> {
      where(predicate: Partial<T> | ((record: T) => boolean)): [DatabaseState, T[]];
    }


    export interface DbContext<S extends KonroSchema<any, any>> {
      schema: S;
      adapter: StorageAdapter;
      read(): Promise<DatabaseState>;
      write(state: DatabaseState): Promise<void>;
      createEmptyState(): DatabaseState;

      query(state: DatabaseState): QueryBuilder<S>;
      insert<T extends keyof S['types']>(state: DatabaseState, tableName: T, values: S['types'][T] | Readonly<S['types'][T]>[]): [DatabaseState, S['types'][T] | S['types'][T][]];
      update<T extends keyof S['tables']>(state: DatabaseState, tableName: T): UpdateBuilder<S['types'][T]>;
      delete<T extends keyof S['tables']>(state: DatabaseState, tableName: T): DeleteBuilder<S['types'][T]>;
    }


    export const createDatabase = <S extends KonroSchema<any, any>>(options: {
    schema: S, adapter: StorageAdapter }): DbContext<S> => {
      const { schema, adapter } = options;

      return {
        schema,
        adapter,
        read: () => adapter.read(schema),
        write: (state) => adapter.write(state),
        createEmptyState: () => createEmptyStateImpl(schema),

        insert: (state, tableName, values) => {
          const valsArray = Array.isArray(values) ? values : [values];
          const [newState, inserted] = _insertImpl(state, schema, tableName as string, valsArray as KRecord[]);
          const result = Array.isArray(values) ? inserted : inserted[0];
          return [newState, result] as [DatabaseState, S['types'][typeof tableName] | S['types'][typeof tableName][]];
        },

        query: (state: DatabaseState): QueryBuilder<S> => ({
          from: <T extends keyof S['tables']>(tableName: T): ChainedQueryBuilder<S['types'][T]> => {
            const descriptor: QueryDescriptor = { tableName: tableName as string };

            const builder: ChainedQueryBuilder<S['types'][T]> = {
              where: (predicate) => {
                descriptor.where = normalizePredicate(predicate);
                return builder;
              },
              with: (relations) => {
                descriptor.with = relations;
                return builder;
              },
              limit: (count) => {
                descriptor.limit = count;
                return builder;
              },
              offset: (count) => {
                descriptor.offset = count;
                return builder;
              },
              all: async () => _queryImpl(state, schema, descriptor) as S['types'][T][],
              first: async () => (_queryImpl(state, schema, { ...descriptor, limit: 1 })[0] ?? null) as S['types'][T] | null,
            };
            return builder;
          },
        }),

        update: <T extends keyof S['tables']>(state: DatabaseState, tableName: T): UpdateBuilder<S['types'][T]> => ({
          set: (data) => ({
            where: (predicate) => {
              const [newState, updatedRecords] = _updateImpl(state, tableName as string, data as Partial<KRecord>, normalizePredicate(predicate));
              return [newState, updatedRecords as S['types'][T][]];
            },
          }),
        }),

        delete: <T extends keyof S['tables']>(state: DatabaseState, tableName: T): DeleteBuilder<S['types'][T]> => ({
          where: (predicate) => {
            const [newState, deletedRecords] = _deleteImpl(state, tableName as string, normalizePredicate(predicate));
            return [newState, deletedRecords as S['types'][T][]];
          },
        }),
      };
    };
  src/operations.ts: >
    import { DatabaseState, KRecord } from './types';

    import { KonroSchema, RelationDefinition } from './schema';

    import { KonroError } from './utils/error.util';


    // --- HELPERS ---



    /** Creates a pristine, empty database state from a schema. */

    export const createEmptyState = (schema: KonroSchema<any, any>):
    DatabaseState => {
      const state: DatabaseState = {};
      for (const tableName in schema.tables) {
        state[tableName] = { records: [], meta: { lastId: 0 } };
      }
      return state;
    };


    // --- QUERY ---


    export interface QueryDescriptor {
      tableName: string;
      where?: (record: KRecord) => boolean;
      with?: Record<string, boolean | { where?: (record: KRecord) => boolean }>;
      limit?: number;
      offset?: number;
    }


    export const _queryImpl = (state: DatabaseState, schema: KonroSchema<any,
    any>, descriptor: QueryDescriptor): KRecord[] => {
      const tableState = state[descriptor.tableName];
      if (!tableState) return [];

      // 1. Filter
      let results = descriptor.where ? tableState.records.filter(descriptor.where) : [...tableState.records];

      // 2. Eager load relations (`with`)
      if (descriptor.with) {
        results = structuredClone(results); // Clone to avoid mutating state
        for (const record of results) {
          for (const relationName in descriptor.with) {
            const relationDef = schema.relations[descriptor.tableName]?.[relationName];
            if (!relationDef) continue;

            const relatedRecords = findRelatedRecords(state, record, relationDef);

            const withOpts = descriptor.with[relationName];
            const nestedWhere = typeof withOpts === 'object' ? withOpts.where : undefined;

            const filteredRelatedRecords = nestedWhere ? relatedRecords.filter(nestedWhere) : relatedRecords;
            if (relationDef.relationType === 'one') {
              record[relationName] = filteredRelatedRecords[0] ?? null;
            } else {
              record[relationName] = filteredRelatedRecords;
            }
          }
        }
      }

      // 3. Paginate
      const offset = descriptor.offset ?? 0;
      const limit = descriptor.limit ?? results.length;
      return results.slice(offset, offset + limit);
    };


    const findRelatedRecords = (state: DatabaseState, record: KRecord,
    relationDef: RelationDefinition) => {
      const foreignKey = record[relationDef.on];
      const targetTable = state[relationDef.targetTable];

      if (foreignKey === undefined || !targetTable) return [];

      // one-to-many: 'on' is PK on current table, 'references' is FK on target
      if (relationDef.relationType === 'many') {
        return targetTable.records.filter(r => r[relationDef.references] === foreignKey);
      }

      // many-to-one: 'on' is FK on current table, 'references' is PK on target
      if (relationDef.relationType === 'one') {
        return targetTable.records.filter(r => r[relationDef.references] === foreignKey);
      }

      return [];
    };



    // --- INSERT ---


    export const _insertImpl = (state: DatabaseState, schema: KonroSchema<any,
    any>, tableName: string, values: KRecord[]): [DatabaseState, KRecord[]] => {
      const newState = structuredClone(state);
      const tableState = newState[tableName];
      if (!tableState) throw KonroError(`Table "${tableName}" does not exist in the database state.`);
      const tableSchema = schema.tables[tableName];
      const insertedRecords: KRecord[] = [];

      for (const value of values) {
        const newRecord: KRecord = { ...value };
        // Handle IDs and defaults
        for (const colName in tableSchema) {
          const colDef = tableSchema[colName];
          if (colDef.dataType === 'id') {
            tableState.meta.lastId++;
            newRecord[colName] = tableState.meta.lastId;
          }
          if (newRecord[colName] === undefined && colDef.options?.default !== undefined) {
            newRecord[colName] = typeof colDef.options.default === 'function' ? colDef.options.default() : colDef.options.default;
          }
        }
        tableState.records.push(newRecord);
        insertedRecords.push(newRecord);
      }

      return [newState, insertedRecords];
    };


    // --- UPDATE ---


    export const _updateImpl = (state: DatabaseState, tableName: string, data:
    Partial<KRecord>, predicate: (record: KRecord) => boolean): [DatabaseState,
    KRecord[]] => {
      const newState = structuredClone(state);
      const tableState = newState[tableName];
      if (!tableState) throw KonroError(`Table "${tableName}" does not exist in the database state.`);
      const updatedRecords: KRecord[] = [];

      tableState.records = tableState.records.map(record => {
        if (predicate(record)) {
          const updatedRecord = { ...record, ...data };
          updatedRecords.push(updatedRecord);
          return updatedRecord;
        }
        return record;
      });

      return [newState, updatedRecords];
    };



    // --- DELETE ---


    export const _deleteImpl = (state: DatabaseState, tableName: string,
    predicate: (record: KRecord) => boolean): [DatabaseState, KRecord[]] => {
      const newState = structuredClone(state);
      const tableState = newState[tableName];
      if (!tableState) throw KonroError(`Table "${tableName}" does not exist in the database state.`);
      const deletedRecords: KRecord[] = [];

      const keptRecords = tableState.records.filter(record => {
        if (predicate(record)) {
          deletedRecords.push(record);
          return false;
        }
        return true;
      });

      tableState.records = keptRecords;
      return [newState, deletedRecords];
    };
approved: true

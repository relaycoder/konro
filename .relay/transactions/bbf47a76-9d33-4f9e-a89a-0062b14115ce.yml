uuid: bbf47a76-9d33-4f9e-a89a-0062b14115ce
projectId: konro
createdAt: '2025-07-09T07:23:54.370Z'
linesAdded: 512
linesRemoved: 407
gitCommitMsg: 'refactor(types): centralize types and implement error codes'
promptSummary: >-
  Refactor to centralize types into `src/types.ts` and implement a structured
  error code system.
reasoning:
  - >-
    This request involves a significant refactoring to centralize type
    definitions and implement a structured error-handling system. Here's my
    plan:
  - >-
    1.  **Introduce Structured Errors**: I'll create a new file,
    `src/utils/error.codes.ts`, to store all error messages as templates with
    unique codes. The existing `src/utils/error.util.ts` will be updated to use
    these codes, allowing for more specific and maintainable error reporting.
  - >-
    2.  **Centralize Type Definitions**: To improve code organization and reduce
    duplication, I will move all shared type definitions and interfaces from
    various files (`schema.ts`, `adapter.ts`, `db.ts`, etc.) into a single
    source of truth: `src/types.ts`.
  - '3.  **Refactor Existing Files**: I will update the affected files to:'
  - '*   Remove the now-redundant local type definitions.'
  - '*   Import the necessary types from the new central `src/types.ts`.'
  - >-
    *   Replace the old string-based error throwing with the new code-based
    system.
  - >-
    This refactoring will make the codebase more robust, easier to navigate, and
    simpler to maintain.
  - First, I'll create the new file for error codes.
  - Next, I'll update the error utility to use these codes.
  - Now, I will centralize all types into `src/types.ts`.
  - I will now refactor the remaining files.
operations:
  - type: write
    path: src/utils/error.codes.ts
    content: |-
      export const KONRO_ERROR_CODES = {
        // General Errors
        E001: 'An unexpected error occurred: {{details}}',

        // Storage Errors
        E100: 'Invalid storage strategy configuration.',
        E101: "The '{{format}}' format requires the '{{dependency}}' package to be installed. Please run 'npm install {{dependency}}'.",
        E102: 'Unsupported or invalid format specified: {{format}}.',
        E103: 'Failed to parse file at "{{filepath}}". It may be corrupt or not a valid {{format}} file. Original error: {{details}}',
        E104: "The 'on-demand' mode requires the 'multi-file' or 'per-record' storage strategy.",
        E105: `The 'per-record' strategy only supports 'json' or 'yaml' formats.`,
        E106: `The '{{format}}' format only supports 'on-demand' mode with a 'multi-file' strategy.`,
        E107: `Invalid file adapter options: missing storage strategy.`,

        // Schema & Data Errors
        E200: 'Table "{{tableName}}" does not exist in the database state.',
        E201: 'Schema for table "{{tableName}}" not found.',
        E202: `Table "{{tableName}}" must have an 'id' column for 'per-record' storage.`,
        E203: 'Aggregation `{{aggType}}` requires a column.',

        // Validation Errors
        E300: `Value '{{value}}' for column '{{columnName}}' must be unique.`,
        E301: `String '{{value}}' for column '{{columnName}}' is too short (min: {{min}}).`,
        E302: `String '{{value}}' for column '{{columnName}}' is too long (max: {{max}}).`,
        E303: `Value '{{value}}' for column '{{columnName}}' is not a valid email.`,
        E304: `Number {{value}} for column '{{columnName}}' is too small (min: {{min}}).`,
        E305: `Number {{value}} for column '{{columnName}}' is too large (max: {{max}}).`,

        // DB Context Errors
        E400: "The method '{{methodName}}' is not supported in 'on-demand' mode.",
      };

      export type KonroErrorCode = keyof typeof KONRO_ERROR_CODES;
    patchStrategy: replace
  - type: write
    path: src/utils/error.util.ts
    content: >-
      import { KONRO_ERROR_CODES, type KonroErrorCode } from './error.codes';


      type ErrorContext = Record<string, string | number | undefined | null>;


      const renderTemplate = (template: string, context: ErrorContext): string
      => {
        return template.replace(/\{\{([^}]+)\}\}/g, (_match, key) => {
          const value = context[key.trim()];
          return value !== undefined && value !== null ? String(value) : `{{${key}}}`;
        });
      };


      // Per user request: no classes. Using constructor functions for errors.

      const createKonroError = (name: string) => {
        function KonroErrorConstructor(messageOrContext: string | ({ code: KonroErrorCode } & ErrorContext)) {
          let message: string;
          let code: KonroErrorCode | undefined;

          if (typeof messageOrContext === 'string') {
            message = messageOrContext;
          } else {
            code = messageOrContext.code;
            const template = KONRO_ERROR_CODES[code] || 'Unknown error code.';
            message = `[${code}] ${renderTemplate(template, messageOrContext)}`;
          }

          const error = new Error(message) as Error & { code?: KonroErrorCode };
          error.name = name;
          error.code = code;
          Object.setPrototypeOf(error, KonroErrorConstructor.prototype);
          return error;
        }
        Object.setPrototypeOf(KonroErrorConstructor.prototype, Error.prototype);
        return KonroErrorConstructor;
      };


      /** Base constructor for all Konro-specific errors. */

      export const KonroError = createKonroError('KonroError');


      /** Thrown for storage adapter-related issues. */

      export const KonroStorageError = createKonroError('KonroStorageError');


      /** Thrown for schema validation errors. */

      export const KonroValidationError =
      createKonroError('KonroValidationError');


      /** Thrown when a resource is not found. */

      export const KonroNotFoundError = createKonroError('KonroNotFoundError');
    patchStrategy: replace
  - type: write
    path: src/types.ts
    content: >-
      // --- Schema Definition Types (from schema.ts) ---


      /** The definition for a database column, created by helpers like
      `konro.string()`. */

      export interface ColumnDefinition<T> {
        readonly _type: 'column';
        readonly dataType: 'id' | 'string' | 'number' | 'boolean' | 'date' | 'object';
        readonly options: any;
        readonly _tsType?: T; // Phantom type, does not exist at runtime
      }


      /** The definition for a table relationship, created by `konro.one()` or
      `konro.many()`. */

      export interface BaseRelationDefinition {
        readonly _type: 'relation';
        readonly targetTable: string;
        readonly on: string;
        readonly references: string;
        readonly onDelete?: 'CASCADE' | 'SET NULL';
      }


      export interface OneRelationDefinition extends BaseRelationDefinition {
        readonly relationType: 'one';
      }


      export interface ManyRelationDefinition extends BaseRelationDefinition {
        readonly relationType: 'many';
      }


      export type RelationDefinition = OneRelationDefinition |
      ManyRelationDefinition;


      /** The definition for a data aggregation, created by `konro.count()`,
      `konro.sum()`, etc. */

      export interface AggregationDefinition {
        readonly _type: 'aggregation';
        readonly aggType: 'count' | 'sum' | 'avg' | 'min' | 'max';
        readonly column?: string;
      }


      /** Infers the underlying TypeScript type from a `ColumnDefinition`. e.g.,
      `ColumnDefinition<string>` => `string`. */

      type InferColumnType<C> = C extends ColumnDefinition<infer T> ? T : never;


      /** A mapping of table names to their base model types (columns only, no
      relations). */

      export type BaseModels<TTables extends Record<string, any>> = {
        [TableName in keyof TTables]: {
          [ColumnName in keyof TTables[TableName]]: InferColumnType<TTables[TableName][ColumnName]>;
        };
      };


      /** A mapping of table names to their full model types, including
      relations. */

      type Models<
        TTables extends Record<string, any>,
        TRelations extends Record<string, any>,
        TBaseModels extends Record<keyof TTables, any>
      > = {
        [TableName in keyof TTables]: TBaseModels[TableName] &
          (TableName extends keyof TRelations
            ? {
                [RelationName in keyof TRelations[TableName]]?: TRelations[TableName][RelationName] extends OneRelationDefinition
                  ? Models<TTables, TRelations, TBaseModels>[TRelations[TableName][RelationName]['targetTable']] | null
                  : TRelations[TableName][RelationName] extends ManyRelationDefinition
                  ? Models<TTables, TRelations, TBaseModels>[TRelations[TableName][RelationName]['targetTable']][]
                  : never;
              }
            : {});
      };


      /** Finds all column names in a table definition that are optional for
      insertion (i.e., `id` or has a `default`). */

      type OptionalCreateKeys<TTableDef> = {
        [K in keyof TTableDef]: TTableDef[K] extends { dataType: 'id' }
          ? K
          : TTableDef[K] extends { options: { default: unknown } }
          ? K
          : never;
      }[keyof TTableDef];


      /** A mapping of table names to their "create" types, used for
      `db.insert`. */

      type CreateModels<
        TTables extends Record<string, any>,
        TBaseModels extends Record<keyof TTables, any>
      > = {
        [TableName in keyof TTables]: Omit<
          {
            // Required fields
            [K in Exclude<keyof TBaseModels[TableName], OptionalCreateKeys<TTables[TableName]>>]: TBaseModels[TableName][K];
          } & {
            // Optional fields
            [K in OptionalCreateKeys<TTables[TableName]>]?: TBaseModels[TableName][K];
          },
          // 'id' is always omitted from create types
          'id'
        >;
      };


      /** The publicly exposed structure of a fully-processed Konro schema. */

      export interface KonroSchema<
        TTables extends Record<string, any>,
        TRelations extends Record<string, any>
      > {
        tables: TTables;
        relations: TRelations;
        /** The full, relational types for each table model. */
        types: Models<TTables, TRelations, BaseModels<TTables>>;
        /** The base types for each table model, without any relations. */
        base: BaseModels<TTables>;
        /** The types for creating new records, with defaults and `id` made optional. */
        create: CreateModels<TTables, BaseModels<TTables>>;
      }



      // --- Generic & Core Types ---


      /** A generic representation of a single record within a table. It uses
      `unknown` for values to enforce type-safe access. */

      export type KRecord = Record<string, unknown>;


      /** Represents the state of a single table, including its records and
      metadata. */

      export type TableState<T extends KRecord = KRecord> = {
        records: T[];
        meta: {
          lastId: number;
        };
      };


      /** The in-memory representation of the entire database. It is a plain,
      immutable object. */

      export type DatabaseState<S extends KonroSchema<any, any> | unknown =
      unknown> = S extends KonroSchema<any, any>
        ? {
            [TableName in keyof S['tables']]: TableState<BaseModels<S['tables']>[TableName]>;
          }
        : {
            [tableName: string]: TableState;
          };


      // --- FS Provider Types (from fs.ts) ---

      export interface FsProvider {
        readFile(filepath: string): Promise<string | null>;
        writeFile(filepath: string, content: string, encoding: 'utf-8'): Promise<void>;
        rename(oldPath: string, newPath: string): Promise<void>;
        mkdir(dir: string, options: { recursive: true }): Promise<string | undefined>;
        readdir(dir: string): Promise<string[]>;
        unlink(filepath: string): Promise<void>;
      }



      // --- Serializer Types (from utils/serializer.util.ts) ---

      export type Serializer = {
        parse: <T>(data: string, tableSchema?: Record<string, ColumnDefinition<any>>) => T;
        stringify: (obj: any) => string;
      };



      // --- Storage Adapter Types (from adapter.ts) ---


      export interface StorageAdapter {
        read<S extends KonroSchema<any, any>>(schema: S): Promise<DatabaseState<S>>;
        write(state: DatabaseState<any>, schema: KonroSchema<any, any>): Promise<void>;
        readonly mode: 'in-memory' | 'on-demand';
      }


      export interface FileStorageAdapter extends StorageAdapter {
        readonly options: FileAdapterOptions;
        readonly fs: FsProvider;
        readonly serializer: Serializer;
        readonly fileExtension: string;
      }


      type SingleFileStrategy = { single: { filepath: string }; multi?: never;
      perRecord?: never };

      type MultiFileStrategy = { multi: { dir: string }; single?: never;
      perRecord?: never };

      type PerRecordStrategy = { perRecord: { dir: string }; single?: never;
      multi?: never };


      export type FileAdapterOptions = {
        format: 'json' | 'yaml' | 'csv' | 'xlsx';
        fs?: FsProvider;
        /**
         * Defines the data access strategy.
         * - `in-memory`: (Default) Loads the entire database into memory on init. Fast for small/medium datasets.
         * - `on-demand`: Reads from the file system for each query. Slower but supports larger datasets. Requires 'multi-file' or 'per-record' strategy.
         */
        mode?: 'in-memory' | 'on-demand';
      } & (SingleFileStrategy | MultiFileStrategy | PerRecordStrategy);



      // --- Operation Descriptor Types (from operations.ts) ---


      export type WithClause = Record<string, boolean | {
        where?: (record: KRecord) => boolean;
        select?: Record<string, ColumnDefinition<unknown>>;
        with?: WithClause;
      }>;


      export interface QueryDescriptor {
        tableName: string;
        select?: Record<string, ColumnDefinition<unknown> | RelationDefinition>;
        where?: (record: KRecord) => boolean;
        with?: WithClause;
        limit?: number;
        offset?: number;
        withDeleted?: boolean;
      }


      export interface AggregationDescriptor extends QueryDescriptor {
        aggregations: Record<string, AggregationDefinition>;
      }



      // --- DB Context & Fluent API Types (from db.ts) ---


      type RelatedModel<T> = T extends (infer R)[] ? R : T extends (infer R |
      null) ? R : T;


      export type WithArgument<TAll> = {
        [K in keyof TAll as NonNullable<TAll[K]> extends any[] | object ? K : never]?: boolean | ({
          where?: (record: RelatedModel<NonNullable<TAll[K]>>) => boolean;
        } & (
          | { select: Record<string, ColumnDefinition<unknown>>; with?: never }
          | { select?: never; with?: WithArgument<RelatedModel<NonNullable<TAll[K]>>> }
        ));
      };


      export type ResolveWith<
        S extends KonroSchema<any, any>,
        TName extends keyof S['tables'],
        TWith extends WithArgument<S['types'][TName]>
      > = {
          [K in keyof TWith & keyof S['relations'][TName]]:
              S['relations'][TName][K] extends { relationType: 'many' }
                  ? (
                      TWith[K] extends { select: infer TSelect }
                          ? ({ [P in keyof TSelect]: InferColumnType<TSelect[P]> })[]
                          : TWith[K] extends { with: infer TNestedWith }
                              ? (S['base'][S['relations'][TName][K]['targetTable']] & ResolveWith<S, S['relations'][TName][K]['targetTable'], TNestedWith & WithArgument<S['types'][S['relations'][TName][K]['targetTable']]>>)[]
                              : S['base'][S['relations'][TName][K]['targetTable']][]
                    )
                  : S['relations'][TName][K] extends { relationType: 'one' }
                      ? (
                          TWith[K] extends { select: infer TSelect }
                              ? ({ [P in keyof TSelect]: InferColumnType<TSelect[P]> }) | null
                              : TWith[K] extends { with: infer TNestedWith }
                                  ? (S['base'][S['relations'][TName][K]['targetTable']] & ResolveWith<S, S['relations'][TName][K]['targetTable'], TNestedWith & WithArgument<S['types'][S['relations'][TName][K]['targetTable']]>>) | null
                                  : S['base'][S['relations'][TName][K]['targetTable']] | null
                        )
                      : never
      };


      interface ChainedQueryBuilder<S extends KonroSchema<any, any>, TName
      extends keyof S['tables'], TReturn> {
        select(fields: Record<string, ColumnDefinition<unknown> | RelationDefinition>): this;
        where(predicate: Partial<S['base'][TName]> | ((record: S['base'][TName]) => boolean)): this;
        withDeleted(): this;
        with<W extends WithArgument<S['types'][TName]>>(relations: W): ChainedQueryBuilder<S, TName, TReturn & ResolveWith<S, TName, W>>;
        limit(count: number): this;
        offset(count: number): this;
        all(): TReturn[];
        first(): TReturn | null;
        aggregate<TAggs extends Record<string, AggregationDefinition>>(
          aggregations: TAggs
        ): { [K in keyof TAggs]: number | null };
      }


      interface QueryBuilder<S extends KonroSchema<any, any>> {
        from<T extends keyof S['tables']>(tableName: T): ChainedQueryBuilder<S, T, S['base'][T]>;
      }


      interface UpdateBuilder<S extends KonroSchema<any, any>, TBase, TCreate> {
        set(data: Partial<TCreate>): {
          where(predicate: Partial<TBase> | ((record: TBase) => boolean)): [DatabaseState<S>, TBase[]];
        };
      }


      interface DeleteBuilder<S extends KonroSchema<any, any>, TBase> {
        where(predicate: Partial<TBase> | ((record: TBase) => boolean)): [DatabaseState<S>, TBase[]];
      }


      export interface InMemoryDbContext<S extends KonroSchema<any, any>> {
        schema: S;
        adapter: StorageAdapter;
        read(): Promise<DatabaseState<S>>;
        write(state: DatabaseState<S>): Promise<void>;
        createEmptyState(): DatabaseState<S>;

        query(state: DatabaseState<S>): QueryBuilder<S>;
        insert<T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T, values: S['create'][T]): [DatabaseState<S>, S['base'][T]];
        insert<T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T, values: Readonly<S['create'][T]>[]): [DatabaseState<S>, S['base'][T][]];
        update<T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T): UpdateBuilder<S, S['base'][T], S['create'][T]>;
        delete<T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T): DeleteBuilder<S, S['base'][T]>;
      }


      interface OnDemandChainedQueryBuilder<S extends KonroSchema<any, any>,
      TName extends keyof S['tables'], TReturn> {
        select(fields: Record<string, ColumnDefinition<unknown> | RelationDefinition>): this;
        where(predicate: Partial<S['base'][TName]> | ((record: S['base'][TName]) => boolean)): this;
        withDeleted(): this;
        with<W extends WithArgument<S['types'][TName]>>(relations: W): OnDemandChainedQueryBuilder<S, TName, TReturn & ResolveWith<S, TName, W>>;
        limit(count: number): this;
        offset(count: number): this;
        all(): Promise<TReturn[]>;
        first(): Promise<TReturn | null>;
        aggregate<TAggs extends Record<string, AggregationDefinition>>(
          aggregations: TAggs
        ): Promise<{ [K in keyof TAggs]: number | null }>;
      }


      interface OnDemandQueryBuilder<S extends KonroSchema<any, any>> {
        from<T extends keyof S['tables']>(tableName: T): OnDemandChainedQueryBuilder<S, T, S['base'][T]>;
      }


      interface OnDemandUpdateBuilder<TBase, TCreate> {
        set(data: Partial<TCreate>): {
          where(predicate: Partial<TBase> | ((record: TBase) => boolean)): Promise<TBase[]>;
        };
      }


      interface OnDemandDeleteBuilder<TBase> {
        where(predicate: Partial<TBase> | ((record: TBase) => boolean)): Promise<TBase[]>;
      }


      export interface OnDemandDbContext<S extends KonroSchema<any, any>> {
        schema: S;
        adapter: StorageAdapter;
        read(): Promise<never>;
        write(): Promise<never>;
        createEmptyState(): DatabaseState<S>;

        query(): OnDemandQueryBuilder<S>;
        insert<T extends keyof S['tables']>(tableName: T, values: S['create'][T]): Promise<S['base'][T]>;
        insert<T extends keyof S['tables']>(tableName: T, values: Readonly<S['create'][T]>[]): Promise<S['base'][T][]>;
        update<T extends keyof S['tables']>(tableName: T): OnDemandUpdateBuilder<S['base'][T], S['create'][T]>;
        delete<T extends keyof S['tables']>(tableName: T): OnDemandDeleteBuilder<S['base'][T]>;
      }


      export type DbContext<S extends KonroSchema<any, any>> =
      InMemoryDbContext<S> | OnDemandDbContext<S>;
    patchStrategy: replace
  - type: write
    path: src/schema.ts
    content: >-
      --- src/schema.ts

      +++ src/schema.ts

      @@ -8,114 +8,17 @@
       // type declarations (`interface User { ... }`) and ensuring they never get out of sync.
       //
       
      -// --- TYPE INFERENCE HELPERS ---

      -

      -/** Infers the underlying TypeScript type from a `ColumnDefinition`.
      e.g., `ColumnDefinition<string>` => `string`. */

      -type InferColumnType<C> = C extends ColumnDefinition<infer T> ? T :
      never;

      -

      -/** A mapping of table names to their base model types (columns only, no
      relations). */

      -export type BaseModels<TTables extends Record<string, any>> = {

      -  [TableName in keyof TTables]: {

      -    [ColumnName in keyof TTables[TableName]]:
      InferColumnType<TTables[TableName][ColumnName]>;

      -  };

      -};

      -

      -/**

      - * A mapping of table names to their full model types, including
      relations.

      - * This is a recursive type that resolves relationships to other full
      models.

      - */

      -type Models<

      -  TTables extends Record<string, any>,

      -  TRelations extends Record<string, any>,

      -  TBaseModels extends Record<keyof TTables, any>

      -> = {

      -  [TableName in keyof TTables]: TBaseModels[TableName] &

      -    (TableName extends keyof TRelations

      -      ? {

      -          [RelationName in keyof TRelations[TableName]]?:
      TRelations[TableName][RelationName] extends OneRelationDefinition

      -            ? // `targetTable` is a string literal, so we can use it to
      index `Models`

      -              Models<TTables, TRelations,
      TBaseModels>[TRelations[TableName][RelationName]['targetTable']] | null

      -            : TRelations[TableName][RelationName] extends
      ManyRelationDefinition

      -            ? Models<TTables, TRelations,
      TBaseModels>[TRelations[TableName][RelationName]['targetTable']][]

      -            : never;

      -        }

      -      : {});

      -};

      -

      -/** Finds all column names in a table definition that are optional for
      insertion (i.e., `id` or has a `default`). */

      -type OptionalCreateKeys<TTableDef> = {

      -  [K in keyof TTableDef]: TTableDef[K] extends { dataType: 'id' }

      -    ? K

      -    : TTableDef[K] extends { options: { default: unknown } }

      -    ? K

      -    : never;

      -}[keyof TTableDef];

      -

      -/**

      - * A mapping of table names to their "create" types, used for
      `db.insert`.

      - * It takes the base model, makes keys with defaults optional, and
      removes the `id` field.

      - */

      -type CreateModels<

      -  TTables extends Record<string, any>,

      -  TBaseModels extends Record<keyof TTables, any>

      -> = {

      -  [TableName in keyof TTables]: Omit<

      -    {

      -      // Required fields

      -      [K in Exclude<keyof TBaseModels[TableName],
      OptionalCreateKeys<TTables[TableName]>>]: TBaseModels[TableName][K];

      -    } & {

      -      // Optional fields

      -      [K in OptionalCreateKeys<TTables[TableName]>]?:
      TBaseModels[TableName][K];

      -    },

      -    // 'id' is always omitted from create types

      -    'id'

      -  >;

      -};

      -

      -

      -// --- PUBLIC API TYPES ---

      -

      -/** The publicly exposed structure of a fully-processed Konro schema. */

      -export interface KonroSchema<

      -  TTables extends Record<string, any>,

      -  TRelations extends Record<string, any>

      -> {

      -  tables: TTables;

      -  relations: TRelations;

      -  /** The full, relational types for each table model. */

      -  types: Models<TTables, TRelations, BaseModels<TTables>>;

      -  /** The base types for each table model, without any relations. */

      -  base: BaseModels<TTables>;

      -  /** The types for creating new records, with defaults and `id` made
      optional. */

      -  create: CreateModels<TTables, BaseModels<TTables>>;

      -}

      -

      -/** The definition for a database column, created by helpers like
      `konro.string()`. */

      -export interface ColumnDefinition<T> {

      -  readonly _type: 'column';

      -  readonly dataType: 'id' | 'string' | 'number' | 'boolean' | 'date' |
      'object';

      -  readonly options: any;

      -  readonly _tsType?: T; // Phantom type, does not exist at runtime

      -}

      -

      -/** The definition for a table relationship, created by `konro.one()` or
      `konro.many()`. */

      -export interface BaseRelationDefinition {

      -  readonly _type: 'relation';

      -  readonly targetTable: string;

      -  readonly on: string;

      -  readonly references: string;

      -  readonly onDelete?: 'CASCADE' | 'SET NULL';

      -}

      -

      -export interface OneRelationDefinition extends BaseRelationDefinition {

      -  readonly relationType: 'one';

      -}

      -

      -export interface ManyRelationDefinition extends BaseRelationDefinition {

      -  readonly relationType: 'many';

      -}

      -

      -export type RelationDefinition = OneRelationDefinition |
      ManyRelationDefinition;

      -

      -/** The definition for a data aggregation, created by `konro.count()`,
      `konro.sum()`, etc. */

      -export interface AggregationDefinition {

      -  readonly _type: 'aggregation';

      -  readonly aggType: 'count' | 'sum' | 'avg' | 'min' | 'max';

      -  readonly column?: string;

      -}

      -

      +import type {

      +  KonroSchema,

      +  ColumnDefinition,

      +  BaseRelationDefinition,

      +  OneRelationDefinition,

      +  ManyRelationDefinition,

      +  AggregationDefinition

      +} from './types';
       
       // --- SCHEMA BUILDER FUNCTION ---
       
      @@ -128,7 +31,7 @@
       export const createSchema = <
         const TDef extends {
           tables: Record<string, Record<string, ColumnDefinition<any>>>;
      -    relations?: (tables: TDef['tables']) => Record<string, Record<string,
      BaseRelationDefinition>>;

      +    relations?: (tables: TDef['tables']) => Record<string, Record<string,
      OneRelationDefinition | ManyRelationDefinition>>;
         }
       >(
         schemaDef: TDef
    patchStrategy: new-unified
  - type: write
    path: src/fs.ts
    content: >-
      --- src/fs.ts

      +++ src/fs.ts

      @@ -1,15 +1,6 @@
       import { promises as fs } from 'fs';
       import path from 'path';
       import { TEMP_FILE_SUFFIX } from './utils/constants';
      -

      -export interface FsProvider {

      -  readFile(filepath: string): Promise<string | null>;

      -  writeFile(filepath: string, content: string, encoding: 'utf-8'):
      Promise<void>;

      -  rename(oldPath: string, newPath: string): Promise<void>;

      -  mkdir(dir: string, options: { recursive: true }): Promise<string |
      undefined>;

      -  readdir(dir: string): Promise<string[]>;

      -  unlink(filepath: string): Promise<void>;

      -}

      +import type { FsProvider } from './types';
       
       export const defaultFsProvider: FsProvider = {
         readFile: async (filepath: string): Promise<string | null> => {
    patchStrategy: new-unified
  - type: write
    path: src/adapter.ts
    content: >-
      --- src/adapter.ts

      +++ src/adapter.ts

      @@ -1,49 +1,24 @@
       import path from 'path';
      -import type { DatabaseState, KRecord, TableState } from './types';

      +import type {

      +  DatabaseState,

      +  KRecord,

      +  TableState,

      +  StorageAdapter,

      +  FileStorageAdapter,

      +  FileAdapterOptions,

      +  ColumnDefinition,

      +  KonroSchema,

      +  Serializer,

      +  FsProvider,

      +} from './types';
       import { createEmptyState } from './operations';
      -import type { ColumnDefinition, KonroSchema } from './schema';

      -import { getSerializer, type Serializer } from './utils/serializer.util';

      -import { FsProvider, defaultFsProvider, writeAtomic } from './fs';

      +import { getSerializer } from './utils/serializer.util';

      +import { defaultFsProvider, writeAtomic } from './fs';
       import { KonroError, KonroStorageError } from './utils/error.util';
       import { TEMP_FILE_SUFFIX } from './utils/constants';
       
      -export interface StorageAdapter {

      -  read<S extends KonroSchema<any, any>>(schema: S):
      Promise<DatabaseState<S>>;

      -  write(state: DatabaseState<any>, schema: KonroSchema<any, any>):
      Promise<void>;

      -  readonly mode: 'in-memory' | 'on-demand';

      -}

      -

      -export interface FileStorageAdapter extends StorageAdapter {

      -  readonly options: FileAdapterOptions;

      -  readonly fs: FsProvider;

      -  readonly serializer: Serializer;

      -  readonly fileExtension: string;

      -}

      -

      -type SingleFileStrategy = { single: { filepath: string }; multi?: never;
      perRecord?: never };

      -type MultiFileStrategy = { multi: { dir: string }; single?: never;
      perRecord?: never };

      -type PerRecordStrategy = { perRecord: { dir: string }; single?: never;
      multi?: never };

      -

      -export type FileAdapterOptions = {

      -  format: 'json' | 'yaml' | 'csv' | 'xlsx';

      -  fs?: FsProvider;

      -  /**

      -   * Defines the data access strategy.

      -   * - `in-memory`: (Default) Loads the entire database into memory on
      init. Fast for small/medium datasets.

      -   * - `on-demand`: Reads from the file system for each query. Slower but
      supports larger datasets. Requires 'multi-file' or 'per-record' strategy.

      -   */

      -  mode?: 'in-memory' | 'on-demand';

      -} & (SingleFileStrategy | MultiFileStrategy | PerRecordStrategy);

      -
       export function createFileAdapter(options: FileAdapterOptions & { mode: 'on-demand' }): FileStorageAdapter & { mode: 'on-demand' };
       export function createFileAdapter(options: FileAdapterOptions & { mode?: 'in-memory' | undefined }): FileStorageAdapter & { mode: 'in-memory' };
       export function createFileAdapter(options: FileAdapterOptions): FileStorageAdapter;
       export function createFileAdapter(options: FileAdapterOptions): FileStorageAdapter {
         const serializer = getSerializer(options.format);
         const fileExtension = `.${options.format}`;
      @@ -51,15 +26,15 @@
         const mode = options.mode ?? 'in-memory';
       
         if (options.perRecord && options.format !== 'json' && options.format !== 'yaml') {
      -    throw KonroError(`The 'per-record' strategy only supports 'json' or
      'yaml' formats.`);

      +    throw KonroError({ code: 'E105' });
         }
       
         const isTabular = options.format === 'csv' || options.format === 'xlsx';
         if (isTabular && (mode !== 'on-demand' || !options.multi)) {
      -    throw KonroError(`The '${options.format}' format only supports
      'on-demand' mode with a 'multi-file' strategy.`);

      +    throw KonroError({ code: 'E106', format: options.format });
         }
       
         if (mode === 'on-demand' && options.single) {
      -    throw KonroError("The 'on-demand' mode requires the 'multi-file' or
      'per-record' storage strategy.");

      +    throw KonroError({ code: 'E104' });
         }
       
         const strategy = createStrategy(options, { fs, serializer, fileExtension, mode });
      @@ -91,7 +66,7 @@
           return createPerRecordStrategy(options.perRecord, context);
         }
         // This case should be prevented by the types, but as a safeguard:
      -  throw KonroError('Invalid file adapter options: missing storage
      strategy.');

      +  throw KonroError({ code: 'E107' });
       }
       
       /** Creates the strategy for reading/writing the entire database to a single file. */
      @@ -105,7 +80,7 @@
             return serializer.parse<T>(data, schema);
           } catch (e) {
             const message = e instanceof Error ? e.message : String(e);
      -      throw KonroStorageError(`Failed to parse file at "${filepath}". It
      may be corrupt or not a valid ${context.fileExtension.slice(1)} file.
      Original error: ${message}`);

      +      throw KonroStorageError({ code: 'E103', filepath, format:
      context.fileExtension.slice(1), details: message });
           }
         };
       
      @@ -128,7 +103,7 @@
             return serializer.parse<T>(data, schema);
           } catch (e) {
             const message = e instanceof Error ? e.message : String(e);
      -      throw KonroStorageError(`Failed to parse file at "${filepath}". It
      may be corrupt or not a valid ${fileExtension.slice(1)} file. Original
      error: ${message}`);

      +      throw KonroStorageError({ code: 'E103', filepath, format:
      fileExtension.slice(1), details: message });
           }
         };
       
      @@ -162,7 +137,7 @@
             return serializer.parse<T>(data);
           } catch (e) {
             const message = e instanceof Error ? e.message : String(e);
      -      throw KonroStorageError(`Failed to parse file at "${filepath}". It
      may be corrupt or not a valid ${context.fileExtension.slice(1)} file.
      Original error: ${message}`);

      +      throw KonroStorageError({ code: 'E103', filepath, format:
      context.fileExtension.slice(1), details: message });
           }
         };
       
      @@ -203,7 +178,7 @@
               await writeAtomic(path.join(tableDir, '_meta.json'), JSON.stringify(tableState.meta, null, 2), fs);
       
               const idColumn = Object.keys(schema.tables[tableName]).find((k) => schema.tables[tableName][k]?.dataType === 'id');
      -        if (!idColumn) throw KonroError(`Table "${tableName}" must have
      an 'id' column for 'per-record' storage.`);

      +        if (!idColumn) throw KonroError({ code: 'E202', tableName });
       
               const currentFiles = new Set(tableState.records.map((r: KRecord) => `${r[idColumn]}${fileExtension}`));
               const existingFiles = (await fs.readdir(tableDir)).filter(f => !f.startsWith('_meta') && !f.endsWith(TEMP_FILE_SUFFIX));
    patchStrategy: new-unified
  - type: write
    path: src/operations.ts
    content: >-
      --- src/operations.ts

      +++ src/operations.ts

      @@ -1,7 +1,15 @@
       import { randomUUID } from 'crypto';
      -import { DatabaseState, KRecord } from './types';

      -import { KonroSchema, RelationDefinition, ColumnDefinition,
      AggregationDefinition } from './schema';

      +import type {

      +  DatabaseState,

      +  KRecord,

      +  KonroSchema,

      +  RelationDefinition,

      +  ColumnDefinition,

      +  AggregationDefinition,

      +  WithClause,

      +  QueryDescriptor,

      +  AggregationDescriptor,

      +} from './types';
       import { KonroError, KonroValidationError } from './utils/error.util';
       
       // --- HELPERS ---
      @@ -18,25 +26,6 @@
       
       // --- QUERY ---
       
      -interface WithOptions {

      -  select?: Record<string, ColumnDefinition<unknown>>;

      -  where?: (record: KRecord) => boolean;

      -  with?: WithClause;

      -}

      -type WithClause = Record<string, boolean | WithOptions>;

      -

      -export interface QueryDescriptor {

      -  tableName: string;

      -  select?: Record<string, ColumnDefinition<unknown> |
      RelationDefinition>;

      -  where?: (record: KRecord) => boolean;

      -  with?: WithClause;

      -  limit?: number;

      -  offset?: number;

      -  withDeleted?: boolean;

      -}

      -

      -export interface AggregationDescriptor extends QueryDescriptor {

      -  aggregations: Record<string, AggregationDefinition>;

      -}

      -
       const _processWith = <S extends KonroSchema<any, any>>(
         recordsToProcess: KRecord[],
         currentTableName: string,
      @@ -75,7 +64,7 @@
             // Then, apply select on the (potentially already processed) related records
             if (nestedSelect) {
               const targetTableSchema = schema.tables[relationDef.targetTable];
      -        if (!targetTableSchema) throw KonroError(`Schema for table
      "${relationDef.targetTable}" not found.`);

      +        if (!targetTableSchema) throw KonroError({ code: 'E201',
      tableName: relationDef.targetTable });
       
               processedRelatedRecords = processedRelatedRecords.map(rec => {
                 const newRec: KRecord = {};
      @@ -107,7 +96,7 @@
         if (!tableState) return [];
       
         const tableSchema = schema.tables[descriptor.tableName];
      -  if (!tableSchema) throw KonroError(`Schema for table
      "${descriptor.tableName}" not found.`);

      +  if (!tableSchema) throw KonroError({ code: 'E201', tableName:
      descriptor.tableName });
         const deletedAtColumn = Object.keys(tableSchema).find(key => tableSchema[key]?.options?._konro_sub_type === 'deletedAt');
       
         // 1. Filter
      @@ -181,7 +170,7 @@
           }
       
           if (!aggDef.column) {
      -      throw KonroError(`Aggregation '${aggDef.aggType}' requires a
      column.`);

      +      throw KonroError({ code: 'E203', aggType: aggDef.aggType });
           }
           const column = aggDef.column;
       
      @@ -213,11 +202,11 @@
       
       export const _insertImpl = <S extends KonroSchema<any, any>>(state: DatabaseState, schema: S, tableName: string, values: KRecord[]): [DatabaseState, KRecord[]] => {
         const oldTableState = state[tableName];
      -  if (!oldTableState) throw KonroError(`Table "${tableName}" does not
      exist in the database state.`);

      +  if (!oldTableState) throw KonroError({ code: 'E200', tableName });
       
         // To maintain immutability, we deep-clone only the table being modified.
         const tableState = structuredClone(oldTableState);
         const tableSchema = schema.tables[tableName];
      -  if (!tableSchema) throw KonroError(`Schema for table "${tableName}" not
      found.`);

      +  if (!tableSchema) throw KonroError({ code: 'E201', tableName });
         const insertedRecords: KRecord[] = [];
       
         for (const value of values) {
      @@ -258,11 +247,11 @@
       
       export const _updateImpl = <S extends KonroSchema<any, any>>(state: DatabaseState, schema: S, tableName: string, data: Partial<KRecord>, predicate: (record: KRecord) => boolean): [DatabaseState, KRecord[]] => {
         const oldTableState = state[tableName];
      -  if (!oldTableState) throw KonroError(`Table "${tableName}" does not
      exist in the database state.`);

      +  if (!oldTableState) throw KonroError({ code: 'E200', tableName });
       
         const tableSchema = schema.tables[tableName];
         if (!tableSchema) {
      -    throw KonroError(`Schema for table "${tableName}" not found.`);

      +    throw KonroError({ code: 'E201', tableName });
         }
       
         const updatedRecords: KRecord[] = [];
      @@ -351,9 +340,9 @@
       
       export const _deleteImpl = (state: DatabaseState, schema: KonroSchema<any, any>, tableName: string, predicate: (record: KRecord) => boolean): [DatabaseState, KRecord[]] => {
         const oldTableState = state[tableName];
      -  if (!oldTableState) throw KonroError(`Table "${tableName}" does not
      exist in the database state.`);

      +  if (!oldTableState) throw KonroError({ code: 'E200', tableName });
         const tableSchema = schema.tables[tableName];
      -  if (!tableSchema) throw KonroError(`Schema for table "${tableName}" not
      found.`);

      +  if (!tableSchema) throw KonroError({ code: 'E201', tableName });
       
         const deletedAtColumn = Object.keys(tableSchema).find(key => tableSchema[key]?.options?._konro_sub_type === 'deletedAt');
       
      @@ -395,35 +384,35 @@
       
           // Validate unique constraint
           if (options.unique && existingRecords.some(r => r[columnName] === value)) {
      -      throw KonroValidationError(`Value '${String(value)}' for column
      '${columnName}' must be unique`);

      +      throw KonroValidationError({ code: 'E300', value: String(value),
      columnName });
           }
       
           // Validate string constraints
           if (colDef.dataType === 'string' && typeof value === 'string') {
             // Min length
             if (options.min !== undefined && value.length < options.min) {
      -        throw KonroValidationError(`String '${value}' for column
      '${columnName}' is too short (min: ${options.min})`);

      +        throw KonroValidationError({ code: 'E301', value, columnName,
      min: options.min });
             }
       
             // Max length
             if (options.max !== undefined && value.length > options.max) {
      -        throw KonroValidationError(`String '${value}' for column
      '${columnName}' is too long (max: ${options.max})`);

      +        throw KonroValidationError({ code: 'E302', value, columnName,
      max: options.max });
             }
       
             // Format validation
             if (options.format === 'email' && !isValidEmail(value)) {
      -        throw KonroValidationError(`Value '${value}' for column
      '${columnName}' is not a valid email`);

      +        throw KonroValidationError({ code: 'E303', value, columnName });
             }
           }
       
           // Validate number constraints
           if (colDef.dataType === 'number' && typeof value === 'number') {
             // Min value
             if (options.min !== undefined && value < options.min) {
      -        throw KonroValidationError(`Number ${value} for column
      '${columnName}' is too small (min: ${options.min})`);

      +        throw KonroValidationError({ code: 'E304', value, columnName,
      min: options.min });
             }
       
             // Max value
             if (options.max !== undefined && value > options.max) {
      -        throw KonroValidationError(`Number ${value} for column
      '${columnName}' is too large (max: ${options.max})`);

      +        throw KonroValidationError({ code: 'E305', value, columnName,
      max: options.max });
             }
           }
         }
    patchStrategy: new-unified
  - type: write
    path: src/db.ts
    content: >-
      --- src/db.ts

      +++ src/db.ts

      @@ -1,139 +1,41 @@
       import path from 'path';
      -import { AggregationDefinition, ColumnDefinition, KonroSchema,
      RelationDefinition } from './schema';

      -import { StorageAdapter, FileStorageAdapter } from './adapter';

      -import { DatabaseState, KRecord, TableState } from './types';

      -import { _queryImpl, _insertImpl, _updateImpl, _deleteImpl,
      createEmptyState as createEmptyStateImpl, QueryDescriptor, _aggregateImpl,
      AggregationDescriptor } from './operations';

      +import type {

      +  AggregationDefinition,

      +  ColumnDefinition,

      +  KonroSchema,

      +  RelationDefinition,

      +  StorageAdapter,

      +  FileStorageAdapter,

      +  DatabaseState,

      +  KRecord,

      +  TableState,

      +  QueryDescriptor,

      +  AggregationDescriptor,

      +  WithArgument,

      +  ResolveWith,

      +  ChainedQueryBuilder,

      +  QueryBuilder,

      +  UpdateBuilder,

      +  DeleteBuilder,

      +  InMemoryDbContext,

      +  OnDemandChainedQueryBuilder,

      +  OnDemandQueryBuilder,

      +  OnDemandUpdateBuilder,

      +  OnDemandDeleteBuilder,

      +  OnDemandDbContext,

      +  DbContext,

      +} from './types';

      +import {

      +  _queryImpl,

      +  _insertImpl,

      +  _updateImpl,

      +  _deleteImpl,

      +  createEmptyState as createEmptyStateImpl,

      +  _aggregateImpl,

      +} from './operations';
       import { createPredicateFromPartial } from './utils/predicate.util';
       import { KonroError, KonroStorageError } from './utils/error.util';
       import { writeAtomic } from './fs';
      -

      -// A helper to normalize a predicate argument

      -const normalizePredicate = <T extends KRecord>(

      -  predicate: Partial<T> | ((record: T) => boolean)

      -): ((record: KRecord) => boolean) =>

      -  // The cast is necessary due to function argument contravariance.

      -  // The internal operations work on the wider `KRecord`, while the
      fluent API provides the specific `T`.

      -  (typeof predicate === 'function' ? predicate :
      createPredicateFromPartial(predicate)) as (record: KRecord) => boolean;

      -

      -// --- TYPE HELPERS for Fluent API ---

      -

      -type RelatedModel<T> = T extends (infer R)[] ? R : T extends (infer R |
      null) ? R : T;

      -

      -// TAll is the full relational model type, e.g. schema.types.users

      -type WithArgument<TAll> = { // e.g. TAll = S['types']['users']

      -  [K in keyof TAll as NonNullable<TAll[K]> extends any[] | object ? K :
      never]?: boolean | ({

      -    where?: (record: RelatedModel<NonNullable<TAll[K]>>) => boolean;

      -  } & (

      -    | { select: Record<string, ColumnDefinition<unknown>>; with?: never }

      -    | { select?: never; with?:
      WithArgument<RelatedModel<NonNullable<TAll[K]>>> }

      -  ));

      -};

      -

      -type ResolveWith<

      -  S extends KonroSchema<any, any>,

      -  TName extends keyof S['tables'],

      -  TWith extends WithArgument<S['types'][TName]>

      -> = { // TName='users', TWith={posts: {with: {author: true}}}

      -    [K in keyof TWith & keyof S['relations'][TName]]:

      -        S['relations'][TName][K] extends { relationType: 'many' }

      -            ? ( // 'many' relation -> array result. K = 'posts'

      -                TWith[K] extends { select: infer TSelect }

      -                    ? ({ [P in keyof TSelect]:
      InferColumnType<TSelect[P]> })[]

      -                    : TWith[K] extends { with: infer TNestedWith }

      -                        //
      S['relations']['users']['posts']['targetTable'] = 'posts'

      -                        ?
      (S['base'][S['relations'][TName][K]['targetTable']] & ResolveWith<S,
      S['relations'][TName][K]['targetTable'], TNestedWith &
      WithArgument<S['types'][S['relations'][TName][K]['targetTable']]>>)[]

      -                        // posts: true.

      -                        :
      S['base'][S['relations'][TName][K]['targetTable']][]

      -              )

      -            : S['relations'][TName][K] extends { relationType: 'one' }

      -                ? ( // 'one' relation -> nullable object result

      -                    TWith[K] extends { select: infer TSelect }

      -                        ? ({ [P in keyof TSelect]:
      InferColumnType<TSelect[P]> }) | null

      -                        : TWith[K] extends { with: infer TNestedWith }

      -                            ?
      (S['base'][S['relations'][TName][K]['targetTable']] & ResolveWith<S,
      S['relations'][TName][K]['targetTable'], TNestedWith &
      WithArgument<S['types'][S['relations'][TName][K]['targetTable']]>>) | null

      -                            :
      S['base'][S['relations'][TName][K]['targetTable']] | null

      -                  )

      -                : never

      -};

      -

      -// InferColumnType is not exported from schema, so we need it here too.

      -type InferColumnType<C> = C extends ColumnDefinition<infer T> ? T :
      never;

      -

      -// --- IN-MEMORY API TYPES (STATEFUL) ---

      -

      -interface ChainedQueryBuilder<S extends KonroSchema<any, any>, TName
      extends keyof S['tables'], TReturn> {

      -  select(fields: Record<string, ColumnDefinition<unknown> |
      RelationDefinition>): this;

      -  where(predicate: Partial<S['base'][TName]> | ((record:
      S['base'][TName]) => boolean)): this;

      -  withDeleted(): this;

      -  with<W extends WithArgument<S['types'][TName]>>(relations: W):
      ChainedQueryBuilder<S, TName, TReturn & ResolveWith<S, TName, W>>;

      -  limit(count: number): this;

      -  offset(count: number): this;

      -  all(): TReturn[];

      -  first(): TReturn | null;

      -  aggregate<TAggs extends Record<string, AggregationDefinition>>(

      -    aggregations: TAggs

      -  ): { [K in keyof TAggs]: number | null };

      -}

      -

      -interface QueryBuilder<S extends KonroSchema<any, any>> {

      -  from<T extends keyof S['tables']>(tableName: T): ChainedQueryBuilder<S,
      T, S['base'][T]>;

      -}

      -

      -interface UpdateBuilder<S extends KonroSchema<any, any>, TBase, TCreate>
      {

      -  set(data: Partial<TCreate>): {

      -    where(predicate: Partial<TBase> | ((record: TBase) => boolean)):
      [DatabaseState<S>, TBase[]];

      -  };

      -}

      -

      -interface DeleteBuilder<S extends KonroSchema<any, any>, TBase> {

      -  where(predicate: Partial<TBase> | ((record: TBase) => boolean)):
      [DatabaseState<S>, TBase[]];

      -}

      -

      -export interface InMemoryDbContext<S extends KonroSchema<any, any>> {

      -  schema: S;

      -  adapter: StorageAdapter;

      -  read(): Promise<DatabaseState<S>>;

      -  write(state: DatabaseState<S>): Promise<void>;

      -  createEmptyState(): DatabaseState<S>;

      -

      -  query(state: DatabaseState<S>): QueryBuilder<S>;

      -  insert<T extends keyof S['tables']>(state: DatabaseState<S>, tableName:
      T, values: S['create'][T]): [DatabaseState<S>, S['base'][T]];

      -  insert<T extends keyof S['tables']>(state: DatabaseState<S>, tableName:
      T, values: Readonly<S['create'][T]>[]): [DatabaseState<S>,
      S['base'][T][]];

      -  update<T extends keyof S['tables']>(state: DatabaseState<S>, tableName:
      T): UpdateBuilder<S, S['base'][T], S['create'][T]>;

      -  delete<T extends keyof S['tables']>(state: DatabaseState<S>, tableName:
      T): DeleteBuilder<S, S['base'][T]>;

      -}

      -

      -

      -// --- ON-DEMAND API TYPES (STATELESS & ASYNC) ---

      -

      -interface OnDemandChainedQueryBuilder<S extends KonroSchema<any, any>,
      TName extends keyof S['tables'], TReturn> {

      -  select(fields: Record<string, ColumnDefinition<unknown> |
      RelationDefinition>): this;

      -  where(predicate: Partial<S['base'][TName]> | ((record:
      S['base'][TName]) => boolean)): this;

      -  withDeleted(): this;

      -  with<W extends WithArgument<S['types'][TName]>>(relations: W):
      OnDemandChainedQueryBuilder<S, TName, TReturn & ResolveWith<S, TName, W>>;

      -  limit(count: number): this;

      -  offset(count: number): this;

      -  all(): Promise<TReturn[]>;

      -  first(): Promise<TReturn | null>;

      -  aggregate<TAggs extends Record<string, AggregationDefinition>>(

      -    aggregations: TAggs

      -  ): Promise<{ [K in keyof TAggs]: number | null }>;

      -}

      -

      -interface OnDemandQueryBuilder<S extends KonroSchema<any, any>> {

      -  from<T extends keyof S['tables']>(tableName: T):
      OnDemandChainedQueryBuilder<S, T, S['base'][T]>;

      -}

      -

      -interface OnDemandUpdateBuilder<TBase, TCreate> {

      -  set(data: Partial<TCreate>): {

      -    where(predicate: Partial<TBase> | ((record: TBase) => boolean)):
      Promise<TBase[]>;

      -  };

      -}

      -

      -interface OnDemandDeleteBuilder<TBase> {

      -  where(predicate: Partial<TBase> | ((record: TBase) => boolean)):
      Promise<TBase[]>;

      -}

      -

      -export interface OnDemandDbContext<S extends KonroSchema<any, any>> {

      -  schema: S;

      -  adapter: StorageAdapter;

      -  read(): Promise<never>; // Not supported in on-demand mode

      -  write(): Promise<never>; // Not supported in on-demand mode

      -  createEmptyState(): DatabaseState<S>;

      -

      -  query(): OnDemandQueryBuilder<S>;

      -  insert<T extends keyof S['tables']>(tableName: T, values:
      S['create'][T]): Promise<S['base'][T]>;

      -  insert<T extends keyof S['tables']>(tableName: T, values:
      Readonly<S['create'][T]>[]): Promise<S['base'][T][]>;

      -  update<T extends keyof S['tables']>(tableName: T):
      OnDemandUpdateBuilder<S['base'][T], S['create'][T]>;

      -  delete<T extends keyof S['tables']>(tableName: T):
      OnDemandDeleteBuilder<S['base'][T]>;

      -}

      -

      -// --- DbContext Union Type ---

      -export type DbContext<S extends KonroSchema<any, any>> =
      InMemoryDbContext<S> | OnDemandDbContext<S>;
       
       // --- CORE LOGIC (STATELESS & PURE) ---
       
      @@ -142,6 +44,14 @@
        * forming the foundation for both in-memory and on-demand modes.
        */
       function createCoreDbContext<S extends KonroSchema<any, any>>(schema: S) {
      +  // A helper to normalize a predicate argument

      +  const normalizePredicate = <T extends KRecord>(

      +    predicate: Partial<T> | ((record: T) => boolean)

      +  ): ((record: KRecord) => boolean) =>

      +    // The cast is necessary due to function argument contravariance.

      +    // The internal operations work on the wider `KRecord`, while the
      fluent API provides the specific `T`.

      +    (typeof predicate === 'function' ? predicate :
      createPredicateFromPartial(predicate)) as (record: KRecord) => boolean;

      +
         const query = (state: DatabaseState<S>): QueryBuilder<S> => ({
           from: <TName extends keyof S['tables']>(tableName: TName): ChainedQueryBuilder<S, TName, S['base'][TName]> => {
             const createBuilder = <TReturn>(currentDescriptor: QueryDescriptor): ChainedQueryBuilder<S, TName, TReturn> => ({
      @@ -235,9 +145,19 @@
           io.delete(core, tableName as string, normalizePredicate(predicate as Parameters<typeof normalizePredicate>[0])) as Promise<S['base'][T][]>,
         });
       
      -  const notSupported = () => Promise.reject(KonroError("This method is
      not supported in 'on-demand' mode."));

      -

      -  return { schema, adapter, createEmptyState: () =>
      createEmptyStateImpl(schema), read: notSupported, write: notSupported,
      query, insert, update, delete: del };

      +  const notSupported = (methodName: string) => () =>
      Promise.reject(KonroError({ code: 'E400', methodName }));

      +

      +  return {

      +    schema,

      +    adapter,

      +    createEmptyState: () => createEmptyStateImpl(schema),

      +    read: notSupported('read'),

      +    write: notSupported('write'),

      +    query,

      +    insert,

      +    update,

      +    delete: del

      +  };
       }
       
       
      @@ -279,7 +199,7 @@
             try {
               return serializer.parse(data, schema.tables[tableName]);
             } catch (e: any) {
      -        throw KonroStorageError(`Failed to parse file at
      "${getTablePath(tableName)}". Original error: ${e.message}`);

      +        throw KonroStorageError({ code: 'E103', filepath:
      getTablePath(tableName), format: fileExtension.slice(1), details:
      e.message });
             }
           };
       
      @@ -317,7 +237,7 @@
           const getMetaPath = (tableName: string) => path.join(getTableDir(tableName), '_meta.json');
           const getIdColumn = (tableName: string) => {
             const col = Object.keys(schema.tables[tableName]).find(k => schema.tables[tableName][k]?.dataType === 'id');
      -      if (!col) throw KonroError(`Table "${tableName}" needs an 'id'
      column for 'per-record' mode.`);

      +      if (!col) throw KonroError({ code: 'E202', tableName });
             return col;
           };
       
      @@ -404,7 +324,7 @@
       
         const io = fileAdapter.options.multi ? createMultiFileIO() : fileAdapter.options.perRecord ? createPerRecordIO() : null;
         if (!io) {
      -    throw KonroError("The 'on-demand' mode requires a 'multi-file' or
      'per-record' storage strategy.");

      +    throw KonroError({ code: 'E104' });
         }
         
         return createOnDemandDbContext(schema, adapter, core, io);
    patchStrategy: new-unified
  - type: write
    path: src/utils/serializer.util.ts
    content: >-
      --- src/utils/serializer.util.ts

      +++ src/utils/serializer.util.ts

      @@ -1,5 +1,5 @@
       import { KonroStorageError } from './error.util';
      -import type { ColumnDefinition } from '../schema';

      +import type { ColumnDefinition, Serializer } from '../types';
       
       const loadOptional = <T>(name: string): T | undefined => {
         try {
      @@ -13,11 +13,6 @@
       const papaparse = loadOptional<{ parse: (str: string, config?: any) => { data: any[] }; unparse: (data: any[] | object) => string; }>('papaparse');
       const xlsx = loadOptional<{ read: (data: any, opts: any) => any; utils: { sheet_to_json: <T>(ws: any) => T[]; json_to_sheet: (json: any) => any; book_new: () => any; book_append_sheet: (wb: any, ws: any, name: string) => void; }; write: (wb: any, opts: any) => any; }>('xlsx');
       
      -export type Serializer = {

      -  parse: <T>(data: string, tableSchema?: Record<string,
      ColumnDefinition<any>>) => T;

      -  stringify: (obj: any) => string;

      -};

      -
       /** For tabular formats (CSV/XLSX), metadata isn't stored. We derive lastId from the data itself. */
       const deriveLastIdFromRecords = (records: any[], tableSchema: Record<string, ColumnDefinition<any>>): number => {
         const idColumn = Object.keys(tableSchema).find((key) => tableSchema[key]?.dataType === 'id' && tableSchema[key]?.options?._pk_strategy !== 'uuid');
      @@ -37,16 +32,16 @@
               stringify: (obj: any): string => JSON.stringify(obj, null, 2),
             };
           case 'yaml':
      -      if (!yaml) throw KonroStorageError("The 'yaml' format requires
      'js-yaml' to be installed. Please run 'npm install js-yaml'.");

      +      if (!yaml) throw KonroStorageError({ code: 'E101', format: 'yaml',
      dependency: 'js-yaml' });
             return {
               parse: <T>(data: string): T => yaml.load(data) as T,
               stringify: (obj: any): string => yaml.dump(obj),
             };
           case 'csv':
      -      if (!papaparse) throw KonroStorageError("The 'csv' format requires
      'papaparse' to be installed. Please run 'npm install papaparse'.");

      +      if (!papaparse) throw KonroStorageError({ code: 'E101', format:
      'csv', dependency: 'papaparse' });
             return {
               parse: <T>(data: string, tableSchema?: Record<string, ColumnDefinition<any>>): T => {
                 const { data: records } = papaparse.parse(data, { header: true, dynamicTyping: true, skipEmptyLines: true });
      @@ -56,7 +51,7 @@
               stringify: (obj: any): string => papaparse.unparse(obj.records || []),
             };
           case 'xlsx':
      -      if (!xlsx) throw KonroStorageError("The 'xlsx' format requires
      'xlsx' to be installed. Please run 'npm install xlsx'.");

      +      if (!xlsx) throw KonroStorageError({ code: 'E101', format: 'xlsx',
      dependency: 'xlsx' });
             return {
               parse: <T>(data: string, tableSchema?: Record<string, ColumnDefinition<any>>): T => {
                 const workbook = xlsx.read(data, { type: 'base64' });
      @@ -75,7 +70,7 @@
               },
             };
           default:
      -      throw KonroStorageError(`Unsupported or invalid format
      specified.`);

      +      throw KonroStorageError({ code: 'E102', format });
         }
       };
    patchStrategy: new-unified
snapshot:
  src/utils/error.codes.ts: null
  src/schema.ts: >-
    //

    // Konro: The Type-Safe, Functional ORM for JSON/YAML

    //

    // ## Pillar I: The Recipe (Schema Definition)

    //

    // This file contains the core logic for defining a database schema. It is
    designed to be

    // both the runtime source of truth for validation and the static source of
    truth for

    // TypeScript types. By using phantom types and inference, we can create a
    fully-typed

    // `db` object from a single schema definition object, eliminating the need
    for manual

    // type declarations (`interface User { ... }`) and ensuring they never get
    out of sync.

    //


    // --- TYPE INFERENCE HELPERS ---


    /** Infers the underlying TypeScript type from a `ColumnDefinition`. e.g.,
    `ColumnDefinition<string>` => `string`. */

    type InferColumnType<C> = C extends ColumnDefinition<infer T> ? T : never;


    /** A mapping of table names to their base model types (columns only, no
    relations). */

    export type BaseModels<TTables extends Record<string, any>> = {
      [TableName in keyof TTables]: {
        [ColumnName in keyof TTables[TableName]]: InferColumnType<TTables[TableName][ColumnName]>;
      };
    };


    /**
     * A mapping of table names to their full model types, including relations.
     * This is a recursive type that resolves relationships to other full models.
     */
    type Models<
      TTables extends Record<string, any>,
      TRelations extends Record<string, any>,
      TBaseModels extends Record<keyof TTables, any>
    > = {
      [TableName in keyof TTables]: TBaseModels[TableName] &
        (TableName extends keyof TRelations
          ? {
              [RelationName in keyof TRelations[TableName]]?: TRelations[TableName][RelationName] extends OneRelationDefinition
                ? // `targetTable` is a string literal, so we can use it to index `Models`
                  Models<TTables, TRelations, TBaseModels>[TRelations[TableName][RelationName]['targetTable']] | null
                : TRelations[TableName][RelationName] extends ManyRelationDefinition
                ? Models<TTables, TRelations, TBaseModels>[TRelations[TableName][RelationName]['targetTable']][]
                : never;
            }
          : {});
    };


    /** Finds all column names in a table definition that are optional for
    insertion (i.e., `id` or has a `default`). */

    type OptionalCreateKeys<TTableDef> = {
      [K in keyof TTableDef]: TTableDef[K] extends { dataType: 'id' }
        ? K
        : TTableDef[K] extends { options: { default: unknown } }
        ? K
        : never;
    }[keyof TTableDef];


    /**
     * A mapping of table names to their "create" types, used for `db.insert`.
     * It takes the base model, makes keys with defaults optional, and removes the `id` field.
     */
    type CreateModels<
      TTables extends Record<string, any>,
      TBaseModels extends Record<keyof TTables, any>
    > = {
      [TableName in keyof TTables]: Omit<
        {
          // Required fields
          [K in Exclude<keyof TBaseModels[TableName], OptionalCreateKeys<TTables[TableName]>>]: TBaseModels[TableName][K];
        } & {
          // Optional fields
          [K in OptionalCreateKeys<TTables[TableName]>]?: TBaseModels[TableName][K];
        },
        // 'id' is always omitted from create types
        'id'
      >;
    };



    // --- PUBLIC API TYPES ---


    /** The publicly exposed structure of a fully-processed Konro schema. */

    export interface KonroSchema<
      TTables extends Record<string, any>,
      TRelations extends Record<string, any>
    > {
      tables: TTables;
      relations: TRelations;
      /** The full, relational types for each table model. */
      types: Models<TTables, TRelations, BaseModels<TTables>>;
      /** The base types for each table model, without any relations. */
      base: BaseModels<TTables>;
      /** The types for creating new records, with defaults and `id` made optional. */
      create: CreateModels<TTables, BaseModels<TTables>>;
    }


    /** The definition for a database column, created by helpers like
    `konro.string()`. */

    export interface ColumnDefinition<T> {
      readonly _type: 'column';
      readonly dataType: 'id' | 'string' | 'number' | 'boolean' | 'date' | 'object';
      readonly options: any;
      readonly _tsType?: T; // Phantom type, does not exist at runtime
    }


    /** The definition for a table relationship, created by `konro.one()` or
    `konro.many()`. */

    export interface BaseRelationDefinition {
      readonly _type: 'relation';
      readonly targetTable: string;
      readonly on: string;
      readonly references: string;
      readonly onDelete?: 'CASCADE' | 'SET NULL';
    }


    export interface OneRelationDefinition extends BaseRelationDefinition {
      readonly relationType: 'one';
    }


    export interface ManyRelationDefinition extends BaseRelationDefinition {
      readonly relationType: 'many';
    }


    export type RelationDefinition = OneRelationDefinition |
    ManyRelationDefinition;


    /** The definition for a data aggregation, created by `konro.count()`,
    `konro.sum()`, etc. */

    export interface AggregationDefinition {
      readonly _type: 'aggregation';
      readonly aggType: 'count' | 'sum' | 'avg' | 'min' | 'max';
      readonly column?: string;
    }



    // --- SCHEMA BUILDER FUNCTION ---


    /**
     * Defines the structure, types, and relations of your database.
     * This is the single source of truth for both runtime validation and static types.
     *
     * @param schemaDef The schema definition object.
     * @returns A processed schema object with inferred types attached.
     */
    export const createSchema = <
      const TDef extends {
        tables: Record<string, Record<string, ColumnDefinition<any>>>;
        relations?: (tables: TDef['tables']) => Record<string, Record<string, BaseRelationDefinition>>;
      }
    >(
      schemaDef: TDef
    ): KonroSchema<TDef['tables'], TDef['relations'] extends (...args: any) =>
    any ? ReturnType<TDef['relations']> : {}> => { // eslint-disable-line
      const relations = schemaDef.relations ? schemaDef.relations(schemaDef.tables) : {};
      return {
        tables: schemaDef.tables,
        relations: relations as any, // Cast to bypass complex conditional type issue
        // Types are applied via the return type annotation, these are just placeholders at runtime.
        types: null as any,
        base: {} as any,
        create: {} as any,
      };
    };



    // --- COLUMN DEFINITION HELPERS ---


    const createColumn = <T>(dataType: ColumnDefinition<T>['dataType'], options:
    object | undefined, tsType: T): ColumnDefinition<T> => ({
      _type: 'column',
      dataType,
      options,
      _tsType: tsType,
    });


    /** A managed, auto-incrementing integer primary key. This is the default
    strategy. */

    export const id = () => createColumn<number>('id', { unique: true,
    _pk_strategy: 'auto-increment' }, 0);

    /** A managed, universally unique identifier (UUID) primary key. Stored as a
    string. */

    export const uuid = () => createColumn<string>('id', { unique: true,
    _pk_strategy: 'uuid' }, '');

    /** A string column with optional validation. */

    export const string = (options?: { unique?: boolean; default?: string | (()
    => string); min?: number; max?: number; format?: 'email' | 'uuid' | 'url' })
    => createColumn<string>('string', options, '');

    /** A number column with optional validation. */

    export const number = (options?: { unique?: boolean; default?: number | (()
    => number); min?: number; max?: number; type?: 'integer' }) =>
    createColumn<number>('number', options, 0);

    /** A boolean column. */

    export const boolean = (options?: { default?: boolean | (() => boolean) })
    => createColumn<boolean>('boolean', options, false);

    /** A generic date column. Consider using `createdAt` or `updatedAt` for
    managed timestamps. */

    export const date = (options?: { default?: Date | (() => Date) }) =>
    createColumn<Date>('date', options, new Date());

    /** A managed timestamp set when a record is created. */

    export const createdAt = (): ColumnDefinition<Date> =>
    createColumn<Date>('date', { _konro_sub_type: 'createdAt', default: () =>
    new Date() }, new Date());

    /** A managed timestamp set when a record is created and updated. */

    export const updatedAt = (): ColumnDefinition<Date> =>
    createColumn<Date>('date', { _konro_sub_type: 'updatedAt', default: () =>
    new Date() }, new Date());

    /** A managed, nullable timestamp for soft-deleting records. */

    export const deletedAt = (): ColumnDefinition<Date | null> =>
    createColumn<Date | null>('date', { _konro_sub_type: 'deletedAt', default:
    null }, null);

    /** A column for storing arbitrary JSON objects, with a generic for type
    safety. */

    export const object = <T extends Record<string, unknown>>(options?: {
    default?: T | (() => T) }): ColumnDefinition<T> => ({ _type: 'column',
    dataType: 'object', options });



    // --- RELATIONSHIP DEFINITION HELPERS ---


    /** Defines a `one-to-one` or `many-to-one` relationship. */

    export const one = <T extends string>(targetTable: T, options: { on: string;
    references: string; onDelete?: 'CASCADE' | 'SET NULL' }):
    OneRelationDefinition & { targetTable: T } => ({
      _type: 'relation',
      relationType: 'one',
      targetTable,
      ...options,
    });


    /** Defines a `one-to-many` relationship. */

    export const many = <T extends string>(targetTable: T, options: { on:
    string; references: string; onDelete?: 'CASCADE' | 'SET NULL' }):
    ManyRelationDefinition & { targetTable: T } => ({
      _type: 'relation',
      relationType: 'many',
      targetTable,
      ...options,
    });



    // --- AGGREGATION DEFINITION HELPERS ---


    /** Aggregation to count records. */

    export const count = (): AggregationDefinition => ({ _type: 'aggregation',
    aggType: 'count' });

    /** Aggregation to sum a numeric column. */

    export const sum = (column: string): AggregationDefinition => ({ _type:
    'aggregation', aggType: 'sum', column });

    /** Aggregation to average a numeric column. */

    export const avg = (column: string): AggregationDefinition => ({ _type:
    'aggregation', aggType: 'avg', column });

    /** Aggregation to find the minimum value in a numeric column. */

    export const min = (column: string): AggregationDefinition => ({ _type:
    'aggregation', aggType: 'min', column });

    /** Aggregation to find the maximum value in a numeric column. */

    export const max = (column: string): AggregationDefinition => ({ _type:
    'aggregation', aggType: 'max', column });
  src/utils/error.util.ts: "// Per user request: no classes. Using constructor functions for errors.\r\nconst createKonroError = (name: string) => {\r\n  function KonroErrorConstructor(message: string) {\r\n    const error = new Error(message);\r\n    error.name = name;\r\n    Object.setPrototypeOf(error, KonroErrorConstructor.prototype);\r\n    return error;\r\n  }\r\n  Object.setPrototypeOf(KonroErrorConstructor.prototype, Error.prototype);\r\n  return KonroErrorConstructor;\r\n};\r\n\r\n/** Base constructor for all Konro-specific errors. */\r\nexport const KonroError = createKonroError('KonroError');\r\n\r\n/** Thrown for storage adapter-related issues. */\r\nexport const KonroStorageError = createKonroError('KonroStorageError');\r\n\r\n/** Thrown for schema validation errors. */\r\nexport const KonroValidationError = createKonroError('KonroValidationError');\r\n\r\n/** Thrown when a resource is not found. */\r\nexport const KonroNotFoundError = createKonroError('KonroNotFoundError');\r\n"
  src/types.ts: "import type { BaseModels, KonroSchema } from './schema';\r\n\r\n/**\r\n * A generic representation of a single record within a table.\r\n * It uses `unknown` for values to enforce type-safe access.\r\n */\r\nexport type KRecord = Record<string, unknown>;\r\n\r\n/**\n * Represents the state of a single table, including its records and metadata.\n */\nexport type TableState<T extends KRecord = KRecord> = {\n  records: T[];\n  meta: {\n    lastId: number;\n  };\n};\n\n/**\r\n * The in-memory representation of the entire database. It is a plain, immutable object.\r\n */\r\nexport type DatabaseState<S extends KonroSchema<any, any> | unknown = unknown> = S extends KonroSchema<any, any>\r\n  ? {\r\n      [TableName in keyof S['tables']]: TableState<BaseModels<S['tables']>[TableName]>;\n    }\n  : {\n      [tableName: string]: TableState;\r\n    };"
  src/fs.ts: |-
    import { promises as fs } from 'fs';
    import path from 'path';
    import { TEMP_FILE_SUFFIX } from './utils/constants';

    export interface FsProvider {
      readFile(filepath: string): Promise<string | null>;
      writeFile(filepath: string, content: string, encoding: 'utf-8'): Promise<void>;
      rename(oldPath: string, newPath: string): Promise<void>;
      mkdir(dir: string, options: { recursive: true }): Promise<string | undefined>;
      readdir(dir: string): Promise<string[]>;
      unlink(filepath: string): Promise<void>;
    }

    export const defaultFsProvider: FsProvider = {
      readFile: async (filepath: string): Promise<string | null> => {
        try {
          return await fs.readFile(filepath, 'utf-8');
        } catch (error: any) {
          if (error.code === 'ENOENT') {
            return null;
          }
          throw error;
        }
      },
      writeFile: (filepath: string, content: string, encoding: 'utf-8'): Promise<void> => {
        return fs.writeFile(filepath, content, encoding);
      },
      rename: fs.rename,
      mkdir: fs.mkdir,
      readdir: fs.readdir,
      unlink: fs.unlink,
    };

    export const writeAtomic = async (
      filepath: string,
      content: string,
      fsProvider: FsProvider,
    ): Promise<void> => {
        // Adding Date.now() for uniqueness in case of concurrent operations
        const tempFilepath = `${filepath}.${Date.now()}${TEMP_FILE_SUFFIX}`;
        await fsProvider.mkdir(path.dirname(filepath), { recursive: true });
        await fsProvider.writeFile(tempFilepath, content, 'utf-8');
        await fsProvider.rename(tempFilepath, filepath);
    };
  src/adapter.ts: >-
    import path from 'path';

    import type { DatabaseState, KRecord, TableState } from './types';

    import { createEmptyState } from './operations';

    import type { ColumnDefinition, KonroSchema } from './schema';

    import { getSerializer, type Serializer } from './utils/serializer.util';

    import { FsProvider, defaultFsProvider, writeAtomic } from './fs';

    import { KonroError, KonroStorageError } from './utils/error.util';

    import { TEMP_FILE_SUFFIX } from './utils/constants';


    export interface StorageAdapter {
      read<S extends KonroSchema<any, any>>(schema: S): Promise<DatabaseState<S>>;
      write(state: DatabaseState<any>, schema: KonroSchema<any, any>): Promise<void>;
      readonly mode: 'in-memory' | 'on-demand';
    }


    export interface FileStorageAdapter extends StorageAdapter {
      readonly options: FileAdapterOptions;
      readonly fs: FsProvider;
      readonly serializer: Serializer;
      readonly fileExtension: string;
    }


    type SingleFileStrategy = { single: { filepath: string }; multi?: never;
    perRecord?: never };

    type MultiFileStrategy = { multi: { dir: string }; single?: never;
    perRecord?: never };

    type PerRecordStrategy = { perRecord: { dir: string }; single?: never;
    multi?: never };


    export type FileAdapterOptions = {
      format: 'json' | 'yaml' | 'csv' | 'xlsx';
      fs?: FsProvider;
      /**
       * Defines the data access strategy.
       * - `in-memory`: (Default) Loads the entire database into memory on init. Fast for small/medium datasets.
       * - `on-demand`: Reads from the file system for each query. Slower but supports larger datasets. Requires 'multi-file' or 'per-record' strategy.
       */
      mode?: 'in-memory' | 'on-demand';
    } & (SingleFileStrategy | MultiFileStrategy | PerRecordStrategy);


    export function createFileAdapter(options: FileAdapterOptions & { mode:
    'on-demand' }): FileStorageAdapter & { mode: 'on-demand' };

    export function createFileAdapter(options: FileAdapterOptions & { mode?:
    'in-memory' | undefined }): FileStorageAdapter & { mode: 'in-memory' };

    export function createFileAdapter(options: FileAdapterOptions):
    FileStorageAdapter;

    export function createFileAdapter(options: FileAdapterOptions):
    FileStorageAdapter {
      const serializer = getSerializer(options.format);
      const fileExtension = `.${options.format}`;
      const fs = options.fs ?? defaultFsProvider;
      const mode = options.mode ?? 'in-memory';

      if (options.perRecord && options.format !== 'json' && options.format !== 'yaml') {
        throw KonroError(`The 'per-record' strategy only supports 'json' or 'yaml' formats.`);
      }

      const isTabular = options.format === 'csv' || options.format === 'xlsx';
      if (isTabular && (mode !== 'on-demand' || !options.multi)) {
        throw KonroError(`The '${options.format}' format only supports 'on-demand' mode with a 'multi-file' strategy.`);
      }

      if (mode === 'on-demand' && options.single) {
        throw KonroError("The 'on-demand' mode requires the 'multi-file' or 'per-record' storage strategy.");
      }

      const strategy = createStrategy(options, { fs, serializer, fileExtension, mode });

      return {
        options,
        fs,
        serializer,
        fileExtension,
        mode,
        ...strategy,
      } as FileStorageAdapter;
    }


    type FileStrategy = Pick<StorageAdapter, 'read' | 'write'>;

    type StrategyContext = {
      fs: FsProvider;
      serializer: Serializer;
      fileExtension: string;
      mode: 'in-memory' | 'on-demand';
    };


    /** Chooses and creates the appropriate file strategy based on adapter
    options. */

    function createStrategy(options: FileAdapterOptions, context:
    StrategyContext): FileStrategy {
      if (options.single) {
        return createSingleFileStrategy(options.single, context);
      }
      if (options.multi) {
        return createMultiFileStrategy(options.multi, context);
      }
      if (options.perRecord) {
        return createPerRecordStrategy(options.perRecord, context);
      }
      // This case should be prevented by the types, but as a safeguard:
      throw KonroError('Invalid file adapter options: missing storage strategy.');
    }


    /** Creates the strategy for reading/writing the entire database to a single
    file. */

    function createSingleFileStrategy(options: SingleFileStrategy['single'],
    context: StrategyContext): FileStrategy {
      const { fs, serializer } = context;

      const parseFile = async <T>(filepath: string, schema?: Record<string, ColumnDefinition<unknown>>): Promise<T | undefined> => {
        const data = await fs.readFile(filepath);
        if (!data) return undefined;
        try {
          return serializer.parse<T>(data, schema);
        } catch (e) {
          const message = e instanceof Error ? e.message : String(e);
          throw KonroStorageError(`Failed to parse file at "${filepath}". It may be corrupt or not a valid ${context.fileExtension.slice(1)} file. Original error: ${message}`);
        }
      };

      return {
        read: async <S extends KonroSchema<any, any>>(schema: S) => {
          // We parse into a generic DatabaseState because the exact type is only known by the caller.
          const state = await parseFile<DatabaseState>(options.filepath);
          return (state ?? createEmptyState(schema)) as DatabaseState<S>;
        },
        write: (state: DatabaseState<any>) => writeAtomic(options.filepath, serializer.stringify(state), fs),
      };
    }


    /** Creates the strategy for reading/writing each table to its own file in a
    directory. */

    function createMultiFileStrategy(options: MultiFileStrategy['multi'],
    context: StrategyContext): FileStrategy {
      const { fs, serializer, fileExtension } = context;
      const parseFile = async <T>(filepath: string, schema?: Record<string, ColumnDefinition<unknown>>): Promise<T | undefined> => {
        const data = await fs.readFile(filepath);
        if (!data) return undefined;
        try {
          return serializer.parse<T>(data, schema);
        } catch (e) {
          const message = e instanceof Error ? e.message : String(e);
          throw KonroStorageError(`Failed to parse file at "${filepath}". It may be corrupt or not a valid ${fileExtension.slice(1)} file. Original error: ${message}`);
        }
      };

      return {
        read: async <S extends KonroSchema<any, any>>(schema: S) => {
          await context.fs.mkdir(options.dir, { recursive: true });
          const state = createEmptyState(schema);
          await Promise.all(
            Object.keys(schema.tables).map(async (tableName) => {
              const filepath = path.join(options.dir, `${tableName}${context.fileExtension}`);
              const tableState = await parseFile<TableState>(filepath, schema.tables[tableName]);
              if (tableState) (state as any)[tableName] = tableState;
            })
          );
          return state;
        },
        write: async (state: DatabaseState<any>) => {
          await context.fs.mkdir(options.dir, { recursive: true });
          const writes = Object.entries(state).map(([tableName, tableState]) => {
            const filepath = path.join(options.dir, `${tableName}${context.fileExtension}`);
            return writeAtomic(filepath, context.serializer.stringify(tableState), context.fs);
          });
          await Promise.all(writes);
        },
      };
    }


    /** Creates the strategy for reading/writing each record to its own file. */

    function createPerRecordStrategy(options: PerRecordStrategy['perRecord'],
    context: StrategyContext): FileStrategy {
      const { fs, serializer, fileExtension } = context;

      const parseFile = async <T>(filepath: string): Promise<T | undefined> => {
        const data = await fs.readFile(filepath);
        if (!data) return undefined;
        try {
          return serializer.parse<T>(data);
        } catch (e) {
          const message = e instanceof Error ? e.message : String(e);
          throw KonroStorageError(`Failed to parse file at "${filepath}". It may be corrupt or not a valid ${context.fileExtension.slice(1)} file. Original error: ${message}`);
        }
      };

      return {
        read: async <S extends KonroSchema<any, any>>(schema: S) => {
          await fs.mkdir(options.dir, { recursive: true });
          const state = createEmptyState(schema);
          await Promise.all(
            Object.keys(schema.tables).map(async (tableName) => {
              const tableDir = path.join(options.dir, tableName);
              const currentTableState = state[tableName as keyof typeof state];
              if (!currentTableState) return;

              await fs.mkdir(tableDir, { recursive: true });

              const metaContent = await fs.readFile(path.join(tableDir, '_meta.json')).catch(() => null);
              if (metaContent) currentTableState.meta = JSON.parse(metaContent);

              const files = await fs.readdir(tableDir);
              const recordFiles = files.filter((f) => !f.startsWith('_meta'));
              const records = (await Promise.all(recordFiles.map((file) => parseFile<KRecord>(path.join(tableDir, file))))).filter((r): r is KRecord => r != null);
              currentTableState.records = records as any;

              if (currentTableState.meta.lastId === 0) {
                const idColumn = Object.keys(schema.tables[tableName]).find((k) => schema.tables[tableName][k]?.options?._pk_strategy === 'auto-increment');
                if (idColumn) {
                  currentTableState.meta.lastId = records.reduce((maxId: number, record: KRecord) => {
                    const id = record[idColumn];
                    return typeof id === 'number' && id > maxId ? id : maxId;
                  }, 0);
                }
              }
            })
          );
          return state;
        },
        write: async (state: DatabaseState<any>, schema: KonroSchema<any, any>) => {
          await fs.mkdir(options.dir, { recursive: true });
          await Promise.all(Object.entries(state).map(async ([tableName, tableState]) => {
            const tableDir = path.join(options.dir, tableName as string);
            await fs.mkdir(tableDir, { recursive: true });
            await writeAtomic(path.join(tableDir, '_meta.json'), JSON.stringify(tableState.meta, null, 2), fs);

            const idColumn = Object.keys(schema.tables[tableName]).find((k) => schema.tables[tableName][k]?.dataType === 'id');
            if (!idColumn) throw KonroError(`Table "${tableName}" must have an 'id' column for 'per-record' storage.`);

            const currentFiles = new Set(tableState.records.map((r: KRecord) => `${r[idColumn]}${fileExtension}`));
            const existingFiles = (await fs.readdir(tableDir)).filter(f => !f.startsWith('_meta') && !f.endsWith(TEMP_FILE_SUFFIX));

            const recordWrites = tableState.records.map((r) => writeAtomic(path.join(tableDir, `${r[idColumn]}${fileExtension}`), serializer.stringify(r), fs));
            const recordDeletes = existingFiles.filter(f => !currentFiles.has(f)).map(f => fs.unlink(path.join(tableDir, f as string)));
            await Promise.all([...recordWrites, ...recordDeletes]);
          }));
        }
      };
    }
  src/operations.ts: "import { randomUUID } from 'crypto';\r\nimport { DatabaseState, KRecord } from './types';\r\nimport { KonroSchema, RelationDefinition, ColumnDefinition, AggregationDefinition } from './schema';\r\nimport { KonroError, KonroValidationError } from './utils/error.util';\r\n\r\n// --- HELPERS ---\r\n\r\n\r\n/** Creates a pristine, empty database state from a schema. */\r\nexport const createEmptyState = <S extends KonroSchema<any, any>>(schema: S): DatabaseState<S> => {\r\n  const state = {} as DatabaseState<S>;\r\n  for (const tableName in schema.tables) {\r\n    // This is a controlled cast, safe because we are iterating over the schema's tables.\r\n    (state as any)[tableName] = { records: [], meta: { lastId: 0 } };\r\n  }\r\n  return state;\r\n};\r\n\r\n// --- QUERY ---\r\n\r\ninterface WithOptions {\r\n  select?: Record<string, ColumnDefinition<unknown>>;\r\n  where?: (record: KRecord) => boolean;\r\n  with?: WithClause;\r\n}\r\ntype WithClause = Record<string, boolean | WithOptions>;\r\n\r\nexport interface QueryDescriptor {\r\n  tableName: string;\r\n  select?: Record<string, ColumnDefinition<unknown> | RelationDefinition>;\r\n  where?: (record: KRecord) => boolean;\r\n  with?: WithClause;\r\n  limit?: number;\r\n  offset?: number;\r\n  withDeleted?: boolean;\r\n}\r\n\r\nexport interface AggregationDescriptor extends QueryDescriptor {\r\n  aggregations: Record<string, AggregationDefinition>;\r\n}\r\n\r\nconst _processWith = <S extends KonroSchema<any, any>>(\r\n  recordsToProcess: KRecord[],\r\n  currentTableName: string,\r\n  withClause: WithClause,\r\n  schema: S,\r\n  state: DatabaseState\r\n): KRecord[] => {\r\n  // structuredClone is important to avoid mutating the records from the previous recursion level or the main state.\r\n  const resultsWithRelations = structuredClone(recordsToProcess);\r\n\r\n  for (const record of resultsWithRelations) {\r\n    for (const relationName in withClause) {\r\n      const relationDef = schema.relations[currentTableName]?.[relationName];\r\n      if (!relationDef) continue;\r\n\r\n      const withOpts = withClause[relationName];\r\n      // Skip if the value is `false` or something not truthy (though types should prevent this)\r\n      if (!withOpts) continue;\r\n\r\n      const relatedRecords = findRelatedRecords(state, record, relationDef);\r\n\r\n      const nestedWhere = typeof withOpts === 'object' ? withOpts.where : undefined;\r\n      const nestedSelect = typeof withOpts === 'object' ? withOpts.select : undefined;\r\n      const nestedWith = typeof withOpts === 'object' ? withOpts.with : undefined;\r\n\r\n      let processedRelatedRecords = nestedWhere ? relatedRecords.filter(nestedWhere) : [...relatedRecords];\r\n\r\n      // Recursively process deeper relations first\r\n      if (nestedWith && processedRelatedRecords.length > 0) {\r\n        processedRelatedRecords = _processWith(\r\n          processedRelatedRecords,\r\n          relationDef.targetTable,\r\n          nestedWith,\r\n          schema,\r\n          state\r\n        );\r\n      }\r\n\r\n      // Then, apply select on the (potentially already processed) related records\r\n      if (nestedSelect) {\r\n        const targetTableSchema = schema.tables[relationDef.targetTable];\r\n        if (!targetTableSchema) throw KonroError(`Schema for table \"${relationDef.targetTable}\" not found.`);\r\n\r\n        processedRelatedRecords = processedRelatedRecords.map(rec => {\r\n          const newRec: KRecord = {};\r\n          for (const outputKey in nestedSelect) {\r\n            const def = nestedSelect[outputKey];\r\n            if (!def) continue;\r\n            // nested with() does not support selecting relations, only columns, as per spec.\r\n            if (def._type === 'column') {\r\n              const colName = Object.keys(targetTableSchema).find(key => targetTableSchema[key] === def);\r\n              if (colName && rec.hasOwnProperty(colName)) {\r\n                newRec[outputKey] = rec[colName];\r\n              }\r\n            }\r\n          }\r\n          return newRec;\r\n        });\r\n      }\r\n\r\n      // Finally, attach the results to the parent record\r\n      if (relationDef.relationType === 'one') {\r\n        record[relationName] = processedRelatedRecords[0] ?? null;\r\n      } else {\r\n        record[relationName] = processedRelatedRecords;\r\n      }\r\n    }\r\n  }\r\n\r\n  return resultsWithRelations;\r\n};\r\n\r\nexport const _queryImpl = <S extends KonroSchema<any, any>>(state: DatabaseState, schema: S, descriptor: QueryDescriptor): KRecord[] => {\r\n  const tableState = state[descriptor.tableName];\r\n  if (!tableState) return [];\r\n\r\n  const tableSchema = schema.tables[descriptor.tableName];\r\n  if (!tableSchema) throw KonroError(`Schema for table \"${descriptor.tableName}\" not found.`);\r\n  const deletedAtColumn = Object.keys(tableSchema).find(key => tableSchema[key]?.options?._konro_sub_type === 'deletedAt');\r\n\r\n  // 1. Filter\r\n  let results: KRecord[];\r\n\r\n  // Auto-filter soft-deleted records unless opted-out\r\n  if (deletedAtColumn && !descriptor.withDeleted) {\r\n    results = tableState.records.filter(r => r[deletedAtColumn] === null || r[deletedAtColumn] === undefined);\r\n  } else {\r\n    results = [...tableState.records];\r\n  }\r\n  \r\n  results = descriptor.where ? results.filter(descriptor.where) : results;\r\n\r\n  // 2. Eager load relations (`with`) - must happen after filtering\r\n  if (descriptor.with) {\r\n    results = \r\n_processWith(results, descriptor.tableName, descriptor.with, schema, state);\r\n  }\r\n\r\n  // 3. Paginate\r\n  const offset = descriptor.offset ?? 0;\r\n  const limit = descriptor.limit ?? results.length;\r\n  let paginatedResults = results.slice(offset, offset + limit);\r\n\r\n  // 4. Select Fields\r\n  if (descriptor.select) {\r\n    const relationsSchema = schema.relations[descriptor.tableName] ?? {};\r\n\r\n    paginatedResults = paginatedResults.map(rec => {\r\n      const newRec: KRecord = {};\r\n      for (const outputKey in descriptor.select!) {\r\n        const def = descriptor.select![outputKey];\r\n        if (!def) continue;\r\n        if (def._type === 'column') {\r\n          const colName = Object.keys(tableSchema).find(key => tableSchema[key] === def);\r\n          if (colName && rec.hasOwnProperty(colName)) {\r\n            newRec[outputKey] = rec[colName];\r\n          }\r\n        } else if (def._type === 'relation') {\r\n          const relName = Object.keys(relationsSchema).find(key => relationsSchema[key] === def);\r\n          if (relName && rec.hasOwnProperty(relName)) {\r\n            newRec[outputKey] = rec[relName];\r\n          }\r\n        }\r\n      }\r\n      return newRec;\r\n    });\r\n  }\r\n\r\n  return paginatedResults;\r\n};\r\n\r\nconst findRelatedRecords = (state: DatabaseState, record: KRecord, relationDef: RelationDefinition) => {\r\n  const foreignKey = record[relationDef.on];\r\n  const targetTable = state[relationDef.targetTable];\r\n\r\n  if (foreignKey === undefined || !targetTable) return [];\r\n\r\n  // one-to-many: 'on' is PK on current table, 'references' is FK on target\r\n  if (relationDef.relationType === 'many') {\r\n    return targetTable.records.filter(r => r[relationDef.references] === foreignKey);\r\n  }\r\n\r\n  // many-to-one: 'on' is FK on current table, 'references' is PK on target\r\n  if (relationDef.relationType === 'one') {\r\n    return targetTable.records.filter(r => r[relationDef.references] === foreignKey);\r\n  }\r\n\r\n  return [];\r\n};\r\n\r\n// --- AGGREGATION ---\r\n\r\nexport const _aggregateImpl = <S extends KonroSchema<any, any>>(\r\n  state: DatabaseState,\r\n  _schema: S, // Not used but keep for API consistency\r\n  descriptor: AggregationDescriptor\r\n): Record<string, number | null> => {\r\n  const tableState = state[descriptor.tableName];\r\n  if (!tableState) return {};\r\n\r\n  const filteredRecords = descriptor.where ? tableState.records.filter(descriptor.where) : [...tableState.records];\r\n  const results: Record<string, number | null> = {};\r\n\r\n  for (const resultKey in descriptor.aggregations) {\r\n    const aggDef = descriptor.aggregations[resultKey];\r\n    if (!aggDef) continue;\r\n\r\n    if (aggDef.aggType === 'count') {\r\n      results[resultKey] = filteredRecords.length;\r\n      continue;\r\n    }\r\n\r\n    if (!aggDef.column) {\r\n      throw KonroError(`Aggregation '${aggDef.aggType}' requires a column.`);\r\n    }\r\n    const column = aggDef.column;\r\n\r\n    const values = filteredRecords.map(r => r[column]).filter(v => typeof v === 'number') as number[];\r\n\r\n    if (values.length === 0) {\r\n      if (aggDef.aggType === 'sum') {\r\n        results[resultKey] = 0; // sum of empty set is 0\r\n      } else {\r\n        results[resultKey] = null; // avg, min, max of empty set is null\r\n      }\r\n      continue;\r\n    }\r\n\r\n    switch (aggDef.aggType) {\r\n      case 'sum':\r\n        results[resultKey] = values.reduce((sum, val) => sum + val, 0);\r\n        break;\r\n      case 'avg':\r\n        results[resultKey] = values.reduce((sum, val) => sum + val, 0) / values.length;\r\n        break;\r\n      case 'min':\r\n        results[resultKey] = Math.min(...values);\r\n        break;\r\n      case 'max':\r\n        results[resultKey] = Math.max(...values);\r\n        break;\r\n    }\r\n  }\r\n  return results;\r\n};\r\n\r\n// --- INSERT ---\r\n\r\nexport const _insertImpl = <S extends KonroSchema<any, any>>(state: DatabaseState, schema: S, tableName: string, values: KRecord[]): [DatabaseState, KRecord[]] => {\r\n  const oldTableState = state[tableName];\r\n  if (!oldTableState) throw KonroError(`Table \"${tableName}\" does not exist in the database state.`);\r\n\r\n  // To maintain immutability, we deep-clone only the table being modified.\r\n  const tableState = structuredClone(oldTableState);\r\n  const tableSchema = schema.tables[tableName];\r\n  if (!tableSchema) throw KonroError(`Schema for table \"${tableName}\" not found.`);\r\n  const insertedRecords: KRecord[] = [];\r\n\r\n  for (const value of values) {\r\n    const newRecord: KRecord = { ...value };\r\n    // Handle IDs and defaults\r\n    for (const colName in tableSchema) {\r\n      const colDef = tableSchema[colName];\r\n      if (colDef.dataType === 'id') {\r\n        if (newRecord[colName] === undefined) {\r\n          // Generate new PK if not provided\r\n          if (colDef.options?._pk_strategy === 'uuid') {\r\n            newRecord[colName] = randomUUID();\r\n          } else { // 'auto-increment' or legacy undefined strategy\r\n            tableState.meta.lastId++;\r\n            newRecord[colName] = tableState.meta.lastId;\r\n          }\r\n        } else {\r\n          // If user provided an ID for an auto-increment table, update lastId to avoid future collisions.\r\n          if (colDef.options?._pk_strategy !== 'uuid' && typeof newRecord[colName] === 'number') {\r\n            tableState.meta.lastId = Math.max(tableState.meta.lastId, newRecord[colName] as number);\r\n          }\r\n        }\r\n      }\r\n      if (newRecord[colName] === undefined && colDef.options?.default !== undefined) {\r\n        newRecord[colName] = typeof colDef.options.default === 'function' ? colDef.options.default() : colDef.options.default;\r\n      }\r\n    }\r\n\r\n    // Validate the record before inserting\r\n    validateRecord(newRecord, tableSchema, tableState.records);\r\n\r\n    tableState.records.push(newRecord);\r\n    insertedRecords.push(newRecord);\r\n  }\r\n\r\n  const newState = { ...state, [tableName]: tableState };\r\n  return [newState, insertedRecords];\r\n};\r\n\r\n// --- UPDATE ---\r\n\r\nexport const _updateImpl = <S extends KonroSchema<any, any>>(state: DatabaseState, schema: S, tableName: string, data: Partial<KRecord>, predicate: (record: KRecord) => boolean): [DatabaseState, KRecord[]] => {\r\n  const oldTableState = state[tableName];\r\n  if (!oldTableState) throw KonroError(`Table \"${tableName}\" does not exist in the database state.`);\r\n\r\n  const tableSchema = schema.tables[tableName];\r\n  if (!tableSchema) {\r\n    throw KonroError(`Schema for table \"${tableName}\" not found.`);\r\n  }\r\n\r\n  const updatedRecords: KRecord[] = [];\r\n\r\n  // Auto-update 'updatedAt' timestamp\r\n  for (const colName of Object.keys(tableSchema)) {\r\n      if (tableSchema[colName]?.options?._konro_sub_type === 'updatedAt') {\r\n          (data as KRecord)[colName] = new Date();\r\n      }\r\n  }\r\n\r\n  const updateData = { ...data };\r\n  // Find the ID column from the schema and prevent it from being updated.\r\n  const idColumn = Object.entries(tableSchema).find(([, colDef]) => {\r\n    return colDef && typeof colDef === 'object' && '_type' in colDef && colDef._type === 'column' && 'dataType' in colDef && colDef.dataType === 'id';\r\n  })?.[0];\r\n  if (idColumn && updateData[idColumn] !== undefined) {\r\n    delete updateData[idColumn];\r\n  }\r\n\r\n  const newRecords = oldTableState.records.map(record => {\r\n    if (predicate(record)) {\r\n      const updatedRecord = { ...record, ...updateData };\r\n\r\n      // Validate the updated record, excluding current record from unique checks\r\n      const otherRecords = oldTableState.records.filter(r => r !== record);\r\n      validateRecord(updatedRecord, tableSchema, otherRecords);\r\n\r\n      updatedRecords.push(updatedRecord);\r\n      return updatedRecord;\r\n    }\r\n    return record;\r\n  });\r\n\r\n  if (updatedRecords.length === 0) {\r\n    return [state, []];\r\n  }\r\n\r\n  const tableState = { ...oldTableState, records: newRecords };\r\n  const newState = { ...state, [tableName]: tableState };\r\n\r\n  return [newState, updatedRecords];\r\n};\r\n\r\n\r\n// --- DELETE ---\r\n\r\nfunction applyCascades<S extends KonroSchema<any, any>>(\r\n  state: DatabaseState<S>,\r\n  schema: S,\r\n  tableName: string,\r\n  deletedRecords: KRecord[]\r\n): DatabaseState<S> {\r\n  if (deletedRecords.length === 0) {\r\n    return state;\r\n  }\r\n\r\n  let nextState = state;\r\n  const relations = schema.relations[tableName] ?? {};\r\n\r\n  for (const relationName in relations) {\r\n    const relationDef = relations[relationName];\r\n    // We only cascade from the \"one\" side of a one-to-many relationship, which is a 'many' type in Konro.\r\n    if (!relationDef || relationDef.relationType !== 'many' || !relationDef.onDelete) {\r\n      continue;\r\n    }\r\n\r\n    const sourceKey = relationDef.on;\r\n    const targetTable = relationDef.targetTable;\r\n    const targetKey = relationDef.references;\r\n\r\n    const sourceKeyValues = deletedRecords.map(r => r[sourceKey]).filter(v => v !== undefined);\r\n    if (sourceKeyValues.length === 0) continue;\r\n\r\n    const sourceKeySet = new Set(sourceKeyValues);\r\n    const predicate = (record: KRecord) => sourceKeySet.has(record[targetKey] as any);\r\n\r\n    if (relationDef.onDelete === 'CASCADE') {\r\n      // Recursively delete\r\n      const [newState, ] = _deleteImpl(nextState, schema, targetTable, predicate);\r\n      nextState = newState as DatabaseState<S>;\r\n    } else if (relationDef.onDelete === 'SET NULL') {\r\n      // Update FK to null\r\n      const [newState, ] = _updateImpl(nextState, schema, targetTable, { [targetKey]: null }, predicate);\r\n      nextState = newState as DatabaseState<S>;\r\n    }\r\n  }\r\n\r\n  return nextState;\r\n}\r\n\r\nexport const _deleteImpl = (state: DatabaseState, schema: KonroSchema<any, any>, tableName: string, predicate: (record: KRecord) => boolean): [DatabaseState, KRecord[]] => {\r\n  const oldTableState = state[tableName];\r\n  if (!oldTableState) throw KonroError(`Table \"${tableName}\" does not exist in the database state.`);\r\n  const tableSchema = schema.tables[tableName];\r\n  if (!tableSchema) throw KonroError(`Schema for table \"${tableName}\" not found.`);\r\n\r\n  const deletedAtColumn = Object.keys(tableSchema).find(key => tableSchema[key]?.options?._konro_sub_type === 'deletedAt');\r\n\r\n  // Soft delete path\r\n  if (deletedAtColumn) {\r\n    // Use update implementation for soft-delete. It will also handle `updatedAt`.\r\n    const [baseState, recordsToUpdate] = _updateImpl(\r\n      state,\r\n      schema,\r\n      tableName,\r\n      { [deletedAtColumn]: new Date() },\r\n      (record) => !record[deletedAtColumn] && predicate(record)\r\n    );\r\n\r\n    if (recordsToUpdate.length === 0) return [state, []];\r\n    const finalState = applyCascades(baseState, schema, tableName, recordsToUpdate);\r\n    // The returned records are the ones that were just soft-deleted from this table.\r\n    return [finalState, recordsToUpdate];\r\n  } \r\n  \r\n  // Hard delete path\r\n  const recordsToDelete: KRecord[] = [];\r\n  const keptRecords = oldTableState.records.filter(r => predicate(r) ? (recordsToDelete.push(r), false) : true);\r\n\r\n  if (recordsToDelete.length === 0) return [state, []];\r\n\r\n  const baseState = { ...state, [tableName]: { ...oldTableState, records: keptRecords } };\r\n  const finalState = applyCascades(baseState, schema, tableName, recordsToDelete);\r\n\r\n  return [finalState, recordsToDelete];\r\n};\r\n\r\n// --- VALIDATION ---\r\n\r\nconst validateRecord = (record: KRecord, tableSchema: Record<string, any>, existingRecords: KRecord[]): void => {\r\n  for (const [columnName, colDef] of Object.entries(tableSchema)) {\r\n    if (!colDef || typeof colDef !== 'object' || !('dataType' in colDef)) continue;\r\n\r\n    const value = record[columnName];\r\n    const options = colDef.options || {};\r\n\r\n    // Skip validation for undefined values (they should have defaults applied already)\r\n    if (value === undefined) continue;\r\n\r\n    // Validate unique constraint\r\n    if (options.unique && existingRecords.some(r => r[columnName] === value)) {\r\n      throw KonroValidationError(`Value '${String(value)}' for column '${columnName}' must be unique`);\r\n    }\r\n\r\n    // Validate string constraints\r\n    if (colDef.dataType === 'string' && typeof value === 'string') {\r\n      // Min length\r\n      if (options.min !== undefined && value.length < options.min) {\r\n        throw KonroValidationError(`String '${value}' for column '${columnName}' is too short (min: ${options.min})`);\r\n      }\r\n\r\n      // Max length\r\n      if (options.max !== undefined && value.length > options.max) {\r\n        throw KonroValidationError(`String '${value}' for column '${columnName}' is too long (max: ${options.max})`);\r\n      }\r\n\r\n      // Format validation\r\n      if (options.format === 'email' && !isValidEmail(value)) {\r\n        throw KonroValidationError(`Value '${value}' for column '${columnName}' is not a valid email`);\r\n      }\r\n    }\r\n\r\n    // Validate number constraints\r\n    if (colDef.dataType === 'number' && typeof value === 'number') {\r\n      // Min value\r\n      if (options.min !== undefined && value < options.min) {\r\n        throw KonroValidationError(`Number ${value} for column '${columnName}' is too small (min: ${options.min})`);\r\n      }\r\n\r\n      // Max value\r\n      if (options.max !== undefined && value > options.max) {\r\n        throw KonroValidationError(`Number ${value} for column '${columnName}' is too large (max: ${options.max})`);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nconst isValidEmail = (email: string): boolean => {\r\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n  return emailRegex.test(email);\r\n};"
  src/utils/serializer.util.ts: >-
    import { KonroStorageError } from './error.util';

    import type { ColumnDefinition } from '../schema';


    const loadOptional = <T>(name: string): T | undefined => {
      try {
        return require(name);
      } catch {
        return undefined;
      }
    };


    const yaml = loadOptional<{ load: (str: string) => unknown; dump: (obj: any,
    options?: any) => string }>('js-yaml');

    const papaparse = loadOptional<{ parse: (str: string, config?: any) => {
    data: any[] }; unparse: (data: any[] | object) => string; }>('papaparse');

    const xlsx = loadOptional<{ read: (data: any, opts: any) => any; utils: {
    sheet_to_json: <T>(ws: any) => T[]; json_to_sheet: (json: any) => any;
    book_new: () => any; book_append_sheet: (wb: any, ws: any, name: string) =>
    void; }; write: (wb: any, opts: any) => any; }>('xlsx');


    export type Serializer = {
      parse: <T>(data: string, tableSchema?: Record<string, ColumnDefinition<any>>) => T;
      stringify: (obj: any) => string;
    };


    /** For tabular formats (CSV/XLSX), metadata isn't stored. We derive lastId
    from the data itself. */

    const deriveLastIdFromRecords = (records: any[], tableSchema: Record<string,
    ColumnDefinition<any>>): number => {
      const idColumn = Object.keys(tableSchema).find((key) => tableSchema[key]?.dataType === 'id' && tableSchema[key]?.options?._pk_strategy !== 'uuid');
      if (!idColumn) return 0;

      return records.reduce((maxId: number, record: any) => {
        const id = record[idColumn];
        return typeof id === 'number' && id > maxId ? id : maxId;
      }, 0);
    };


    export const getSerializer = (format: 'json' | 'yaml' | 'csv' | 'xlsx'):
    Serializer => {
      switch (format) {
        case 'json':
          return {
            parse: <T>(data: string): T => JSON.parse(data),
            stringify: (obj: any): string => JSON.stringify(obj, null, 2),
          };
        case 'yaml':
          if (!yaml) throw KonroStorageError("The 'yaml' format requires 'js-yaml' to be installed. Please run 'npm install js-yaml'.");
          return {
            parse: <T>(data: string): T => yaml.load(data) as T,
            stringify: (obj: any): string => yaml.dump(obj),
          };
        case 'csv':
          if (!papaparse) throw KonroStorageError("The 'csv' format requires 'papaparse' to be installed. Please run 'npm install papaparse'.");
          return {
            parse: <T>(data: string, tableSchema?: Record<string, ColumnDefinition<any>>): T => {
              const { data: records } = papaparse.parse(data, { header: true, dynamicTyping: true, skipEmptyLines: true });
              const lastId = tableSchema ? deriveLastIdFromRecords(records, tableSchema) : 0;
              return { records, meta: { lastId } } as T;
            },
            stringify: (obj: any): string => papaparse.unparse(obj.records || []),
          };
        case 'xlsx':
          if (!xlsx) throw KonroStorageError("The 'xlsx' format requires 'xlsx' to be installed. Please run 'npm install xlsx'.");
          return {
            parse: <T>(data: string, tableSchema?: Record<string, ColumnDefinition<any>>): T => {
              const workbook = xlsx.read(data, { type: 'base64' });
              const sheetName = workbook.SheetNames[0];
              if (!sheetName) return { records: [], meta: { lastId: 0 } } as T;
              const worksheet = workbook.Sheets[sheetName];
              const records = xlsx.utils.sheet_to_json(worksheet);
              const lastId = tableSchema ? deriveLastIdFromRecords(records, tableSchema) : 0;
              return { records, meta: { lastId } } as T;
            },
            stringify: (obj: any): string => {
              const worksheet = xlsx.utils.json_to_sheet(obj.records || []);
              const workbook = xlsx.utils.book_new();
              xlsx.utils.book_append_sheet(workbook, worksheet, 'data');
              return xlsx.write(workbook, { bookType: 'xlsx', type: 'base64' });
            },
          };
        default:
          throw KonroStorageError(`Unsupported or invalid format specified.`);
      }
    };
  src/db.ts: >-
    import path from 'path';

    import { AggregationDefinition, ColumnDefinition, KonroSchema,
    RelationDefinition } from './schema';

    import { StorageAdapter, FileStorageAdapter } from './adapter';

    import { DatabaseState, KRecord, TableState } from './types';

    import { _queryImpl, _insertImpl, _updateImpl, _deleteImpl, createEmptyState
    as createEmptyStateImpl, QueryDescriptor, _aggregateImpl,
    AggregationDescriptor } from './operations';

    import { createPredicateFromPartial } from './utils/predicate.util';

    import { KonroError, KonroStorageError } from './utils/error.util';

    import { writeAtomic } from './fs';


    // A helper to normalize a predicate argument

    const normalizePredicate = <T extends KRecord>(
      predicate: Partial<T> | ((record: T) => boolean)
    ): ((record: KRecord) => boolean) =>
      // The cast is necessary due to function argument contravariance.
      // The internal operations work on the wider `KRecord`, while the fluent API provides the specific `T`.
      (typeof predicate === 'function' ? predicate : createPredicateFromPartial(predicate)) as (record: KRecord) => boolean;

    // --- TYPE HELPERS for Fluent API ---


    type RelatedModel<T> = T extends (infer R)[] ? R : T extends (infer R |
    null) ? R : T;


    // TAll is the full relational model type, e.g. schema.types.users

    type WithArgument<TAll> = { // e.g. TAll = S['types']['users']
      [K in keyof TAll as NonNullable<TAll[K]> extends any[] | object ? K : never]?: boolean | ({
        where?: (record: RelatedModel<NonNullable<TAll[K]>>) => boolean;
      } & (
        | { select: Record<string, ColumnDefinition<unknown>>; with?: never }
        | { select?: never; with?: WithArgument<RelatedModel<NonNullable<TAll[K]>>> }
      ));
    };


    type ResolveWith<
      S extends KonroSchema<any, any>,
      TName extends keyof S['tables'],
      TWith extends WithArgument<S['types'][TName]>
    > = { // TName='users', TWith={posts: {with: {author: true}}}
        [K in keyof TWith & keyof S['relations'][TName]]:
            S['relations'][TName][K] extends { relationType: 'many' }
                ? ( // 'many' relation -> array result. K = 'posts'
                    TWith[K] extends { select: infer TSelect }
                        ? ({ [P in keyof TSelect]: InferColumnType<TSelect[P]> })[]
                        : TWith[K] extends { with: infer TNestedWith }
                            // S['relations']['users']['posts']['targetTable'] = 'posts'
                            ? (S['base'][S['relations'][TName][K]['targetTable']] & ResolveWith<S, S['relations'][TName][K]['targetTable'], TNestedWith & WithArgument<S['types'][S['relations'][TName][K]['targetTable']]>>)[]
                            // posts: true.
                            : S['base'][S['relations'][TName][K]['targetTable']][]
                  )
                : S['relations'][TName][K] extends { relationType: 'one' }
                    ? ( // 'one' relation -> nullable object result
                        TWith[K] extends { select: infer TSelect }
                            ? ({ [P in keyof TSelect]: InferColumnType<TSelect[P]> }) | null
                            : TWith[K] extends { with: infer TNestedWith }
                                ? (S['base'][S['relations'][TName][K]['targetTable']] & ResolveWith<S, S['relations'][TName][K]['targetTable'], TNestedWith & WithArgument<S['types'][S['relations'][TName][K]['targetTable']]>>) | null
                                : S['base'][S['relations'][TName][K]['targetTable']] | null
                      )
                    : never
    };


    // InferColumnType is not exported from schema, so we need it here too.

    type InferColumnType<C> = C extends ColumnDefinition<infer T> ? T : never;


    // --- IN-MEMORY API TYPES (STATEFUL) ---


    interface ChainedQueryBuilder<S extends KonroSchema<any, any>, TName extends
    keyof S['tables'], TReturn> {
      select(fields: Record<string, ColumnDefinition<unknown> | RelationDefinition>): this;
      where(predicate: Partial<S['base'][TName]> | ((record: S['base'][TName]) => boolean)): this;
      withDeleted(): this;
      with<W extends WithArgument<S['types'][TName]>>(relations: W): ChainedQueryBuilder<S, TName, TReturn & ResolveWith<S, TName, W>>;
      limit(count: number): this;
      offset(count: number): this;
      all(): TReturn[];
      first(): TReturn | null;
      aggregate<TAggs extends Record<string, AggregationDefinition>>(
        aggregations: TAggs
      ): { [K in keyof TAggs]: number | null };
    }


    interface QueryBuilder<S extends KonroSchema<any, any>> {
      from<T extends keyof S['tables']>(tableName: T): ChainedQueryBuilder<S, T, S['base'][T]>;
    }


    interface UpdateBuilder<S extends KonroSchema<any, any>, TBase, TCreate> {
      set(data: Partial<TCreate>): {
        where(predicate: Partial<TBase> | ((record: TBase) => boolean)): [DatabaseState<S>, TBase[]];
      };
    }


    interface DeleteBuilder<S extends KonroSchema<any, any>, TBase> {
      where(predicate: Partial<TBase> | ((record: TBase) => boolean)): [DatabaseState<S>, TBase[]];
    }


    export interface InMemoryDbContext<S extends KonroSchema<any, any>> {
      schema: S;
      adapter: StorageAdapter;
      read(): Promise<DatabaseState<S>>;
      write(state: DatabaseState<S>): Promise<void>;
      createEmptyState(): DatabaseState<S>;

      query(state: DatabaseState<S>): QueryBuilder<S>;
      insert<T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T, values: S['create'][T]): [DatabaseState<S>, S['base'][T]];
      insert<T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T, values: Readonly<S['create'][T]>[]): [DatabaseState<S>, S['base'][T][]];
      update<T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T): UpdateBuilder<S, S['base'][T], S['create'][T]>;
      delete<T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T): DeleteBuilder<S, S['base'][T]>;
    }



    // --- ON-DEMAND API TYPES (STATELESS & ASYNC) ---


    interface OnDemandChainedQueryBuilder<S extends KonroSchema<any, any>, TName
    extends keyof S['tables'], TReturn> {
      select(fields: Record<string, ColumnDefinition<unknown> | RelationDefinition>): this;
      where(predicate: Partial<S['base'][TName]> | ((record: S['base'][TName]) => boolean)): this;
      withDeleted(): this;
      with<W extends WithArgument<S['types'][TName]>>(relations: W): OnDemandChainedQueryBuilder<S, TName, TReturn & ResolveWith<S, TName, W>>;
      limit(count: number): this;
      offset(count: number): this;
      all(): Promise<TReturn[]>;
      first(): Promise<TReturn | null>;
      aggregate<TAggs extends Record<string, AggregationDefinition>>(
        aggregations: TAggs
      ): Promise<{ [K in keyof TAggs]: number | null }>;
    }


    interface OnDemandQueryBuilder<S extends KonroSchema<any, any>> {
      from<T extends keyof S['tables']>(tableName: T): OnDemandChainedQueryBuilder<S, T, S['base'][T]>;
    }


    interface OnDemandUpdateBuilder<TBase, TCreate> {
      set(data: Partial<TCreate>): {
        where(predicate: Partial<TBase> | ((record: TBase) => boolean)): Promise<TBase[]>;
      };
    }


    interface OnDemandDeleteBuilder<TBase> {
      where(predicate: Partial<TBase> | ((record: TBase) => boolean)): Promise<TBase[]>;
    }


    export interface OnDemandDbContext<S extends KonroSchema<any, any>> {
      schema: S;
      adapter: StorageAdapter;
      read(): Promise<never>; // Not supported in on-demand mode
      write(): Promise<never>; // Not supported in on-demand mode
      createEmptyState(): DatabaseState<S>;

      query(): OnDemandQueryBuilder<S>;
      insert<T extends keyof S['tables']>(tableName: T, values: S['create'][T]): Promise<S['base'][T]>;
      insert<T extends keyof S['tables']>(tableName: T, values: Readonly<S['create'][T]>[]): Promise<S['base'][T][]>;
      update<T extends keyof S['tables']>(tableName: T): OnDemandUpdateBuilder<S['base'][T], S['create'][T]>;
      delete<T extends keyof S['tables']>(tableName: T): OnDemandDeleteBuilder<S['base'][T]>;
    }


    // --- DbContext Union Type ---

    export type DbContext<S extends KonroSchema<any, any>> =
    InMemoryDbContext<S> | OnDemandDbContext<S>;


    // --- CORE LOGIC (STATELESS & PURE) ---


    /**
     * Creates the core, stateless database operations.
     * These operations are pure functions that take a database state and return a new state,
     * forming the foundation for both in-memory and on-demand modes.
     */
    function createCoreDbContext<S extends KonroSchema<any, any>>(schema: S) {
      const query = (state: DatabaseState<S>): QueryBuilder<S> => ({
        from: <TName extends keyof S['tables']>(tableName: TName): ChainedQueryBuilder<S, TName, S['base'][TName]> => {
          const createBuilder = <TReturn>(currentDescriptor: QueryDescriptor): ChainedQueryBuilder<S, TName, TReturn> => ({
            select(fields) { return createBuilder<TReturn>({ ...currentDescriptor, select: fields }); },
            where(predicate) { return createBuilder<TReturn>({ ...currentDescriptor, where: normalizePredicate(predicate as Parameters<typeof normalizePredicate>[0]) }); },
            withDeleted() { return createBuilder<TReturn>({ ...currentDescriptor, withDeleted: true }); },
            with<W extends WithArgument<S['types'][TName]>>(relations: W) {
              const newWith = { ...currentDescriptor.with, ...(relations as QueryDescriptor['with']) };
              return createBuilder<TReturn & ResolveWith<S, TName, W>>({ ...currentDescriptor, with: newWith });
            },
            limit(count) { return createBuilder<TReturn>({ ...currentDescriptor, limit: count }); },
            offset(count) { return createBuilder<TReturn>({ ...currentDescriptor, offset: count }); },
            all: (): TReturn[] => _queryImpl(state as DatabaseState, schema, currentDescriptor) as TReturn[],
            first: (): TReturn | null => (_queryImpl(state as DatabaseState, schema, { ...currentDescriptor, limit: 1 })[0] ?? null) as TReturn | null,
            aggregate: <TAggs extends Record<string, AggregationDefinition>>(aggregations: TAggs) => {
              const aggDescriptor: AggregationDescriptor = { ...currentDescriptor, aggregations };
              return _aggregateImpl(state as DatabaseState, schema, aggDescriptor) as { [K in keyof TAggs]: number | null };
            },
          });
          return createBuilder<S['base'][TName]>({ tableName: tableName as string });
        },
      });

      const insert = <T extends keyof S['tables']>(
        state: DatabaseState<S>, tableName: T, values: S['create'][T] | Readonly<S['create'][T]>[]
      ): [DatabaseState<S>, S['base'][T] | S['base'][T][]] => {
        const valsArray = Array.isArray(values) ? values : [values];
        const [newState, inserted] = _insertImpl(state as DatabaseState, schema, tableName as string, valsArray as KRecord[]);
        const result = Array.isArray(values) ? inserted : inserted[0];
        return [newState as DatabaseState<S>, result] as [DatabaseState<S>, S['base'][T] | S['base'][T][]];
      };

      const update = <T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T): UpdateBuilder<S, S['base'][T], S['create'][T]> => ({
        set: (data) => ({
          where: (predicate) => {
            const [newState, updatedRecords] = _updateImpl(state as DatabaseState, schema, tableName as string, data as Partial<KRecord>, normalizePredicate(predicate as Parameters<typeof normalizePredicate>[0]));
            return [newState as DatabaseState<S>, updatedRecords as S['base'][T][]];
          },
        }),
      });

      const del = <T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T): DeleteBuilder<S, S['base'][T]> => ({
        where: (predicate) => {
          const [newState, deletedRecords] = _deleteImpl(state as DatabaseState, schema, tableName as string, normalizePredicate(predicate as Parameters<typeof normalizePredicate>[0]));
          return [newState as DatabaseState<S>, deletedRecords as S['base'][T][]];
        },
      });

      return { query, insert, update, delete: del };
    }


    // --- ON-DEMAND CONTEXT (STATEFUL WRAPPER) ---


    type CoreDbContext<S extends KonroSchema<any, any>> = ReturnType<typeof
    createCoreDbContext<S>>;


    /** Defines the contract for file I/O operations in on-demand mode. */

    interface OnDemandIO<S extends KonroSchema<any, any>> {
      getFullState(): Promise<DatabaseState<S>>;
      insert(core: CoreDbContext<S>, tableName: string, values: any): Promise<any>;
      update(core: CoreDbContext<S>, tableName: string, data: Partial<unknown>, predicate: (record: KRecord) => boolean): Promise<KRecord[]>;
      delete(core: CoreDbContext<S>, tableName: string, predicate: (record: KRecord) => boolean): Promise<KRecord[]>;
    }


    /**
     * Creates a generic, unified `OnDemandDbContext` from an I/O strategy.
     * This function is the key to removing duplication between 'multi-file' and 'per-record' modes.
     */
    function createOnDemandDbContext<S extends KonroSchema<any, any>>(
      schema: S,
      adapter: StorageAdapter,
      core: CoreDbContext<S>,
      io: OnDemandIO<S>
    ): OnDemandDbContext<S> {
      const query = (): OnDemandQueryBuilder<S> => ({
        from: <TName extends keyof S['tables']>(tableName: TName): OnDemandChainedQueryBuilder<S, TName, S['base'][TName]> => {
          const createBuilder = <TReturn>(currentDescriptor: QueryDescriptor): OnDemandChainedQueryBuilder<S, TName, TReturn> => ({
            select(fields) { return createBuilder<TReturn>({ ...currentDescriptor, select: fields }); },
            where(predicate) { return createBuilder<TReturn>({ ...currentDescriptor, where: normalizePredicate(predicate as Parameters<typeof normalizePredicate>[0]) }); },
            withDeleted() { return createBuilder<TReturn>({ ...currentDescriptor, withDeleted: true }); },
            with<W extends WithArgument<S['types'][TName]>>(relations: W) {
              const newWith = { ...currentDescriptor.with, ...(relations as QueryDescriptor['with']) };
              return createBuilder<TReturn & ResolveWith<S, TName, W>>({ ...currentDescriptor, with: newWith });
            },
            limit(count) { return createBuilder<TReturn>({ ...currentDescriptor, limit: count }); },
            offset(count) { return createBuilder<TReturn>({ ...currentDescriptor, offset: count }); },
            all: async (): Promise<TReturn[]> => {
              const state = await io.getFullState();
              return _queryImpl(state, schema, currentDescriptor) as TReturn[];
            },
            first: async (): Promise<TReturn | null> => {
              const state = await io.getFullState();
              return (_queryImpl(state, schema, { ...currentDescriptor, limit: 1 })[0] ?? null) as TReturn | null;
            },
            aggregate: async <TAggs extends Record<string, AggregationDefinition>>(aggregations: TAggs) => {
              const state = await io.getFullState();
              const aggDescriptor: AggregationDescriptor = { ...currentDescriptor, aggregations };
              return _aggregateImpl(state, schema, aggDescriptor) as { [K in keyof TAggs]: number | null };
            },
          });
          return createBuilder<S['base'][TName]>({ tableName: tableName as string });
        },
      });

      const insert = <T extends keyof S['tables']>(tableName: T, values: S['create'][T] | Readonly<S['create'][T]>[]): Promise<any> =>
        io.insert(core, tableName as string, values);

      const update = <T extends keyof S['tables']>(tableName: T): OnDemandUpdateBuilder<S['base'][T], S['create'][T]> => ({
        set: (data) => ({
          where: (predicate) => io.update(core, tableName as string, data, normalizePredicate(predicate as Parameters<typeof normalizePredicate>[0])) as Promise<S['base'][T][]>,
        }),
      });

      const del = <T extends keyof S['tables']>(tableName: T): OnDemandDeleteBuilder<S['base'][T]> => ({
        where: (predicate) => io.delete(core, tableName as string, normalizePredicate(predicate as Parameters<typeof normalizePredicate>[0])) as Promise<S['base'][T][]>,
      });

      const notSupported = () => Promise.reject(KonroError("This method is not supported in 'on-demand' mode."));

      return { schema, adapter, createEmptyState: () => createEmptyStateImpl(schema), read: notSupported, write: notSupported, query, insert, update, delete: del };
    }



    // --- DATABASE FACTORY ---


    export function createDatabase<
      S extends KonroSchema<any, any>,
      TAdapter extends StorageAdapter,
    >(
      options: { schema: S; adapter: TAdapter }
    ): TAdapter['mode'] extends 'on-demand' ? OnDemandDbContext<S> :
    InMemoryDbContext<S>;

    export function createDatabase<S extends KonroSchema<any, any>>(
      options: { schema: S; adapter: StorageAdapter }
    ): DbContext<S> {
      const { schema, adapter } = options;
      const core = createCoreDbContext(schema);

      // --- In-Memory Mode ---
      if (adapter.mode === 'in-memory') {
        return {
          ...core,
          schema, adapter,
          read: () => adapter.read(schema),
          write: (state) => adapter.write(state, schema),
          createEmptyState: () => createEmptyStateImpl(schema),
        } as InMemoryDbContext<S>;
      }

      // --- On-Demand Mode ---
      const fileAdapter = adapter as FileStorageAdapter; // We can be sure it's a FileStorageAdapter due to checks
      const { fs, serializer, fileExtension } = fileAdapter;

      // The `read` method from the adapter provides the canonical way to get the full state.
      const getFullState = (): Promise<DatabaseState<S>> => adapter.read(schema);
      
      // --- I/O Strategy for Multi-File ---
      const createMultiFileIO = (): OnDemandIO<S> => {
        const { dir } = fileAdapter.options.multi!;
        const getTablePath = (tableName: string) => path.join(dir, `${tableName}${fileExtension}`);

        const readTableState = async (tableName: string): Promise<TableState> => {
          const data = await fs.readFile(getTablePath(tableName));
          if (!data) return { records: [], meta: { lastId: 0 } };
          try {
            return serializer.parse(data, schema.tables[tableName]);
          } catch (e: any) {
            throw KonroStorageError(`Failed to parse file at "${getTablePath(tableName)}". Original error: ${e.message}`);
          }
        };

        const writeTableState = async (tableName: string, tableState: TableState): Promise<void> => {
          await fs.mkdir(dir, { recursive: true });
          await writeAtomic(getTablePath(tableName), serializer.stringify(tableState), fs);
        };

        return {
          getFullState,
          insert: async (core, tableName, values) => {
            const state = createEmptyStateImpl(schema);
            (state as any)[tableName] = await readTableState(tableName);
            const [newState, result] = core.insert(state, tableName as keyof S['tables'], values as any);
            await writeTableState(tableName, newState[tableName]!);
            return result;
          },
          update: async (core, tableName, data, predicate) => {
            const state = createEmptyStateImpl(schema);
            (state as any)[tableName] = await readTableState(tableName);
            const [newState, result] = core.update(state, tableName as keyof S["tables"]).set(data as any).where(predicate);
            if (result.length > 0) await writeTableState(tableName, newState[tableName]!);
            return result as any;
          },
          delete: async (core, tableName, predicate) => {
            const state = await getFullState(); // Cascades require full state
            const [newState, deletedRecords] = core.delete(state, tableName as keyof S["tables"]).where(predicate);
            const changedTables = Object.keys(newState).filter(k => newState[k as keyof typeof newState] !== state[k as keyof typeof state]);
            await Promise.all(changedTables.map(t => writeTableState(t, newState[t as keyof typeof newState]!)));
            return deletedRecords as any;
          },
        };
      };

      // --- I/O Strategy for Per-Record ---
      const createPerRecordIO = (): OnDemandIO<S> => {
        const { dir } = fileAdapter.options.perRecord!;
        const getTableDir = (tableName: string) => path.join(dir, tableName);
        const getRecordPath = (tableName: string, id: any) => path.join(getTableDir(tableName), `${id}${fileExtension}`);
        const getMetaPath = (tableName: string) => path.join(getTableDir(tableName), '_meta.json');
        const getIdColumn = (tableName: string) => {
          const col = Object.keys(schema.tables[tableName]).find(k => schema.tables[tableName][k]?.dataType === 'id');
          if (!col) throw KonroError(`Table "${tableName}" needs an 'id' column for 'per-record' mode.`);
          return col;
        };

        return {
          getFullState,
          insert: async (core, tableName, values) => {
            const metaContent = await fs.readFile(getMetaPath(tableName)).catch(() => null);
            const meta = metaContent ? JSON.parse(metaContent) : { lastId: 0 };
            const idCol = getIdColumn(tableName);

            // Perform insert without existing records for performance
            const [newState, inserted] = core.insert({ [tableName]: { records: [], meta } } as any, tableName as keyof S['tables'], values as any);
            const insertedArr = Array.isArray(inserted) ? inserted : (inserted ? [inserted] : []);
            if (insertedArr.length === 0) return inserted;

            // Write new records and update meta if it changed
            await fs.mkdir(getTableDir(tableName), { recursive: true });
            const newMeta = newState[tableName]?.meta;
            const promises = insertedArr.map((r) => writeAtomic(getRecordPath(tableName, r[idCol]), serializer.stringify(r), fs));
            if (newMeta && newMeta.lastId !== meta.lastId) {
              promises.push(writeAtomic(getMetaPath(tableName), JSON.stringify(newMeta, null, 2), fs));
            }
            await Promise.all(promises);
            return inserted;
          },
          update: async (core, tableName, data, predicate) => {
            const state = await getFullState(); // Update needs full table state for predicate
            const [newState, updated] = core.update(state, tableName as keyof S["tables"]).set(data as any).where(predicate);
            if (updated.length === 0) return updated as any;

            const idCol = getIdColumn(tableName);
            await Promise.all(updated.map((r: any) => writeAtomic(getRecordPath(tableName, r[idCol]), serializer.stringify(r), fs)));
            
            const newMeta = newState[tableName]?.meta;
            const oldMeta = state[tableName as keyof typeof state]?.meta;
            if (newMeta && JSON.stringify(newMeta) !== JSON.stringify(oldMeta)) {
                await writeAtomic(getMetaPath(tableName), JSON.stringify(newMeta, null, 2), fs);
            }
            return updated as any;
          },
          delete: async (core, tableName, predicate) => {
            const oldState = await getFullState();
            const [newState, deletedRecords] = core.delete(oldState, tableName as keyof S["tables"]).where(predicate);
            if (deletedRecords.length === 0) return deletedRecords as any;

            const changes = Object.keys(schema.tables).map(async tName => {
              const oldTState = oldState[tName as keyof typeof oldState]!;
              const newTState = newState[tName as keyof typeof newState]!;
              if (oldTState === newTState) return;

              const idCol = getIdColumn(tName);
              const oldMap = new Map(oldTState.records.map((r: any) => [r[idCol], r]));
              const newMap = new Map(newTState.records.map((r: any) => [r[idCol], r]));
              
              const promises: Promise<void>[] = [];
              if (JSON.stringify(oldTState.meta) !== JSON.stringify(newTState.meta)) {
                promises.push(fs.mkdir(getTableDir(tName), { recursive: true }).then(() =>
                  writeAtomic(getMetaPath(tName), JSON.stringify(newTState.meta, null, 2), fs))
                );
              }
              newMap.forEach((rec, id) => {
                if (oldMap.get(id) !== rec) promises.push(writeAtomic(getRecordPath(tName, id), serializer.stringify(rec), fs));
              });
              oldMap.forEach((_rec, id) => {
                if (!newMap.has(id)) promises.push(fs.unlink(getRecordPath(tName, id)));
              });
              await Promise.all(promises);
            });

            await Promise.all(changes);
            return deletedRecords as any;
          },
        };
      };

      const io = fileAdapter.options.multi ? createMultiFileIO() : fileAdapter.options.perRecord ? createPerRecordIO() : null;
      if (!io) {
        throw KonroError("The 'on-demand' mode requires a 'multi-file' or 'per-record' storage strategy.");
      }
      
      return createOnDemandDbContext(schema, adapter, core, io);
    }
approved: true

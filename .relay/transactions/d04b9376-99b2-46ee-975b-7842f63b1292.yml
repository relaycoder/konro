uuid: d04b9376-99b2-46ee-975b-7842f63b1292
projectId: konro
createdAt: '2025-07-09T19:30:15.913Z'
linesAdded: 10
linesRemoved: 12
reasoning:
  - Reverting transaction 442657e2-45e0-4786-bb35-77a87e596ac1.
  - >-
    Reasoning from original transaction: Of course. Dealing with deeply
    recursive types in TypeScript can be challenging, but applying
    depth-limiting patterns is an effective strategy to prevent type-checking
    errors and improve language server performance. I will apply this principle
    to your library's fluent query API, which is the most likely source of these
    issues due to its highly recursive nature. Specifically, I'll modify the
    `WithArgument`, `ResolveWith`, and related query builder types in
    `src/types.ts`. ### Step-by-step Reasoning: 1.  **Introduce a Depth-Limiting
    Mechanism**: I'll first define a `Prev` utility type. This is a tuple of
    numbers that acts as a lookup table to decrement a number literal type,
    which is essential for controlling recursion depth. 2.  **Update
    `WithArgument`**: I'll modify the `WithArgument` type to accept a `TDepth`
    generic parameter, defaulting to a reasonable depth (e.g., 5 levels). In
    each recursive step within the `with` property, it will pass `Prev[TDepth]`,
    effectively decrementing the allowed depth. When the depth reaches `never`
    (after 0), it resolves to an empty object `{}`, terminating the recursion
    and preventing further nesting. 3.  **Update `ResolveWith`**: This type
    resolves the return shape from a `with` clause. Its recursive structure
    mirrors `WithArgument`. I will update its `TWith` constraint to
    `WithArgument<S, TName, any>` to accept `WithArgument` types of any depth.
    I'll also simplify the recursive call inside it. The inferred `TNestedWith`
    type already carries the correct (decremented) depth information, so the
    previous intersection with a new `WithArgument` was both redundant and
    problematic with explicit depth tracking. 4.  **Update Query Builders**:
    Finally, I will update the `.with()` method signature in both
    `ChainedQueryBuilder` and `OnDemandChainedQueryBuilder`. The generic
    constraint for the `relations` argument (`W`) will be changed to `extends
    WithArgument<S, TName, any>` to correctly handle the new depth-limited type.
    These changes will make your recursive types finite and prevent the "type
    instantiation is excessively deep" error, stabilizing both your linter and
    the TypeScript compiler for consumers of your library. Here are the changes
    for `src/types.ts`:
operations:
  - type: write
    path: src/types.ts
    content: "// --- Schema Definition Types (from schema.ts) ---\r\n\r\n/** The definition for a database column, created by helpers like `konro.string()`. */\r\nexport interface ColumnDefinition<T> {\r\n  readonly _type: 'column';\r\n  readonly dataType: 'id' | 'string' | 'number' | 'boolean' | 'date' | 'object';\r\n  readonly options: any;\r\n  readonly _tsType?: T; // Phantom type, does not exist at runtime\r\n}\r\n\r\n/** The definition for a table relationship, created by `konro.one()` or `konro.many()`. */\r\nexport interface BaseRelationDefinition {\r\n  readonly _type: 'relation';\r\n  readonly targetTable: string;\r\n  readonly on: string;\r\n  readonly references: string;\r\n  readonly onDelete?: 'CASCADE' | 'SET NULL';\r\n}\r\n\r\nexport interface OneRelationDefinition extends BaseRelationDefinition {\r\n  readonly relationType: 'one';\r\n}\r\n\r\nexport interface ManyRelationDefinition extends BaseRelationDefinition {\r\n  readonly relationType: 'many';\r\n}\r\n\r\nexport type RelationDefinition = OneRelationDefinition | ManyRelationDefinition;\r\n\r\n/** The definition for a data aggregation, created by `konro.count()`, `konro.sum()`, etc. */\r\nexport interface AggregationDefinition {\r\n  readonly _type: 'aggregation';\r\n  readonly aggType: 'count' | 'sum' | 'avg' | 'min' | 'max';\r\n  readonly column?: string;\r\n}\r\n\r\n/** Infers the underlying TypeScript type from a `ColumnDefinition`. e.g., `ColumnDefinition<string>` => `string`. */\r\ntype InferColumnType<C> = C extends ColumnDefinition<infer T> ? T : never;\r\n\r\n/** A mapping of table names to their base model types (columns only, no relations). */\r\nexport type BaseModels<TTables extends Record<string, any>> = {\r\n  [TableName in keyof TTables]: {\r\n    [ColumnName in keyof TTables[TableName]]: InferColumnType<TTables[TableName][ColumnName]>;\r\n  };\r\n};\r\n\r\n/** A mapping of table names to their full model types, including relations. */\r\ntype Models<\r\n  TTables extends Record<string, any>,\r\n  TRelations extends Record<string, any>,\r\n  TBaseModels extends Record<keyof TTables, any>\r\n> = {\r\n  [TableName in keyof TTables]: TBaseModels[TableName] &\r\n    (TableName extends keyof TRelations\r\n      ? {\r\n          [RelationName in keyof TRelations[TableName]]?: TRelations[TableName][RelationName] extends OneRelationDefinition\r\n            ? Models<TTables, TRelations, TBaseModels>[TRelations[TableName][RelationName]['targetTable']] | null\r\n            : TRelations[TableName][RelationName] extends ManyRelationDefinition\r\n            ? Models<TTables, TRelations, TBaseModels>[TRelations[TableName][RelationName]['targetTable']][]\r\n            : never;\r\n        }\r\n      : {});\r\n};\r\n\r\n/** Finds all column names in a table definition that are optional for insertion (i.e., `id`, has a `default`, or is `optional`). */\r\ntype OptionalCreateKeys<TTableDef> = {\r\n  [K in keyof TTableDef]: TTableDef[K] extends { dataType: 'id' }\r\n    ? K\r\n    : TTableDef[K] extends { options: { default: unknown } }\r\n    ? K\r\n    : TTableDef[K] extends { options: { optional: true } }\r\n    ? K\r\n    : never;\r\n}[keyof TTableDef];\r\n\r\n/** A mapping of table names to their \"create\" types, used for `db.insert`. */\r\ntype CreateModels<\r\n  TTables extends Record<string, any>,\r\n  TBaseModels extends Record<keyof TTables, any>\r\n> = {\r\n  [TableName in keyof TTables]: Omit<\r\n    {\r\n      // Required fields\r\n      [K in Exclude<keyof TBaseModels[TableName], OptionalCreateKeys<TTables[TableName]>>]: TBaseModels[TableName][K];\r\n    } & {\r\n      // Optional fields\r\n      [K in OptionalCreateKeys<TTables[TableName]>]?: TBaseModels[TableName][K];\r\n    },\r\n    // 'id' is always omitted from create types\r\n    'id'\r\n  >;\r\n};\r\n\r\n/** The publicly exposed structure of a fully-processed Konro schema. */\r\nexport interface KonroSchema<\r\n  TTables extends Record<string, any>,\r\n  TRelations extends Record<string, any>\r\n> {\r\n  tables: TTables;\r\n  relations: TRelations;\r\n  /** The full, relational types for each table model. */\r\n  types: Models<TTables, TRelations, BaseModels<TTables>>;\r\n  /** The base types for each table model, without any relations. */\r\n  base: BaseModels<TTables>;\r\n  /** The types for creating new records, with defaults and `id` made optional. */\r\n  create: CreateModels<TTables, BaseModels<TTables>>;\r\n}\r\n\r\n\r\n// --- Generic & Core Types ---\r\n\r\n/** A generic representation of a single record within a table. It uses `unknown` for values to enforce type-safe access. */\r\nexport type KRecord = Record<string, unknown>;\r\n\r\n/** Represents the state of a single table, including its records and metadata. */\r\nexport type TableState<T extends KRecord = KRecord> = {\r\n  records: T[];\r\n  meta: {\r\n    lastId: number;\r\n  };\r\n};\r\n\r\n/** The in-memory representation of the entire database. It is a plain, immutable object. */\r\nexport type DatabaseState<S extends KonroSchema<any, any> | unknown = unknown> = S extends KonroSchema<any, any>\r\n  ? {\r\n      [TableName in keyof S['tables']]: TableState<BaseModels<S['tables']>[TableName]>;\r\n    }\r\n  : {\r\n      [tableName: string]: TableState;\r\n    };\r\n\r\n\r\n// --- FS Provider Types (from fs.ts) ---\r\nexport interface FsProvider {\r\n  readFile(filepath: string): Promise<string | null>;\r\n  writeFile(filepath: string, content: string, encoding: 'utf-8'): Promise<void>;\r\n  rename(oldPath: string, newPath: string): Promise<void>;\r\n  mkdir(dir: string, options: { recursive: true }): Promise<string | undefined>;\r\n  readdir(dir: string): Promise<string[]>;\r\n  unlink(filepath: string): Promise<void>;\r\n}\r\n\r\n\r\n// --- Serializer Types (from utils/serializer.util.ts) ---\r\nexport type Serializer = {\r\n  parse: <T>(data: string, tableSchema?: Record<string, ColumnDefinition<any>>) => T;\r\n  stringify: (obj: any) => string;\r\n};\r\n\r\n\r\n// --- Storage Adapter Types (from adapter.ts) ---\r\n\r\nexport interface StorageAdapter {\r\n  read<S extends KonroSchema<any, any>>(schema: S): Promise<DatabaseState<S>>;\r\n  write(state: DatabaseState<any>, schema: KonroSchema<any, any>): Promise<void>;\r\n  readonly mode: 'in-memory' | 'on-demand';\r\n}\r\n\r\nexport interface FileStorageAdapter extends StorageAdapter {\r\n  readonly options: FileAdapterOptions;\r\n  readonly fs: FsProvider;\r\n  readonly serializer: Serializer;\r\n  readonly fileExtension: string;\r\n}\r\n\r\nexport type SingleFileStrategy = { single: { filepath: string }; multi?: never; perRecord?: never };\r\nexport type MultiFileStrategy = { multi: { dir: string }; single?: never; perRecord?: never };\r\nexport type PerRecordStrategy = { perRecord: { dir: string }; single?: never; multi?: never };\r\n\r\nexport type FileAdapterOptions = {\r\n  format: 'json' | 'yaml' | 'csv' | 'xlsx';\r\n  fs?: FsProvider;\r\n  /**\r\n   * Defines the data access strategy.\r\n   * - `in-memory`: (Default) Loads the entire database into memory on init. Fast for small/medium datasets.\r\n   * - `on-demand`: Reads from the file system for each query. Slower but supports larger datasets. Requires 'multi-file' or 'per-record' strategy.\r\n   */\r\n  mode?: 'in-memory' | 'on-demand';\r\n} & (SingleFileStrategy | MultiFileStrategy | PerRecordStrategy);\r\n\r\n\r\n// --- Operation Descriptor Types (from operations.ts) ---\r\n\r\nexport type WithClause = Record<string, boolean | {\r\n  where?: (record: KRecord) => boolean;\r\n  select?: Record<string, ColumnDefinition<unknown>>;\r\n  with?: WithClause;\r\n}>;\r\n\r\nexport interface QueryDescriptor {\r\n  tableName: string;\r\n  select?: Record<string, ColumnDefinition<unknown> | RelationDefinition>;\r\n  where?: (record: KRecord) => boolean;\r\n  with?: WithClause;\r\n  limit?: number;\r\n  offset?: number;\r\n  withDeleted?: boolean;\r\n}\r\n\r\nexport interface AggregationDescriptor extends QueryDescriptor {\r\n  aggregations: Record<string, AggregationDefinition>;\r\n}\r\n\r\n\r\n// --- DB Context & Fluent API Types (from db.ts) ---\r\n\r\nexport type WithArgument<\n  S extends KonroSchema<any, any>,\n  TName extends keyof S['tables']\n> = {\n  [K in keyof S['relations'][TName]]?: boolean | ({\n    where?: (record: S['base'][S['relations'][TName][K]['targetTable']]) => boolean;\r\n  } & (\r\n    | { select: Record<string, ColumnDefinition<unknown>>; with?: never }\r\n    | { select?: never; with?: WithArgument<S, S['relations'][TName][K]['targetTable']> }\r\n  ));\r\n};\r\n\r\nexport type ResolveWith<\r\n  S extends KonroSchema<any, any>,\r\n  TName extends keyof S['tables'],\r\n  TWith extends WithArgument<S, TName>\r\n> = {\r\n  [K in keyof TWith & keyof S['relations'][TName]]:\r S['relations'][TName][K] extends { relationType: 'many' }\r\n    ? TWith[K] extends { select: infer TSelect }\r\n      ? { [P in keyof TSelect]: InferColumnType<TSelect[P]> }[]\r\n      : TWith[K] extends { with: infer TNestedWith }\r\n      ? (S['base'][S['relations'][TName][K]['targetTable']] &\n          ResolveWith<S, S['relations'][TName][K]['targetTable'], TNestedWith & WithArgument<S, S['relations'][TName][K]['targetTable']>>)[]\r\n      : S['base'][S['relations'][TName][K]['targetTable']][]\r\n    : S['relations'][TName][K] extends { relationType: 'one' }\r\n    ? TWith[K] extends { select: infer TSelect }\r\n      ? { [P in keyof TSelect]: InferColumnType<TSelect[P]> } | null\r\n      : TWith[K] extends { with: infer TNestedWith }\r\n      ? (S['base'][S['relations'][TName][K]['targetTable']] &\n          ResolveWith<S, S['relations'][TName][K]['targetTable'], TNestedWith & WithArgument<S, S['relations'][TName][K]['targetTable']>>) | null\r\n      : S['base'][S['relations'][TName][K]['targetTable']] | null\r\n    : never\r;\n};\r\n\r\nexport interface ChainedQueryBuilder<S extends KonroSchema<any, any>, TName extends keyof S['tables'], TReturn> {\r\n  select(fields: Record<string, ColumnDefinition<unknown> | RelationDefinition>): this;\r\n  where(predicate: Partial<S['base'][TName]> | ((record: S['base'][TName]) => boolean)): this;\r\n  withDeleted(): this;\r\n  with<W extends WithArgument<S, TName>>(relations: W): ChainedQueryBuilder<S, TName, TReturn & ResolveWith<S, TName, W>>;\r\n  limit(count: number): this;\r\n  offset(count: number): this;\r\n  all(): TReturn[];\r\n  first(): TReturn | null;\r\n  aggregate<TAggs extends Record<string, AggregationDefinition>>(\r\n    aggregations: TAggs\r\n  ): { [K in keyof TAggs]: number | null };\r\n}\r\n\r\nexport interface QueryBuilder<S extends KonroSchema<any, any>> {\r\n  from<T extends keyof S['tables']>(tableName: T): ChainedQueryBuilder<S, T, S['base'][T]>;\r\n}\r\n\r\nexport interface UpdateBuilder<S extends KonroSchema<any, any>, TBase, TCreate> {\r\n  set(data: Partial<TCreate>): {\r\n    where(predicate: Partial<TBase> | ((record: TBase) => boolean)): [DatabaseState<S>, TBase[]];\r\n  };\r\n}\r\n\r\nexport interface DeleteBuilder<S extends KonroSchema<any, any>, TBase> {\r\n  where(predicate: Partial<TBase> | ((record: TBase) => boolean)): [DatabaseState<S>, TBase[]];\r\n}\r\n\r\nexport interface InMemoryDbContext<S extends KonroSchema<any, any>> {\r\n  schema: S;\r\n  adapter: StorageAdapter;\r\n  read(): Promise<DatabaseState<S>>;\r\n  write(state: DatabaseState<S>): Promise<void>;\r\n  createEmptyState(): DatabaseState<S>;\r\n\r\n  query(state: DatabaseState<S>): QueryBuilder<S>;\r\n  insert<T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T, values: S['create'][T]): [DatabaseState<S>, S['base'][T]];\r\n  insert<T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T, values: Readonly<S['create'][T]>[]): [DatabaseState<S>, S['base'][T][]];\r\n  update<T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T): UpdateBuilder<S, S['base'][T], S['create'][T]>;\r\n  delete<T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T): DeleteBuilder<S, S['base'][T]>;\r\n}\r\n\r\nexport interface OnDemandChainedQueryBuilder<S extends KonroSchema<any, any>, TName extends keyof S['tables'], TReturn> {\r\n  select(fields: Record<string, ColumnDefinition<unknown> | RelationDefinition>): this;\r\n  where(predicate: Partial<S['base'][TName]> | ((record: S['base'][TName]) => boolean)): this;\r\n  withDeleted(): this;\r\n  with<W extends WithArgument<S, TName>>(relations: W): OnDemandChainedQueryBuilder<S, TName, TReturn & ResolveWith<S, TName, W>>;\r\n  limit(count: number): this;\r\n  offset(count: number): this;\r\n  all(): Promise<TReturn[]>;\r\n  first(): Promise<TReturn | null>;\r\n  aggregate<TAggs extends Record<string, AggregationDefinition>>(\r\n    aggregations: TAggs\r\n  ): Promise<{ [K in keyof TAggs]: number | null }>;\r\n}\r\n\r\nexport interface OnDemandQueryBuilder<S extends KonroSchema<any, any>> {\r\n  from<T extends keyof S['tables']>(tableName: T): OnDemandChainedQueryBuilder<S, T, S['base'][T]>;\r\n}\r\n\r\nexport interface OnDemandUpdateBuilder<TBase, TCreate> {\r\n  set(data: Partial<TCreate>): {\r\n    where(predicate: Partial<TBase> | ((record: TBase) => boolean)): Promise<TBase[]>;\r\n  };\r\n}\r\n\r\nexport interface OnDemandDeleteBuilder<TBase> {\r\n  where(predicate: Partial<TBase> | ((record: TBase) => boolean)): Promise<TBase[]>;\r\n}\r\n\r\nexport interface OnDemandDbContext<S extends KonroSchema<any, any>> {\r\n  schema: S;\r\n  adapter: StorageAdapter;\r\n  read(): Promise<never>;\r\n  write(): Promise<never>;\r\n  createEmptyState(): DatabaseState<S>;\r\n\r\n  query(): OnDemandQueryBuilder<S>;\r\n  insert<T extends keyof S['tables']>(tableName: T, values: S['create'][T]): Promise<S['base'][T]>;\r\n  insert<T extends keyof S['tables']>(tableName: T, values: Readonly<S['create'][T]>[]): Promise<S['base'][T][]>;\r\n  update<T extends keyof S['tables']>(tableName: T): OnDemandUpdateBuilder<S['base'][T], S['create'][T]>;\r\n  delete<T extends keyof S['tables']>(tableName: T): OnDemandDeleteBuilder<S['base'][T]>;\r\n}\r\n\r\nexport type DbContext<S extends KonroSchema<any, any>> = InMemoryDbContext<S> | OnDemandDbContext<S>;"
    patchStrategy: replace
snapshot:
  src/types.ts: "// --- Schema Definition Types (from schema.ts) ---\r\n\r\n/** The definition for a database column, created by helpers like `konro.string()`. */\r\nexport interface ColumnDefinition<T> {\r\n  readonly _type: 'column';\r\n  readonly dataType: 'id' | 'string' | 'number' | 'boolean' | 'date' | 'object';\r\n  readonly options: any;\r\n  readonly _tsType?: T; // Phantom type, does not exist at runtime\r\n}\r\n\r\n/** The definition for a table relationship, created by `konro.one()` or `konro.many()`. */\r\nexport interface BaseRelationDefinition {\r\n  readonly _type: 'relation';\r\n  readonly targetTable: string;\r\n  readonly on: string;\r\n  readonly references: string;\r\n  readonly onDelete?: 'CASCADE' | 'SET NULL';\r\n}\r\n\r\nexport interface OneRelationDefinition extends BaseRelationDefinition {\r\n  readonly relationType: 'one';\r\n}\r\n\r\nexport interface ManyRelationDefinition extends BaseRelationDefinition {\r\n  readonly relationType: 'many';\r\n}\r\n\r\nexport type RelationDefinition = OneRelationDefinition | ManyRelationDefinition;\r\n\r\n/** The definition for a data aggregation, created by `konro.count()`, `konro.sum()`, etc. */\r\nexport interface AggregationDefinition {\r\n  readonly _type: 'aggregation';\r\n  readonly aggType: 'count' | 'sum' | 'avg' | 'min' | 'max';\r\n  readonly column?: string;\r\n}\r\n\r\n/** Infers the underlying TypeScript type from a `ColumnDefinition`. e.g., `ColumnDefinition<string>` => `string`. */\r\ntype InferColumnType<C> = C extends ColumnDefinition<infer T> ? T : never;\r\n\r\n/** A mapping of table names to their base model types (columns only, no relations). */\r\nexport type BaseModels<TTables extends Record<string, any>> = {\r\n  [TableName in keyof TTables]: {\r\n    [ColumnName in keyof TTables[TableName]]: InferColumnType<TTables[TableName][ColumnName]>;\r\n  };\r\n};\r\n\r\n/** A mapping of table names to their full model types, including relations. */\r\ntype Models<\r\n  TTables extends Record<string, any>,\r\n  TRelations extends Record<string, any>,\r\n  TBaseModels extends Record<keyof TTables, any>\r\n> = {\r\n  [TableName in keyof TTables]: TBaseModels[TableName] &\r\n    (TableName extends keyof TRelations\r\n      ? {\r\n          [RelationName in keyof TRelations[TableName]]?: TRelations[TableName][RelationName] extends OneRelationDefinition\r\n            ? Models<TTables, TRelations, TBaseModels>[TRelations[TableName][RelationName]['targetTable']] | null\r\n            : TRelations[TableName][RelationName] extends ManyRelationDefinition\r\n            ? Models<TTables, TRelations, TBaseModels>[TRelations[TableName][RelationName]['targetTable']][]\r\n            : never;\r\n        }\r\n      : {});\r\n};\r\n\r\n/** Finds all column names in a table definition that are optional for insertion (i.e., `id`, has a `default`, or is `optional`). */\r\ntype OptionalCreateKeys<TTableDef> = {\r\n  [K in keyof TTableDef]: TTableDef[K] extends { dataType: 'id' }\r\n    ? K\r\n    : TTableDef[K] extends { options: { default: unknown } }\r\n    ? K\r\n    : TTableDef[K] extends { options: { optional: true } }\r\n    ? K\r\n    : never;\r\n}[keyof TTableDef];\r\n\r\n/** A mapping of table names to their \"create\" types, used for `db.insert`. */\r\ntype CreateModels<\r\n  TTables extends Record<string, any>,\r\n  TBaseModels extends Record<keyof TTables, any>\r\n> = {\r\n  [TableName in keyof TTables]: Omit<\r\n    {\r\n      // Required fields\r\n      [K in Exclude<keyof TBaseModels[TableName], OptionalCreateKeys<TTables[TableName]>>]: TBaseModels[TableName][K];\r\n    } & {\r\n      // Optional fields\r\n      [K in OptionalCreateKeys<TTables[TableName]>]?: TBaseModels[TableName][K];\r\n    },\r\n    // 'id' is always omitted from create types\r\n    'id'\r\n  >;\r\n};\r\n\r\n/** The publicly exposed structure of a fully-processed Konro schema. */\r\nexport interface KonroSchema<\r\n  TTables extends Record<string, any>,\r\n  TRelations extends Record<string, any>\r\n> {\r\n  tables: TTables;\r\n  relations: TRelations;\r\n  /** The full, relational types for each table model. */\r\n  types: Models<TTables, TRelations, BaseModels<TTables>>;\r\n  /** The base types for each table model, without any relations. */\r\n  base: BaseModels<TTables>;\r\n  /** The types for creating new records, with defaults and `id` made optional. */\r\n  create: CreateModels<TTables, BaseModels<TTables>>;\r\n}\r\n\r\n\r\n// --- Generic & Core Types ---\r\n\r\n/** A generic representation of a single record within a table. It uses `unknown` for values to enforce type-safe access. */\r\nexport type KRecord = Record<string, unknown>;\r\n\r\n/** Represents the state of a single table, including its records and metadata. */\r\nexport type TableState<T extends KRecord = KRecord> = {\r\n  records: T[];\r\n  meta: {\r\n    lastId: number;\r\n  };\r\n};\r\n\r\n/** The in-memory representation of the entire database. It is a plain, immutable object. */\r\nexport type DatabaseState<S extends KonroSchema<any, any> | unknown = unknown> = S extends KonroSchema<any, any>\r\n  ? {\r\n      [TableName in keyof S['tables']]: TableState<BaseModels<S['tables']>[TableName]>;\r\n    }\r\n  : {\r\n      [tableName: string]: TableState;\r\n    };\r\n\r\n\r\n// --- FS Provider Types (from fs.ts) ---\r\nexport interface FsProvider {\r\n  readFile(filepath: string): Promise<string | null>;\r\n  writeFile(filepath: string, content: string, encoding: 'utf-8'): Promise<void>;\r\n  rename(oldPath: string, newPath: string): Promise<void>;\r\n  mkdir(dir: string, options: { recursive: true }): Promise<string | undefined>;\r\n  readdir(dir: string): Promise<string[]>;\r\n  unlink(filepath: string): Promise<void>;\r\n}\r\n\r\n\r\n// --- Serializer Types (from utils/serializer.util.ts) ---\r\nexport type Serializer = {\r\n  parse: <T>(data: string, tableSchema?: Record<string, ColumnDefinition<any>>) => T;\r\n  stringify: (obj: any) => string;\r\n};\r\n\r\n\r\n// --- Storage Adapter Types (from adapter.ts) ---\r\n\r\nexport interface StorageAdapter {\r\n  read<S extends KonroSchema<any, any>>(schema: S): Promise<DatabaseState<S>>;\r\n  write(state: DatabaseState<any>, schema: KonroSchema<any, any>): Promise<void>;\r\n  readonly mode: 'in-memory' | 'on-demand';\r\n}\r\n\r\nexport interface FileStorageAdapter extends StorageAdapter {\r\n  readonly options: FileAdapterOptions;\r\n  readonly fs: FsProvider;\r\n  readonly serializer: Serializer;\r\n  readonly fileExtension: string;\r\n}\r\n\r\nexport type SingleFileStrategy = { single: { filepath: string }; multi?: never; perRecord?: never };\r\nexport type MultiFileStrategy = { multi: { dir: string }; single?: never; perRecord?: never };\r\nexport type PerRecordStrategy = { perRecord: { dir: string }; single?: never; multi?: never };\r\n\r\nexport type FileAdapterOptions = {\r\n  format: 'json' | 'yaml' | 'csv' | 'xlsx';\r\n  fs?: FsProvider;\r\n  /**\r\n   * Defines the data access strategy.\r\n   * - `in-memory`: (Default) Loads the entire database into memory on init. Fast for small/medium datasets.\r\n   * - `on-demand`: Reads from the file system for each query. Slower but supports larger datasets. Requires 'multi-file' or 'per-record' strategy.\r\n   */\r\n  mode?: 'in-memory' | 'on-demand';\r\n} & (SingleFileStrategy | MultiFileStrategy | PerRecordStrategy);\r\n\r\n\r\n// --- Operation Descriptor Types (from operations.ts) ---\r\n\r\nexport type WithClause = Record<string, boolean | {\r\n  where?: (record: KRecord) => boolean;\r\n  select?: Record<string, ColumnDefinition<unknown>>;\r\n  with?: WithClause;\r\n}>;\r\n\r\nexport interface QueryDescriptor {\r\n  tableName: string;\r\n  select?: Record<string, ColumnDefinition<unknown> | RelationDefinition>;\r\n  where?: (record: KRecord) => boolean;\r\n  with?: WithClause;\r\n  limit?: number;\r\n  offset?: number;\r\n  withDeleted?: boolean;\r\n}\r\n\r\nexport interface AggregationDescriptor extends QueryDescriptor {\r\n  aggregations: Record<string, AggregationDefinition>;\r\n}\r\n\r\n\r\n// --- DB Context & Fluent API Types (from db.ts) ---\r\n\r\n/** Utility type to decrement a number literal for recursion depth limiting. */\ntype Prev = [never, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; // Max depth of 10.\n\nexport type WithArgument<\n  S extends KonroSchema<any, any>,\n  TName extends keyof S['tables'],\n  TDepth extends number = 5\n> = TDepth extends never ? {} : {\n  [K in keyof S['relations'][TName]]?: boolean | ({\n    where?: (record: S['base'][S['relations'][TName][K]['targetTable']]) => boolean;\r\n  } & (\r\n    | { select: Record<string, ColumnDefinition<unknown>>; with?: never }\r\n    | { select?: never; with?: WithArgument<S, S['relations'][TName][K]['targetTable'], Prev[TDepth]> }\r\n  ));\r\n};\r\n\r\nexport type ResolveWith<\r\n  S extends KonroSchema<any, any>,\r\n  TName extends keyof S['tables'],\r\n  TWith extends WithArgument<S, TName, any>\r\n> = {\r\n  [K in keyof TWith & keyof S['relations'][TName]]:\r S['relations'][TName][K] extends { relationType: 'many' }\r\n    ? TWith[K] extends { select: infer TSelect }\r\n      ? { [P in keyof TSelect]: InferColumnType<TSelect[P]> }[]\r\n      : TWith[K] extends { with: infer TNestedWith }\r\n      ? (S['base'][S['relations'][TName][K]['targetTable']] & ResolveWith<S, S['relations'][TName][K]['targetTable'], TNestedWith>)[]\r\n      : S['base'][S['relations'][TName][K]['targetTable']][]\r\n    : S['relations'][TName][K] extends { relationType: 'one' }\r\n    ? TWith[K] extends { select: infer TSelect }\r\n      ? { [P in keyof TSelect]: InferColumnType<TSelect[P]> } | null\r\n      : TWith[K] extends { with: infer TNestedWith }\r\n      ? (S['base'][S['relations'][TName][K]['targetTable']] & ResolveWith<S, S['relations'][TName][K]['targetTable'], TNestedWith>) | null\r\n      : S['base'][S['relations'][TName][K]['targetTable']] | null\r\n    : never\r;\n};\r\n\r\nexport interface ChainedQueryBuilder<S extends KonroSchema<any, any>, TName extends keyof S['tables'], TReturn> {\r\n  select(fields: Record<string, ColumnDefinition<unknown> | RelationDefinition>): this;\r\n  where(predicate: Partial<S['base'][TName]> | ((record: S['base'][TName]) => boolean)): this;\r\n  withDeleted(): this;\r\n  with<W extends WithArgument<S, TName, any>>(relations: W): ChainedQueryBuilder<S, TName, TReturn & ResolveWith<S, TName, W>>;\r\n  limit(count: number): this;\r\n  offset(count: number): this;\r\n  all(): TReturn[];\r\n  first(): TReturn | null;\r\n  aggregate<TAggs extends Record<string, AggregationDefinition>>(\r\n    aggregations: TAggs\r\n  ): { [K in keyof TAggs]: number | null };\r\n}\r\n\r\nexport interface QueryBuilder<S extends KonroSchema<any, any>> {\r\n  from<T extends keyof S['tables']>(tableName: T): ChainedQueryBuilder<S, T, S['base'][T]>;\r\n}\r\n\r\nexport interface UpdateBuilder<S extends KonroSchema<any, any>, TBase, TCreate> {\r\n  set(data: Partial<TCreate>): {\r\n    where(predicate: Partial<TBase> | ((record: TBase) => boolean)): [DatabaseState<S>, TBase[]];\r\n  };\r\n}\r\n\r\nexport interface DeleteBuilder<S extends KonroSchema<any, any>, TBase> {\r\n  where(predicate: Partial<TBase> | ((record: TBase) => boolean)): [DatabaseState<S>, TBase[]];\r\n}\r\n\r\nexport interface InMemoryDbContext<S extends KonroSchema<any, any>> {\r\n  schema: S;\r\n  adapter: StorageAdapter;\r\n  read(): Promise<DatabaseState<S>>;\r\n  write(state: DatabaseState<S>): Promise<void>;\r\n  createEmptyState(): DatabaseState<S>;\r\n\r\n  query(state: DatabaseState<S>): QueryBuilder<S>;\r\n  insert<T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T, values: S['create'][T]): [DatabaseState<S>, S['base'][T]];\r\n  insert<T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T, values: Readonly<S['create'][T]>[]): [DatabaseState<S>, S['base'][T][]];\r\n  update<T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T): UpdateBuilder<S, S['base'][T], S['create'][T]>;\r\n  delete<T extends keyof S['tables']>(state: DatabaseState<S>, tableName: T): DeleteBuilder<S, S['base'][T]>;\r\n}\r\n\r\nexport interface OnDemandChainedQueryBuilder<S extends KonroSchema<any, any>, TName extends keyof S['tables'], TReturn> {\r\n  select(fields: Record<string, ColumnDefinition<unknown> | RelationDefinition>): this;\r\n  where(predicate: Partial<S['base'][TName]> | ((record: S['base'][TName]) => boolean)): this;\r\n  withDeleted(): this;\r\n  with<W extends WithArgument<S, TName, any>>(relations: W): OnDemandChainedQueryBuilder<S, TName, TReturn & ResolveWith<S, TName, W>>;\r\n  limit(count: number): this;\r\n  offset(count: number): this;\r\n  all(): Promise<TReturn[]>;\r\n  first(): Promise<TReturn | null>;\r\n  aggregate<TAggs extends Record<string, AggregationDefinition>>(\r\n    aggregations: TAggs\r\n  ): Promise<{ [K in keyof TAggs]: number | null }>;\r\n}\r\n\r\nexport interface OnDemandQueryBuilder<S extends KonroSchema<any, any>> {\r\n  from<T extends keyof S['tables']>(tableName: T): OnDemandChainedQueryBuilder<S, T, S['base'][T]>;\r\n}\r\n\r\nexport interface OnDemandUpdateBuilder<TBase, TCreate> {\r\n  set(data: Partial<TCreate>): {\r\n    where(predicate: Partial<TBase> | ((record: TBase) => boolean)): Promise<TBase[]>;\r\n  };\r\n}\r\n\r\nexport interface OnDemandDeleteBuilder<TBase> {\r\n  where(predicate: Partial<TBase> | ((record: TBase) => boolean)): Promise<TBase[]>;\r\n}\r\n\r\nexport interface OnDemandDbContext<S extends KonroSchema<any, any>> {\r\n  schema: S;\r\n  adapter: StorageAdapter;\r\n  read(): Promise<never>;\r\n  write(): Promise<never>;\r\n  createEmptyState(): DatabaseState<S>;\r\n\r\n  query(): OnDemandQueryBuilder<S>;\r\n  insert<T extends keyof S['tables']>(tableName: T, values: S['create'][T]): Promise<S['base'][T]>;\r\n  insert<T extends keyof S['tables']>(tableName: T, values: Readonly<S['create'][T]>[]): Promise<S['base'][T][]>;\r\n  update<T extends keyof S['tables']>(tableName: T): OnDemandUpdateBuilder<S['base'][T], S['create'][T]>;\r\n  delete<T extends keyof S['tables']>(tableName: T): OnDemandDeleteBuilder<S['base'][T]>;\r\n}\r\n\r\nexport type DbContext<S extends KonroSchema<any, any>> = InMemoryDbContext<S> | OnDemandDbContext<S>;"
approved: true
